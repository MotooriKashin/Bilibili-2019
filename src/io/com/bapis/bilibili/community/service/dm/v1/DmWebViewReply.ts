// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/community/service/dm/v1/DmWebViewReply.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bilibili.community.service.dm.v1";

export enum PostPanelBizType {
  PostPanelBizTypeNone = 0,
  PostPanelBizTypeEncourage = 1,
  PostPanelBizTypeFragClose = 4,
  PostPanelBizTypeColorDM = 2,
  UNRECOGNIZED = -1,
}

export function postPanelBizTypeFromJSON(object: any): PostPanelBizType {
  switch (object) {
    case 0:
    case "PostPanelBizTypeNone":
      return PostPanelBizType.PostPanelBizTypeNone;
    case 1:
    case "PostPanelBizTypeEncourage":
      return PostPanelBizType.PostPanelBizTypeEncourage;
    case 4:
    case "PostPanelBizTypeFragClose":
      return PostPanelBizType.PostPanelBizTypeFragClose;
    case 2:
    case "PostPanelBizTypeColorDM":
      return PostPanelBizType.PostPanelBizTypeColorDM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostPanelBizType.UNRECOGNIZED;
  }
}

export function postPanelBizTypeToJSON(object: PostPanelBizType): string {
  switch (object) {
    case PostPanelBizType.PostPanelBizTypeNone:
      return "PostPanelBizTypeNone";
    case PostPanelBizType.PostPanelBizTypeEncourage:
      return "PostPanelBizTypeEncourage";
    case PostPanelBizType.PostPanelBizTypeFragClose:
      return "PostPanelBizTypeFragClose";
    case PostPanelBizType.PostPanelBizTypeColorDM:
      return "PostPanelBizTypeColorDM";
    case PostPanelBizType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RenderType {
  RenderTypeNone = 0,
  RenderTypeSingle = 1,
  RenderTypeRotation = 2,
  UNRECOGNIZED = -1,
}

export function renderTypeFromJSON(object: any): RenderType {
  switch (object) {
    case 0:
    case "RenderTypeNone":
      return RenderType.RenderTypeNone;
    case 1:
    case "RenderTypeSingle":
      return RenderType.RenderTypeSingle;
    case 2:
    case "RenderTypeRotation":
      return RenderType.RenderTypeRotation;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RenderType.UNRECOGNIZED;
  }
}

export function renderTypeToJSON(object: RenderType): string {
  switch (object) {
    case RenderType.RenderTypeNone:
      return "RenderTypeNone";
    case RenderType.RenderTypeSingle:
      return "RenderTypeSingle";
    case RenderType.RenderTypeRotation:
      return "RenderTypeRotation";
    case RenderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PostStatus {
  PostStatusNormal = 0,
  PostStatusClosed = 1,
  UNRECOGNIZED = -1,
}

export function postStatusFromJSON(object: any): PostStatus {
  switch (object) {
    case 0:
    case "PostStatusNormal":
      return PostStatus.PostStatusNormal;
    case 1:
    case "PostStatusClosed":
      return PostStatus.PostStatusClosed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostStatus.UNRECOGNIZED;
  }
}

export function postStatusToJSON(object: PostStatus): string {
  switch (object) {
    case PostStatus.PostStatusNormal:
      return "PostStatusNormal";
    case PostStatus.PostStatusClosed:
      return "PostStatusClosed";
    case PostStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CheckboxType {
  CheckboxTypeNone = 0,
  CheckboxTypeEncourage = 1,
  UNRECOGNIZED = -1,
}

export function checkboxTypeFromJSON(object: any): CheckboxType {
  switch (object) {
    case 0:
    case "CheckboxTypeNone":
      return CheckboxType.CheckboxTypeNone;
    case 1:
    case "CheckboxTypeEncourage":
      return CheckboxType.CheckboxTypeEncourage;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckboxType.UNRECOGNIZED;
  }
}

export function checkboxTypeToJSON(object: CheckboxType): string {
  switch (object) {
    case CheckboxType.CheckboxTypeNone:
      return "CheckboxTypeNone";
    case CheckboxType.CheckboxTypeEncourage:
      return "CheckboxTypeEncourage";
    case CheckboxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ToastFunctionType {
  ToastFunctionTypeNone = 0,
  ToastFunctionTypePostPanel = 1,
  UNRECOGNIZED = -1,
}

export function toastFunctionTypeFromJSON(object: any): ToastFunctionType {
  switch (object) {
    case 0:
    case "ToastFunctionTypeNone":
      return ToastFunctionType.ToastFunctionTypeNone;
    case 1:
    case "ToastFunctionTypePostPanel":
      return ToastFunctionType.ToastFunctionTypePostPanel;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ToastFunctionType.UNRECOGNIZED;
  }
}

export function toastFunctionTypeToJSON(object: ToastFunctionType): string {
  switch (object) {
    case ToastFunctionType.ToastFunctionTypeNone:
      return "ToastFunctionTypeNone";
    case ToastFunctionType.ToastFunctionTypePostPanel:
      return "ToastFunctionTypePostPanel";
    case ToastFunctionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExposureType {
  ExposureTypeNone = 0,
  ExposureTypeDMSend = 1,
  UNRECOGNIZED = -1,
}

export function exposureTypeFromJSON(object: any): ExposureType {
  switch (object) {
    case 0:
    case "ExposureTypeNone":
      return ExposureType.ExposureTypeNone;
    case 1:
    case "ExposureTypeDMSend":
      return ExposureType.ExposureTypeDMSend;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExposureType.UNRECOGNIZED;
  }
}

export function exposureTypeToJSON(object: ExposureType): string {
  switch (object) {
    case ExposureType.ExposureTypeNone:
      return "ExposureTypeNone";
    case ExposureType.ExposureTypeDMSend:
      return "ExposureTypeDMSend";
    case ExposureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BubbleType {
  BubbleTypeNone = 0,
  BubbleTypeClickButton = 1,
  BubbleTypeDmSettingPanel = 2,
  UNRECOGNIZED = -1,
}

export function bubbleTypeFromJSON(object: any): BubbleType {
  switch (object) {
    case 0:
    case "BubbleTypeNone":
      return BubbleType.BubbleTypeNone;
    case 1:
    case "BubbleTypeClickButton":
      return BubbleType.BubbleTypeClickButton;
    case 2:
    case "BubbleTypeDmSettingPanel":
      return BubbleType.BubbleTypeDmSettingPanel;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BubbleType.UNRECOGNIZED;
  }
}

export function bubbleTypeToJSON(object: BubbleType): string {
  switch (object) {
    case BubbleType.BubbleTypeNone:
      return "BubbleTypeNone";
    case BubbleType.BubbleTypeClickButton:
      return "BubbleTypeClickButton";
    case BubbleType.BubbleTypeDmSettingPanel:
      return "BubbleTypeDmSettingPanel";
    case BubbleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DmMaskWallContentType {
  DmMaskWallContentTypeUnknown = 0,
  DmMaskWallContentTypeText = 1,
  DmMaskWallContentTypePic = 2,
  UNRECOGNIZED = -1,
}

export function dmMaskWallContentTypeFromJSON(object: any): DmMaskWallContentType {
  switch (object) {
    case 0:
    case "DmMaskWallContentTypeUnknown":
      return DmMaskWallContentType.DmMaskWallContentTypeUnknown;
    case 1:
    case "DmMaskWallContentTypeText":
      return DmMaskWallContentType.DmMaskWallContentTypeText;
    case 2:
    case "DmMaskWallContentTypePic":
      return DmMaskWallContentType.DmMaskWallContentTypePic;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DmMaskWallContentType.UNRECOGNIZED;
  }
}

export function dmMaskWallContentTypeToJSON(object: DmMaskWallContentType): string {
  switch (object) {
    case DmMaskWallContentType.DmMaskWallContentTypeUnknown:
      return "DmMaskWallContentTypeUnknown";
    case DmMaskWallContentType.DmMaskWallContentTypeText:
      return "DmMaskWallContentTypeText";
    case DmMaskWallContentType.DmMaskWallContentTypePic:
      return "DmMaskWallContentTypePic";
    case DmMaskWallContentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DmMaskWallBizType {
  DmMaskWallBizTypeUnknown = 0,
  DmMaskWallBizTypeOGV = 1,
  DmMaskWallBizTypeBizPic = 2,
  DmMaskWallBizTypeMute = 3,
  DmMaskWallBizTypeRecord = 4,
  UNRECOGNIZED = -1,
}

export function dmMaskWallBizTypeFromJSON(object: any): DmMaskWallBizType {
  switch (object) {
    case 0:
    case "DmMaskWallBizTypeUnknown":
      return DmMaskWallBizType.DmMaskWallBizTypeUnknown;
    case 1:
    case "DmMaskWallBizTypeOGV":
      return DmMaskWallBizType.DmMaskWallBizTypeOGV;
    case 2:
    case "DmMaskWallBizTypeBizPic":
      return DmMaskWallBizType.DmMaskWallBizTypeBizPic;
    case 3:
    case "DmMaskWallBizTypeMute":
      return DmMaskWallBizType.DmMaskWallBizTypeMute;
    case 4:
    case "DmMaskWallBizTypeRecord":
      return DmMaskWallBizType.DmMaskWallBizTypeRecord;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DmMaskWallBizType.UNRECOGNIZED;
  }
}

export function dmMaskWallBizTypeToJSON(object: DmMaskWallBizType): string {
  switch (object) {
    case DmMaskWallBizType.DmMaskWallBizTypeUnknown:
      return "DmMaskWallBizTypeUnknown";
    case DmMaskWallBizType.DmMaskWallBizTypeOGV:
      return "DmMaskWallBizTypeOGV";
    case DmMaskWallBizType.DmMaskWallBizTypeBizPic:
      return "DmMaskWallBizTypeBizPic";
    case DmMaskWallBizType.DmMaskWallBizTypeMute:
      return "DmMaskWallBizTypeMute";
    case DmMaskWallBizType.DmMaskWallBizTypeRecord:
      return "DmMaskWallBizTypeRecord";
    case DmMaskWallBizType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 弹幕数据 */
export interface DmWebViewReply {
  /** 弹幕区是否关闭 */
  state?: number | undefined;
  text?: string | undefined;
  textSide?:
    | string
    | undefined;
  /** 分段弹幕配置 */
  dmSge:
    | DmSegConfig
    | undefined;
  /** ai云屏蔽弹幕的配置 */
  flag:
    | DanmakuFlagConfig
    | undefined;
  /** 高级弹幕链接地址 （上传到bfs） */
  specialDms: string[];
  /** check box 是否展示 */
  checkBox?:
    | boolean
    | undefined;
  /** 弹幕数 */
  count: bigint;
  /** 指令弹幕 */
  commandDms: CommandDm[];
  /** 用户弹幕配置 */
  playerConfig:
    | DanmuWebPlayerConfig
    | undefined;
  /** 用户举报弹幕，cid维度屏蔽 */
  reportFilterContent: string[];
  expressions: Expressions[];
  postPanel: PostPanel[];
  activityMetas: string[];
  postPanelV2: PostPanelV2[];
  subViews: DmSubView[];
  qoe?: QoeInfo | undefined;
  maskWalls: DmMaskWall[];
}

export interface DmSegConfig {
  pageSize: bigint;
  total: bigint;
}

/** ai云屏蔽弹幕的配置 */
export interface DanmakuFlagConfig {
  /** 云屏蔽等级 */
  recFlag: number;
  /** 云屏蔽文案 */
  recText: string;
  /** 云屏蔽开关 */
  recSwitch: number;
}

/** 指令弹幕 */
export interface CommandDm {
  /** 弹幕id */
  id: bigint;
  /** oid */
  oid: bigint;
  /** mid */
  mid: bigint;
  /** 弹幕指令 */
  command: string;
  /** 弹幕内容 */
  content: string;
  /** 弹幕位置：/ms */
  progress: number;
  /** 创建时间 */
  ctime: string;
  /** 修改时间 */
  mtime: string;
  /** 扩展json数据 */
  extra: string;
  /** 弹幕id_str */
  idstr: string;
}

/** 具体数值意义 https://info.bilibili.co/pages/viewpage.action?pageId=114161867 */
export interface DanmuWebPlayerConfig {
  dmSwitch: boolean;
  aiSwitch?: boolean | undefined;
  aiLevel: number;
  blocktop: boolean;
  blockscroll: boolean;
  blockbottom: boolean;
  blockcolor: boolean;
  blockspecial: boolean;
  preventshade?: boolean | undefined;
  dmask?: boolean | undefined;
  opacity: number;
  dmarea?: number | undefined;
  speedplus: number;
  fontsize: number;
  screensync?: boolean | undefined;
  speedsync?: boolean | undefined;
  fontfamily: string;
  bold: boolean;
  fontborder?: number | undefined;
  drawType: string;
  seniorModeSwitch: number;
}

export interface Expressions {
  data: Expression[];
}

export interface Expression {
  keyword: string[];
  url: string;
  period: Period[];
}

export interface Period {
  start?: bigint | undefined;
  end: bigint;
}

export interface PostPanel {
  start: bigint;
  end: bigint;
  priority: bigint;
  bizId: bigint;
  bizType: PostPanelBizType;
  clickButton: ClickButton | undefined;
  textInput: TextInput | undefined;
  checkBox: CheckBox | undefined;
  toast: Toast | undefined;
}

export interface ClickButton {
  portraitText: string[];
  landscapeText: string[];
  portraitTextFocus: string[];
  landscapeTextFocus: string[];
  renderType: RenderType;
  show: boolean;
}

export interface TextInput {
  portraitPlaceholder: string[];
  landscapePlaceholder: string[];
  renderType: RenderType;
  placeholderPost: boolean;
  show: boolean;
  postStatus: PostStatus;
}

export interface CheckBox {
  text: string;
  type: CheckboxType;
  defaultValue: boolean;
  show: boolean;
}

export interface Toast {
  text: string;
  duration: number;
  show: boolean;
  button: Button | undefined;
}

export interface Button {
  text: string;
  action: ToastFunctionType;
}

export interface PostPanelV2 {
  start: bigint;
  end: bigint;
  bizType: PostPanelBizType;
  clickButton: ClickButtonV2 | undefined;
  textInput: TextInputV2 | undefined;
  checkBox: CheckBoxV2 | undefined;
  toast: ToastV2 | undefined;
  bubble: BubbleV2 | undefined;
  label: LabelV2 | undefined;
  postStatus: PostStatus;
}

export interface ClickButtonV2 {
  portraitText: string[];
  landscapeText: string[];
  portraitTextFocus: string[];
  landscapeTextFocus: string[];
  renderType: RenderType;
  textInputPost: boolean;
  exposureOnce: boolean;
  exposureType: ExposureType;
}

export interface TextInputV2 {
  portraitPlaceholder: string[];
  landscapePlaceholder: string[];
  renderType: RenderType;
  placeholderPost: boolean;
  textInputLimit: number;
}

export interface CheckBoxV2 {
  text: string;
  type: CheckboxType;
  defaultValue: boolean;
}

export interface ToastV2 {
  text: string;
  duration: number;
  toastButtonV2: ToastButtonV2 | undefined;
}

export interface ToastButtonV2 {
  text: string;
  action: ToastFunctionType;
}

export interface BubbleV2 {
  text: string;
  url: string;
  bubbleType: BubbleType;
  exposureOnce: boolean;
  exposureType: ExposureType;
}

export interface LabelV2 {
  title: string;
  content: string[];
  exposureOnce: boolean;
  exposureType: ExposureType;
}

export interface DmSubView {
  type: number;
  oid: bigint;
  pid: bigint;
  postPanel2: PostPanelV2[];
}

export interface QoeInfo {
  info: string;
}

export interface DmMaskWall {
  start: bigint;
  end: bigint;
  content: string;
  contentType: DmMaskWallContentType;
  bizType: DmMaskWallBizType;
  contents: DmMaskWallContent[];
}

export interface DmMaskWallContent {
  type: DmMaskWallContentType;
  content: string;
}

function createBaseDmWebViewReply(): DmWebViewReply {
  return {
    dmSge: undefined,
    flag: undefined,
    specialDms: [],
    count: 0n,
    commandDms: [],
    playerConfig: undefined,
    reportFilterContent: [],
    expressions: [],
    postPanel: [],
    activityMetas: [],
    postPanelV2: [],
    subViews: [],
    maskWalls: [],
  };
}

export const DmWebViewReply: MessageFns<DmWebViewReply> = {
  encode(message: DmWebViewReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      writer.uint32(8).int32(message.state);
    }
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    if (message.textSide !== undefined) {
      writer.uint32(26).string(message.textSide);
    }
    if (message.dmSge !== undefined) {
      DmSegConfig.encode(message.dmSge, writer.uint32(34).fork()).join();
    }
    if (message.flag !== undefined) {
      DanmakuFlagConfig.encode(message.flag, writer.uint32(42).fork()).join();
    }
    for (const v of message.specialDms) {
      writer.uint32(50).string(v!);
    }
    if (message.checkBox !== undefined) {
      writer.uint32(56).bool(message.checkBox);
    }
    if (message.count !== 0n) {
      if (BigInt.asIntN(64, message.count) !== message.count) {
        throw new globalThis.Error("value provided for field message.count of type int64 too large");
      }
      writer.uint32(64).int64(message.count);
    }
    for (const v of message.commandDms) {
      CommandDm.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.playerConfig !== undefined) {
      DanmuWebPlayerConfig.encode(message.playerConfig, writer.uint32(82).fork()).join();
    }
    for (const v of message.reportFilterContent) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.expressions) {
      Expressions.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.postPanel) {
      PostPanel.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.activityMetas) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.postPanelV2) {
      PostPanelV2.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.subViews) {
      DmSubView.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.qoe !== undefined) {
      QoeInfo.encode(message.qoe, writer.uint32(138).fork()).join();
    }
    for (const v of message.maskWalls) {
      DmMaskWall.encode(v!, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmWebViewReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmWebViewReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textSide = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dmSge = DmSegConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.flag = DanmakuFlagConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.specialDms.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.checkBox = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.count = reader.int64() as bigint;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.commandDms.push(CommandDm.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.playerConfig = DanmuWebPlayerConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.reportFilterContent.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.expressions.push(Expressions.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.postPanel.push(PostPanel.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.activityMetas.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.postPanelV2.push(PostPanelV2.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.subViews.push(DmSubView.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.qoe = QoeInfo.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.maskWalls.push(DmMaskWall.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmWebViewReply {
    return {
      state: isSet(object.state) ? globalThis.Number(object.state) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      textSide: isSet(object.textSide) ? globalThis.String(object.textSide) : undefined,
      dmSge: isSet(object.dmSge) ? DmSegConfig.fromJSON(object.dmSge) : undefined,
      flag: isSet(object.flag) ? DanmakuFlagConfig.fromJSON(object.flag) : undefined,
      specialDms: globalThis.Array.isArray(object?.specialDms)
        ? object.specialDms.map((e: any) => globalThis.String(e))
        : [],
      checkBox: isSet(object.checkBox) ? globalThis.Boolean(object.checkBox) : undefined,
      count: isSet(object.count) ? BigInt(object.count) : 0n,
      commandDms: globalThis.Array.isArray(object?.commandDms)
        ? object.commandDms.map((e: any) => CommandDm.fromJSON(e))
        : [],
      playerConfig: isSet(object.playerConfig) ? DanmuWebPlayerConfig.fromJSON(object.playerConfig) : undefined,
      reportFilterContent: globalThis.Array.isArray(object?.reportFilterContent)
        ? object.reportFilterContent.map((e: any) => globalThis.String(e))
        : [],
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => Expressions.fromJSON(e))
        : [],
      postPanel: globalThis.Array.isArray(object?.postPanel)
        ? object.postPanel.map((e: any) => PostPanel.fromJSON(e))
        : [],
      activityMetas: globalThis.Array.isArray(object?.activityMetas)
        ? object.activityMetas.map((e: any) => globalThis.String(e))
        : [],
      postPanelV2: globalThis.Array.isArray(object?.postPanelV2)
        ? object.postPanelV2.map((e: any) => PostPanelV2.fromJSON(e))
        : [],
      subViews: globalThis.Array.isArray(object?.subViews)
        ? object.subViews.map((e: any) => DmSubView.fromJSON(e))
        : [],
      qoe: isSet(object.qoe) ? QoeInfo.fromJSON(object.qoe) : undefined,
      maskWalls: globalThis.Array.isArray(object?.maskWalls)
        ? object.maskWalls.map((e: any) => DmMaskWall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DmWebViewReply): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = Math.round(message.state);
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.textSide !== undefined) {
      obj.textSide = message.textSide;
    }
    if (message.dmSge !== undefined) {
      obj.dmSge = DmSegConfig.toJSON(message.dmSge);
    }
    if (message.flag !== undefined) {
      obj.flag = DanmakuFlagConfig.toJSON(message.flag);
    }
    if (message.specialDms?.length) {
      obj.specialDms = message.specialDms;
    }
    if (message.checkBox !== undefined) {
      obj.checkBox = message.checkBox;
    }
    if (message.count !== 0n) {
      obj.count = message.count.toString();
    }
    if (message.commandDms?.length) {
      obj.commandDms = message.commandDms.map((e) => CommandDm.toJSON(e));
    }
    if (message.playerConfig !== undefined) {
      obj.playerConfig = DanmuWebPlayerConfig.toJSON(message.playerConfig);
    }
    if (message.reportFilterContent?.length) {
      obj.reportFilterContent = message.reportFilterContent;
    }
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => Expressions.toJSON(e));
    }
    if (message.postPanel?.length) {
      obj.postPanel = message.postPanel.map((e) => PostPanel.toJSON(e));
    }
    if (message.activityMetas?.length) {
      obj.activityMetas = message.activityMetas;
    }
    if (message.postPanelV2?.length) {
      obj.postPanelV2 = message.postPanelV2.map((e) => PostPanelV2.toJSON(e));
    }
    if (message.subViews?.length) {
      obj.subViews = message.subViews.map((e) => DmSubView.toJSON(e));
    }
    if (message.qoe !== undefined) {
      obj.qoe = QoeInfo.toJSON(message.qoe);
    }
    if (message.maskWalls?.length) {
      obj.maskWalls = message.maskWalls.map((e) => DmMaskWall.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DmWebViewReply>, I>>(base?: I): DmWebViewReply {
    return DmWebViewReply.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DmWebViewReply>, I>>(object: I): DmWebViewReply {
    const message = createBaseDmWebViewReply();
    message.state = object.state ?? undefined;
    message.text = object.text ?? undefined;
    message.textSide = object.textSide ?? undefined;
    message.dmSge = (object.dmSge !== undefined && object.dmSge !== null)
      ? DmSegConfig.fromPartial(object.dmSge)
      : undefined;
    message.flag = (object.flag !== undefined && object.flag !== null)
      ? DanmakuFlagConfig.fromPartial(object.flag)
      : undefined;
    message.specialDms = object.specialDms?.map((e) => e) || [];
    message.checkBox = object.checkBox ?? undefined;
    message.count = object.count ?? 0n;
    message.commandDms = object.commandDms?.map((e) => CommandDm.fromPartial(e)) || [];
    message.playerConfig = (object.playerConfig !== undefined && object.playerConfig !== null)
      ? DanmuWebPlayerConfig.fromPartial(object.playerConfig)
      : undefined;
    message.reportFilterContent = object.reportFilterContent?.map((e) => e) || [];
    message.expressions = object.expressions?.map((e) => Expressions.fromPartial(e)) || [];
    message.postPanel = object.postPanel?.map((e) => PostPanel.fromPartial(e)) || [];
    message.activityMetas = object.activityMetas?.map((e) => e) || [];
    message.postPanelV2 = object.postPanelV2?.map((e) => PostPanelV2.fromPartial(e)) || [];
    message.subViews = object.subViews?.map((e) => DmSubView.fromPartial(e)) || [];
    message.qoe = (object.qoe !== undefined && object.qoe !== null) ? QoeInfo.fromPartial(object.qoe) : undefined;
    message.maskWalls = object.maskWalls?.map((e) => DmMaskWall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDmSegConfig(): DmSegConfig {
  return { pageSize: 0n, total: 0n };
}

export const DmSegConfig: MessageFns<DmSegConfig> = {
  encode(message: DmSegConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0n) {
      if (BigInt.asIntN(64, message.pageSize) !== message.pageSize) {
        throw new globalThis.Error("value provided for field message.pageSize of type int64 too large");
      }
      writer.uint32(8).int64(message.pageSize);
    }
    if (message.total !== 0n) {
      if (BigInt.asIntN(64, message.total) !== message.total) {
        throw new globalThis.Error("value provided for field message.total of type int64 too large");
      }
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmSegConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmSegConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmSegConfig {
    return {
      pageSize: isSet(object.pageSize) ? BigInt(object.pageSize) : 0n,
      total: isSet(object.total) ? BigInt(object.total) : 0n,
    };
  },

  toJSON(message: DmSegConfig): unknown {
    const obj: any = {};
    if (message.pageSize !== 0n) {
      obj.pageSize = message.pageSize.toString();
    }
    if (message.total !== 0n) {
      obj.total = message.total.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DmSegConfig>, I>>(base?: I): DmSegConfig {
    return DmSegConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DmSegConfig>, I>>(object: I): DmSegConfig {
    const message = createBaseDmSegConfig();
    message.pageSize = object.pageSize ?? 0n;
    message.total = object.total ?? 0n;
    return message;
  },
};

function createBaseDanmakuFlagConfig(): DanmakuFlagConfig {
  return { recFlag: 0, recText: "", recSwitch: 0 };
}

export const DanmakuFlagConfig: MessageFns<DanmakuFlagConfig> = {
  encode(message: DanmakuFlagConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recFlag !== 0) {
      writer.uint32(8).int32(message.recFlag);
    }
    if (message.recText !== "") {
      writer.uint32(18).string(message.recText);
    }
    if (message.recSwitch !== 0) {
      writer.uint32(24).int32(message.recSwitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DanmakuFlagConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDanmakuFlagConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recFlag = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recText = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recSwitch = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DanmakuFlagConfig {
    return {
      recFlag: isSet(object.recFlag) ? globalThis.Number(object.recFlag) : 0,
      recText: isSet(object.recText) ? globalThis.String(object.recText) : "",
      recSwitch: isSet(object.recSwitch) ? globalThis.Number(object.recSwitch) : 0,
    };
  },

  toJSON(message: DanmakuFlagConfig): unknown {
    const obj: any = {};
    if (message.recFlag !== 0) {
      obj.recFlag = Math.round(message.recFlag);
    }
    if (message.recText !== "") {
      obj.recText = message.recText;
    }
    if (message.recSwitch !== 0) {
      obj.recSwitch = Math.round(message.recSwitch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DanmakuFlagConfig>, I>>(base?: I): DanmakuFlagConfig {
    return DanmakuFlagConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DanmakuFlagConfig>, I>>(object: I): DanmakuFlagConfig {
    const message = createBaseDanmakuFlagConfig();
    message.recFlag = object.recFlag ?? 0;
    message.recText = object.recText ?? "";
    message.recSwitch = object.recSwitch ?? 0;
    return message;
  },
};

function createBaseCommandDm(): CommandDm {
  return {
    id: 0n,
    oid: 0n,
    mid: 0n,
    command: "",
    content: "",
    progress: 0,
    ctime: "",
    mtime: "",
    extra: "",
    idstr: "",
  };
}

export const CommandDm: MessageFns<CommandDm> = {
  encode(message: CommandDm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asIntN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type int64 too large");
      }
      writer.uint32(8).int64(message.id);
    }
    if (message.oid !== 0n) {
      if (BigInt.asIntN(64, message.oid) !== message.oid) {
        throw new globalThis.Error("value provided for field message.oid of type int64 too large");
      }
      writer.uint32(16).int64(message.oid);
    }
    if (message.mid !== 0n) {
      if (BigInt.asIntN(64, message.mid) !== message.mid) {
        throw new globalThis.Error("value provided for field message.mid of type int64 too large");
      }
      writer.uint32(24).int64(message.mid);
    }
    if (message.command !== "") {
      writer.uint32(34).string(message.command);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    if (message.progress !== 0) {
      writer.uint32(48).int32(message.progress);
    }
    if (message.ctime !== "") {
      writer.uint32(58).string(message.ctime);
    }
    if (message.mtime !== "") {
      writer.uint32(66).string(message.mtime);
    }
    if (message.extra !== "") {
      writer.uint32(74).string(message.extra);
    }
    if (message.idstr !== "") {
      writer.uint32(82).string(message.idstr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandDm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandDm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.oid = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mid = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.command = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progress = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ctime = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mtime = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.extra = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.idstr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandDm {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      oid: isSet(object.oid) ? BigInt(object.oid) : 0n,
      mid: isSet(object.mid) ? BigInt(object.mid) : 0n,
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      ctime: isSet(object.ctime) ? globalThis.String(object.ctime) : "",
      mtime: isSet(object.mtime) ? globalThis.String(object.mtime) : "",
      extra: isSet(object.extra) ? globalThis.String(object.extra) : "",
      idstr: isSet(object.idstr) ? globalThis.String(object.idstr) : "",
    };
  },

  toJSON(message: CommandDm): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.oid !== 0n) {
      obj.oid = message.oid.toString();
    }
    if (message.mid !== 0n) {
      obj.mid = message.mid.toString();
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.ctime !== "") {
      obj.ctime = message.ctime;
    }
    if (message.mtime !== "") {
      obj.mtime = message.mtime;
    }
    if (message.extra !== "") {
      obj.extra = message.extra;
    }
    if (message.idstr !== "") {
      obj.idstr = message.idstr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandDm>, I>>(base?: I): CommandDm {
    return CommandDm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandDm>, I>>(object: I): CommandDm {
    const message = createBaseCommandDm();
    message.id = object.id ?? 0n;
    message.oid = object.oid ?? 0n;
    message.mid = object.mid ?? 0n;
    message.command = object.command ?? "";
    message.content = object.content ?? "";
    message.progress = object.progress ?? 0;
    message.ctime = object.ctime ?? "";
    message.mtime = object.mtime ?? "";
    message.extra = object.extra ?? "";
    message.idstr = object.idstr ?? "";
    return message;
  },
};

function createBaseDanmuWebPlayerConfig(): DanmuWebPlayerConfig {
  return {
    dmSwitch: false,
    aiLevel: 0,
    blocktop: false,
    blockscroll: false,
    blockbottom: false,
    blockcolor: false,
    blockspecial: false,
    opacity: 0,
    speedplus: 0,
    fontsize: 0,
    fontfamily: "",
    bold: false,
    drawType: "",
    seniorModeSwitch: 0,
  };
}

export const DanmuWebPlayerConfig: MessageFns<DanmuWebPlayerConfig> = {
  encode(message: DanmuWebPlayerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dmSwitch !== false) {
      writer.uint32(8).bool(message.dmSwitch);
    }
    if (message.aiSwitch !== undefined) {
      writer.uint32(16).bool(message.aiSwitch);
    }
    if (message.aiLevel !== 0) {
      writer.uint32(24).int32(message.aiLevel);
    }
    if (message.blocktop !== false) {
      writer.uint32(32).bool(message.blocktop);
    }
    if (message.blockscroll !== false) {
      writer.uint32(40).bool(message.blockscroll);
    }
    if (message.blockbottom !== false) {
      writer.uint32(48).bool(message.blockbottom);
    }
    if (message.blockcolor !== false) {
      writer.uint32(56).bool(message.blockcolor);
    }
    if (message.blockspecial !== false) {
      writer.uint32(64).bool(message.blockspecial);
    }
    if (message.preventshade !== undefined) {
      writer.uint32(72).bool(message.preventshade);
    }
    if (message.dmask !== undefined) {
      writer.uint32(80).bool(message.dmask);
    }
    if (message.opacity !== 0) {
      writer.uint32(93).float(message.opacity);
    }
    if (message.dmarea !== undefined) {
      writer.uint32(96).int32(message.dmarea);
    }
    if (message.speedplus !== 0) {
      writer.uint32(109).float(message.speedplus);
    }
    if (message.fontsize !== 0) {
      writer.uint32(117).float(message.fontsize);
    }
    if (message.screensync !== undefined) {
      writer.uint32(120).bool(message.screensync);
    }
    if (message.speedsync !== undefined) {
      writer.uint32(128).bool(message.speedsync);
    }
    if (message.fontfamily !== "") {
      writer.uint32(138).string(message.fontfamily);
    }
    if (message.bold !== false) {
      writer.uint32(144).bool(message.bold);
    }
    if (message.fontborder !== undefined) {
      writer.uint32(152).int32(message.fontborder);
    }
    if (message.drawType !== "") {
      writer.uint32(162).string(message.drawType);
    }
    if (message.seniorModeSwitch !== 0) {
      writer.uint32(168).int32(message.seniorModeSwitch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DanmuWebPlayerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDanmuWebPlayerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dmSwitch = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.aiSwitch = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aiLevel = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.blocktop = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.blockscroll = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.blockbottom = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.blockcolor = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.blockspecial = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.preventshade = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.dmask = reader.bool();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.opacity = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.dmarea = reader.int32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.speedplus = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.fontsize = reader.float();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.screensync = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.speedsync = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.fontfamily = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.bold = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.fontborder = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.drawType = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.seniorModeSwitch = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DanmuWebPlayerConfig {
    return {
      dmSwitch: isSet(object.dmSwitch) ? globalThis.Boolean(object.dmSwitch) : false,
      aiSwitch: isSet(object.aiSwitch) ? globalThis.Boolean(object.aiSwitch) : undefined,
      aiLevel: isSet(object.aiLevel) ? globalThis.Number(object.aiLevel) : 0,
      blocktop: isSet(object.blocktop) ? globalThis.Boolean(object.blocktop) : false,
      blockscroll: isSet(object.blockscroll) ? globalThis.Boolean(object.blockscroll) : false,
      blockbottom: isSet(object.blockbottom) ? globalThis.Boolean(object.blockbottom) : false,
      blockcolor: isSet(object.blockcolor) ? globalThis.Boolean(object.blockcolor) : false,
      blockspecial: isSet(object.blockspecial) ? globalThis.Boolean(object.blockspecial) : false,
      preventshade: isSet(object.preventshade) ? globalThis.Boolean(object.preventshade) : undefined,
      dmask: isSet(object.dmask) ? globalThis.Boolean(object.dmask) : undefined,
      opacity: isSet(object.opacity) ? globalThis.Number(object.opacity) : 0,
      dmarea: isSet(object.dmarea) ? globalThis.Number(object.dmarea) : undefined,
      speedplus: isSet(object.speedplus) ? globalThis.Number(object.speedplus) : 0,
      fontsize: isSet(object.fontsize) ? globalThis.Number(object.fontsize) : 0,
      screensync: isSet(object.screensync) ? globalThis.Boolean(object.screensync) : undefined,
      speedsync: isSet(object.speedsync) ? globalThis.Boolean(object.speedsync) : undefined,
      fontfamily: isSet(object.fontfamily) ? globalThis.String(object.fontfamily) : "",
      bold: isSet(object.bold) ? globalThis.Boolean(object.bold) : false,
      fontborder: isSet(object.fontborder) ? globalThis.Number(object.fontborder) : undefined,
      drawType: isSet(object.drawType) ? globalThis.String(object.drawType) : "",
      seniorModeSwitch: isSet(object.seniorModeSwitch) ? globalThis.Number(object.seniorModeSwitch) : 0,
    };
  },

  toJSON(message: DanmuWebPlayerConfig): unknown {
    const obj: any = {};
    if (message.dmSwitch !== false) {
      obj.dmSwitch = message.dmSwitch;
    }
    if (message.aiSwitch !== undefined) {
      obj.aiSwitch = message.aiSwitch;
    }
    if (message.aiLevel !== 0) {
      obj.aiLevel = Math.round(message.aiLevel);
    }
    if (message.blocktop !== false) {
      obj.blocktop = message.blocktop;
    }
    if (message.blockscroll !== false) {
      obj.blockscroll = message.blockscroll;
    }
    if (message.blockbottom !== false) {
      obj.blockbottom = message.blockbottom;
    }
    if (message.blockcolor !== false) {
      obj.blockcolor = message.blockcolor;
    }
    if (message.blockspecial !== false) {
      obj.blockspecial = message.blockspecial;
    }
    if (message.preventshade !== undefined) {
      obj.preventshade = message.preventshade;
    }
    if (message.dmask !== undefined) {
      obj.dmask = message.dmask;
    }
    if (message.opacity !== 0) {
      obj.opacity = message.opacity;
    }
    if (message.dmarea !== undefined) {
      obj.dmarea = Math.round(message.dmarea);
    }
    if (message.speedplus !== 0) {
      obj.speedplus = message.speedplus;
    }
    if (message.fontsize !== 0) {
      obj.fontsize = message.fontsize;
    }
    if (message.screensync !== undefined) {
      obj.screensync = message.screensync;
    }
    if (message.speedsync !== undefined) {
      obj.speedsync = message.speedsync;
    }
    if (message.fontfamily !== "") {
      obj.fontfamily = message.fontfamily;
    }
    if (message.bold !== false) {
      obj.bold = message.bold;
    }
    if (message.fontborder !== undefined) {
      obj.fontborder = Math.round(message.fontborder);
    }
    if (message.drawType !== "") {
      obj.drawType = message.drawType;
    }
    if (message.seniorModeSwitch !== 0) {
      obj.seniorModeSwitch = Math.round(message.seniorModeSwitch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DanmuWebPlayerConfig>, I>>(base?: I): DanmuWebPlayerConfig {
    return DanmuWebPlayerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DanmuWebPlayerConfig>, I>>(object: I): DanmuWebPlayerConfig {
    const message = createBaseDanmuWebPlayerConfig();
    message.dmSwitch = object.dmSwitch ?? false;
    message.aiSwitch = object.aiSwitch ?? undefined;
    message.aiLevel = object.aiLevel ?? 0;
    message.blocktop = object.blocktop ?? false;
    message.blockscroll = object.blockscroll ?? false;
    message.blockbottom = object.blockbottom ?? false;
    message.blockcolor = object.blockcolor ?? false;
    message.blockspecial = object.blockspecial ?? false;
    message.preventshade = object.preventshade ?? undefined;
    message.dmask = object.dmask ?? undefined;
    message.opacity = object.opacity ?? 0;
    message.dmarea = object.dmarea ?? undefined;
    message.speedplus = object.speedplus ?? 0;
    message.fontsize = object.fontsize ?? 0;
    message.screensync = object.screensync ?? undefined;
    message.speedsync = object.speedsync ?? undefined;
    message.fontfamily = object.fontfamily ?? "";
    message.bold = object.bold ?? false;
    message.fontborder = object.fontborder ?? undefined;
    message.drawType = object.drawType ?? "";
    message.seniorModeSwitch = object.seniorModeSwitch ?? 0;
    return message;
  },
};

function createBaseExpressions(): Expressions {
  return { data: [] };
}

export const Expressions: MessageFns<Expressions> = {
  encode(message: Expressions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      Expression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expressions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpressions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data.push(Expression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expressions {
    return { data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => Expression.fromJSON(e)) : [] };
  },

  toJSON(message: Expressions): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => Expression.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expressions>, I>>(base?: I): Expressions {
    return Expressions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expressions>, I>>(object: I): Expressions {
    const message = createBaseExpressions();
    message.data = object.data?.map((e) => Expression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExpression(): Expression {
  return { keyword: [], url: "", period: [] };
}

export const Expression: MessageFns<Expression> = {
  encode(message: Expression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keyword) {
      writer.uint32(10).string(v!);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    for (const v of message.period) {
      Period.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyword.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.period.push(Period.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expression {
    return {
      keyword: globalThis.Array.isArray(object?.keyword) ? object.keyword.map((e: any) => globalThis.String(e)) : [],
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      period: globalThis.Array.isArray(object?.period) ? object.period.map((e: any) => Period.fromJSON(e)) : [],
    };
  },

  toJSON(message: Expression): unknown {
    const obj: any = {};
    if (message.keyword?.length) {
      obj.keyword = message.keyword;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.period?.length) {
      obj.period = message.period.map((e) => Period.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expression>, I>>(base?: I): Expression {
    return Expression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expression>, I>>(object: I): Expression {
    const message = createBaseExpression();
    message.keyword = object.keyword?.map((e) => e) || [];
    message.url = object.url ?? "";
    message.period = object.period?.map((e) => Period.fromPartial(e)) || [];
    return message;
  },
};

function createBasePeriod(): Period {
  return { end: 0n };
}

export const Period: MessageFns<Period> = {
  encode(message: Period, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      if (BigInt.asIntN(64, message.start) !== message.start) {
        throw new globalThis.Error("value provided for field message.start of type int64 too large");
      }
      writer.uint32(8).int64(message.start);
    }
    if (message.end !== 0n) {
      if (BigInt.asIntN(64, message.end) !== message.end) {
        throw new globalThis.Error("value provided for field message.end of type int64 too large");
      }
      writer.uint32(16).int64(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Period {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Period {
    return {
      start: isSet(object.start) ? BigInt(object.start) : undefined,
      end: isSet(object.end) ? BigInt(object.end) : 0n,
    };
  },

  toJSON(message: Period): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = message.start.toString();
    }
    if (message.end !== 0n) {
      obj.end = message.end.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Period>, I>>(base?: I): Period {
    return Period.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Period>, I>>(object: I): Period {
    const message = createBasePeriod();
    message.start = object.start ?? undefined;
    message.end = object.end ?? 0n;
    return message;
  },
};

function createBasePostPanel(): PostPanel {
  return {
    start: 0n,
    end: 0n,
    priority: 0n,
    bizId: 0n,
    bizType: 0,
    clickButton: undefined,
    textInput: undefined,
    checkBox: undefined,
    toast: undefined,
  };
}

export const PostPanel: MessageFns<PostPanel> = {
  encode(message: PostPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0n) {
      if (BigInt.asIntN(64, message.start) !== message.start) {
        throw new globalThis.Error("value provided for field message.start of type int64 too large");
      }
      writer.uint32(8).int64(message.start);
    }
    if (message.end !== 0n) {
      if (BigInt.asIntN(64, message.end) !== message.end) {
        throw new globalThis.Error("value provided for field message.end of type int64 too large");
      }
      writer.uint32(16).int64(message.end);
    }
    if (message.priority !== 0n) {
      if (BigInt.asIntN(64, message.priority) !== message.priority) {
        throw new globalThis.Error("value provided for field message.priority of type int64 too large");
      }
      writer.uint32(24).int64(message.priority);
    }
    if (message.bizId !== 0n) {
      if (BigInt.asIntN(64, message.bizId) !== message.bizId) {
        throw new globalThis.Error("value provided for field message.bizId of type int64 too large");
      }
      writer.uint32(32).int64(message.bizId);
    }
    if (message.bizType !== 0) {
      writer.uint32(40).int32(message.bizType);
    }
    if (message.clickButton !== undefined) {
      ClickButton.encode(message.clickButton, writer.uint32(50).fork()).join();
    }
    if (message.textInput !== undefined) {
      TextInput.encode(message.textInput, writer.uint32(58).fork()).join();
    }
    if (message.checkBox !== undefined) {
      CheckBox.encode(message.checkBox, writer.uint32(66).fork()).join();
    }
    if (message.toast !== undefined) {
      Toast.encode(message.toast, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bizId = reader.int64() as bigint;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.bizType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clickButton = ClickButton.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.textInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.checkBox = CheckBox.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.toast = Toast.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPanel {
    return {
      start: isSet(object.start) ? BigInt(object.start) : 0n,
      end: isSet(object.end) ? BigInt(object.end) : 0n,
      priority: isSet(object.priority) ? BigInt(object.priority) : 0n,
      bizId: isSet(object.bizId) ? BigInt(object.bizId) : 0n,
      bizType: isSet(object.bizType) ? postPanelBizTypeFromJSON(object.bizType) : 0,
      clickButton: isSet(object.clickButton) ? ClickButton.fromJSON(object.clickButton) : undefined,
      textInput: isSet(object.textInput) ? TextInput.fromJSON(object.textInput) : undefined,
      checkBox: isSet(object.checkBox) ? CheckBox.fromJSON(object.checkBox) : undefined,
      toast: isSet(object.toast) ? Toast.fromJSON(object.toast) : undefined,
    };
  },

  toJSON(message: PostPanel): unknown {
    const obj: any = {};
    if (message.start !== 0n) {
      obj.start = message.start.toString();
    }
    if (message.end !== 0n) {
      obj.end = message.end.toString();
    }
    if (message.priority !== 0n) {
      obj.priority = message.priority.toString();
    }
    if (message.bizId !== 0n) {
      obj.bizId = message.bizId.toString();
    }
    if (message.bizType !== 0) {
      obj.bizType = postPanelBizTypeToJSON(message.bizType);
    }
    if (message.clickButton !== undefined) {
      obj.clickButton = ClickButton.toJSON(message.clickButton);
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInput.toJSON(message.textInput);
    }
    if (message.checkBox !== undefined) {
      obj.checkBox = CheckBox.toJSON(message.checkBox);
    }
    if (message.toast !== undefined) {
      obj.toast = Toast.toJSON(message.toast);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPanel>, I>>(base?: I): PostPanel {
    return PostPanel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPanel>, I>>(object: I): PostPanel {
    const message = createBasePostPanel();
    message.start = object.start ?? 0n;
    message.end = object.end ?? 0n;
    message.priority = object.priority ?? 0n;
    message.bizId = object.bizId ?? 0n;
    message.bizType = object.bizType ?? 0;
    message.clickButton = (object.clickButton !== undefined && object.clickButton !== null)
      ? ClickButton.fromPartial(object.clickButton)
      : undefined;
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInput.fromPartial(object.textInput)
      : undefined;
    message.checkBox = (object.checkBox !== undefined && object.checkBox !== null)
      ? CheckBox.fromPartial(object.checkBox)
      : undefined;
    message.toast = (object.toast !== undefined && object.toast !== null) ? Toast.fromPartial(object.toast) : undefined;
    return message;
  },
};

function createBaseClickButton(): ClickButton {
  return {
    portraitText: [],
    landscapeText: [],
    portraitTextFocus: [],
    landscapeTextFocus: [],
    renderType: 0,
    show: false,
  };
}

export const ClickButton: MessageFns<ClickButton> = {
  encode(message: ClickButton, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.portraitText) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.landscapeText) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.portraitTextFocus) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.landscapeTextFocus) {
      writer.uint32(34).string(v!);
    }
    if (message.renderType !== 0) {
      writer.uint32(40).int32(message.renderType);
    }
    if (message.show !== false) {
      writer.uint32(48).bool(message.show);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClickButton {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClickButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portraitText.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.landscapeText.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.portraitTextFocus.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.landscapeTextFocus.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.show = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClickButton {
    return {
      portraitText: globalThis.Array.isArray(object?.portraitText)
        ? object.portraitText.map((e: any) => globalThis.String(e))
        : [],
      landscapeText: globalThis.Array.isArray(object?.landscapeText)
        ? object.landscapeText.map((e: any) => globalThis.String(e))
        : [],
      portraitTextFocus: globalThis.Array.isArray(object?.portraitTextFocus)
        ? object.portraitTextFocus.map((e: any) => globalThis.String(e))
        : [],
      landscapeTextFocus: globalThis.Array.isArray(object?.landscapeTextFocus)
        ? object.landscapeTextFocus.map((e: any) => globalThis.String(e))
        : [],
      renderType: isSet(object.renderType) ? renderTypeFromJSON(object.renderType) : 0,
      show: isSet(object.show) ? globalThis.Boolean(object.show) : false,
    };
  },

  toJSON(message: ClickButton): unknown {
    const obj: any = {};
    if (message.portraitText?.length) {
      obj.portraitText = message.portraitText;
    }
    if (message.landscapeText?.length) {
      obj.landscapeText = message.landscapeText;
    }
    if (message.portraitTextFocus?.length) {
      obj.portraitTextFocus = message.portraitTextFocus;
    }
    if (message.landscapeTextFocus?.length) {
      obj.landscapeTextFocus = message.landscapeTextFocus;
    }
    if (message.renderType !== 0) {
      obj.renderType = renderTypeToJSON(message.renderType);
    }
    if (message.show !== false) {
      obj.show = message.show;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClickButton>, I>>(base?: I): ClickButton {
    return ClickButton.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClickButton>, I>>(object: I): ClickButton {
    const message = createBaseClickButton();
    message.portraitText = object.portraitText?.map((e) => e) || [];
    message.landscapeText = object.landscapeText?.map((e) => e) || [];
    message.portraitTextFocus = object.portraitTextFocus?.map((e) => e) || [];
    message.landscapeTextFocus = object.landscapeTextFocus?.map((e) => e) || [];
    message.renderType = object.renderType ?? 0;
    message.show = object.show ?? false;
    return message;
  },
};

function createBaseTextInput(): TextInput {
  return {
    portraitPlaceholder: [],
    landscapePlaceholder: [],
    renderType: 0,
    placeholderPost: false,
    show: false,
    postStatus: 0,
  };
}

export const TextInput: MessageFns<TextInput> = {
  encode(message: TextInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.portraitPlaceholder) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.landscapePlaceholder) {
      writer.uint32(18).string(v!);
    }
    if (message.renderType !== 0) {
      writer.uint32(24).int32(message.renderType);
    }
    if (message.placeholderPost !== false) {
      writer.uint32(32).bool(message.placeholderPost);
    }
    if (message.show !== false) {
      writer.uint32(40).bool(message.show);
    }
    if (message.postStatus !== 0) {
      writer.uint32(56).int32(message.postStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portraitPlaceholder.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.landscapePlaceholder.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.placeholderPost = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.show = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.postStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInput {
    return {
      portraitPlaceholder: globalThis.Array.isArray(object?.portraitPlaceholder)
        ? object.portraitPlaceholder.map((e: any) => globalThis.String(e))
        : [],
      landscapePlaceholder: globalThis.Array.isArray(object?.landscapePlaceholder)
        ? object.landscapePlaceholder.map((e: any) => globalThis.String(e))
        : [],
      renderType: isSet(object.renderType) ? renderTypeFromJSON(object.renderType) : 0,
      placeholderPost: isSet(object.placeholderPost) ? globalThis.Boolean(object.placeholderPost) : false,
      show: isSet(object.show) ? globalThis.Boolean(object.show) : false,
      postStatus: isSet(object.postStatus) ? postStatusFromJSON(object.postStatus) : 0,
    };
  },

  toJSON(message: TextInput): unknown {
    const obj: any = {};
    if (message.portraitPlaceholder?.length) {
      obj.portraitPlaceholder = message.portraitPlaceholder;
    }
    if (message.landscapePlaceholder?.length) {
      obj.landscapePlaceholder = message.landscapePlaceholder;
    }
    if (message.renderType !== 0) {
      obj.renderType = renderTypeToJSON(message.renderType);
    }
    if (message.placeholderPost !== false) {
      obj.placeholderPost = message.placeholderPost;
    }
    if (message.show !== false) {
      obj.show = message.show;
    }
    if (message.postStatus !== 0) {
      obj.postStatus = postStatusToJSON(message.postStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInput>, I>>(base?: I): TextInput {
    return TextInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInput>, I>>(object: I): TextInput {
    const message = createBaseTextInput();
    message.portraitPlaceholder = object.portraitPlaceholder?.map((e) => e) || [];
    message.landscapePlaceholder = object.landscapePlaceholder?.map((e) => e) || [];
    message.renderType = object.renderType ?? 0;
    message.placeholderPost = object.placeholderPost ?? false;
    message.show = object.show ?? false;
    message.postStatus = object.postStatus ?? 0;
    return message;
  },
};

function createBaseCheckBox(): CheckBox {
  return { text: "", type: 0, defaultValue: false, show: false };
}

export const CheckBox: MessageFns<CheckBox> = {
  encode(message: CheckBox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.defaultValue !== false) {
      writer.uint32(24).bool(message.defaultValue);
    }
    if (message.show !== false) {
      writer.uint32(32).bool(message.show);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultValue = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.show = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBox {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      type: isSet(object.type) ? checkboxTypeFromJSON(object.type) : 0,
      defaultValue: isSet(object.defaultValue) ? globalThis.Boolean(object.defaultValue) : false,
      show: isSet(object.show) ? globalThis.Boolean(object.show) : false,
    };
  },

  toJSON(message: CheckBox): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.type !== 0) {
      obj.type = checkboxTypeToJSON(message.type);
    }
    if (message.defaultValue !== false) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.show !== false) {
      obj.show = message.show;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckBox>, I>>(base?: I): CheckBox {
    return CheckBox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckBox>, I>>(object: I): CheckBox {
    const message = createBaseCheckBox();
    message.text = object.text ?? "";
    message.type = object.type ?? 0;
    message.defaultValue = object.defaultValue ?? false;
    message.show = object.show ?? false;
    return message;
  },
};

function createBaseToast(): Toast {
  return { text: "", duration: 0, show: false, button: undefined };
}

export const Toast: MessageFns<Toast> = {
  encode(message: Toast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int32(message.duration);
    }
    if (message.show !== false) {
      writer.uint32(24).bool(message.show);
    }
    if (message.button !== undefined) {
      Button.encode(message.button, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Toast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.show = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.button = Button.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Toast {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      show: isSet(object.show) ? globalThis.Boolean(object.show) : false,
      button: isSet(object.button) ? Button.fromJSON(object.button) : undefined,
    };
  },

  toJSON(message: Toast): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.show !== false) {
      obj.show = message.show;
    }
    if (message.button !== undefined) {
      obj.button = Button.toJSON(message.button);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Toast>, I>>(base?: I): Toast {
    return Toast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Toast>, I>>(object: I): Toast {
    const message = createBaseToast();
    message.text = object.text ?? "";
    message.duration = object.duration ?? 0;
    message.show = object.show ?? false;
    message.button = (object.button !== undefined && object.button !== null)
      ? Button.fromPartial(object.button)
      : undefined;
    return message;
  },
};

function createBaseButton(): Button {
  return { text: "", action: 0 };
}

export const Button: MessageFns<Button> = {
  encode(message: Button, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Button {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Button {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      action: isSet(object.action) ? toastFunctionTypeFromJSON(object.action) : 0,
    };
  },

  toJSON(message: Button): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.action !== 0) {
      obj.action = toastFunctionTypeToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Button>, I>>(base?: I): Button {
    return Button.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Button>, I>>(object: I): Button {
    const message = createBaseButton();
    message.text = object.text ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBasePostPanelV2(): PostPanelV2 {
  return {
    start: 0n,
    end: 0n,
    bizType: 0,
    clickButton: undefined,
    textInput: undefined,
    checkBox: undefined,
    toast: undefined,
    bubble: undefined,
    label: undefined,
    postStatus: 0,
  };
}

export const PostPanelV2: MessageFns<PostPanelV2> = {
  encode(message: PostPanelV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0n) {
      if (BigInt.asIntN(64, message.start) !== message.start) {
        throw new globalThis.Error("value provided for field message.start of type int64 too large");
      }
      writer.uint32(8).int64(message.start);
    }
    if (message.end !== 0n) {
      if (BigInt.asIntN(64, message.end) !== message.end) {
        throw new globalThis.Error("value provided for field message.end of type int64 too large");
      }
      writer.uint32(16).int64(message.end);
    }
    if (message.bizType !== 0) {
      writer.uint32(24).int32(message.bizType);
    }
    if (message.clickButton !== undefined) {
      ClickButtonV2.encode(message.clickButton, writer.uint32(34).fork()).join();
    }
    if (message.textInput !== undefined) {
      TextInputV2.encode(message.textInput, writer.uint32(42).fork()).join();
    }
    if (message.checkBox !== undefined) {
      CheckBoxV2.encode(message.checkBox, writer.uint32(50).fork()).join();
    }
    if (message.toast !== undefined) {
      ToastV2.encode(message.toast, writer.uint32(58).fork()).join();
    }
    if (message.bubble !== undefined) {
      BubbleV2.encode(message.bubble, writer.uint32(66).fork()).join();
    }
    if (message.label !== undefined) {
      LabelV2.encode(message.label, writer.uint32(74).fork()).join();
    }
    if (message.postStatus !== 0) {
      writer.uint32(80).int32(message.postStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostPanelV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostPanelV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bizType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clickButton = ClickButtonV2.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textInput = TextInputV2.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.checkBox = CheckBoxV2.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.toast = ToastV2.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bubble = BubbleV2.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.label = LabelV2.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.postStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostPanelV2 {
    return {
      start: isSet(object.start) ? BigInt(object.start) : 0n,
      end: isSet(object.end) ? BigInt(object.end) : 0n,
      bizType: isSet(object.bizType) ? postPanelBizTypeFromJSON(object.bizType) : 0,
      clickButton: isSet(object.clickButton) ? ClickButtonV2.fromJSON(object.clickButton) : undefined,
      textInput: isSet(object.textInput) ? TextInputV2.fromJSON(object.textInput) : undefined,
      checkBox: isSet(object.checkBox) ? CheckBoxV2.fromJSON(object.checkBox) : undefined,
      toast: isSet(object.toast) ? ToastV2.fromJSON(object.toast) : undefined,
      bubble: isSet(object.bubble) ? BubbleV2.fromJSON(object.bubble) : undefined,
      label: isSet(object.label) ? LabelV2.fromJSON(object.label) : undefined,
      postStatus: isSet(object.postStatus) ? postStatusFromJSON(object.postStatus) : 0,
    };
  },

  toJSON(message: PostPanelV2): unknown {
    const obj: any = {};
    if (message.start !== 0n) {
      obj.start = message.start.toString();
    }
    if (message.end !== 0n) {
      obj.end = message.end.toString();
    }
    if (message.bizType !== 0) {
      obj.bizType = postPanelBizTypeToJSON(message.bizType);
    }
    if (message.clickButton !== undefined) {
      obj.clickButton = ClickButtonV2.toJSON(message.clickButton);
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInputV2.toJSON(message.textInput);
    }
    if (message.checkBox !== undefined) {
      obj.checkBox = CheckBoxV2.toJSON(message.checkBox);
    }
    if (message.toast !== undefined) {
      obj.toast = ToastV2.toJSON(message.toast);
    }
    if (message.bubble !== undefined) {
      obj.bubble = BubbleV2.toJSON(message.bubble);
    }
    if (message.label !== undefined) {
      obj.label = LabelV2.toJSON(message.label);
    }
    if (message.postStatus !== 0) {
      obj.postStatus = postStatusToJSON(message.postStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostPanelV2>, I>>(base?: I): PostPanelV2 {
    return PostPanelV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostPanelV2>, I>>(object: I): PostPanelV2 {
    const message = createBasePostPanelV2();
    message.start = object.start ?? 0n;
    message.end = object.end ?? 0n;
    message.bizType = object.bizType ?? 0;
    message.clickButton = (object.clickButton !== undefined && object.clickButton !== null)
      ? ClickButtonV2.fromPartial(object.clickButton)
      : undefined;
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInputV2.fromPartial(object.textInput)
      : undefined;
    message.checkBox = (object.checkBox !== undefined && object.checkBox !== null)
      ? CheckBoxV2.fromPartial(object.checkBox)
      : undefined;
    message.toast = (object.toast !== undefined && object.toast !== null)
      ? ToastV2.fromPartial(object.toast)
      : undefined;
    message.bubble = (object.bubble !== undefined && object.bubble !== null)
      ? BubbleV2.fromPartial(object.bubble)
      : undefined;
    message.label = (object.label !== undefined && object.label !== null)
      ? LabelV2.fromPartial(object.label)
      : undefined;
    message.postStatus = object.postStatus ?? 0;
    return message;
  },
};

function createBaseClickButtonV2(): ClickButtonV2 {
  return {
    portraitText: [],
    landscapeText: [],
    portraitTextFocus: [],
    landscapeTextFocus: [],
    renderType: 0,
    textInputPost: false,
    exposureOnce: false,
    exposureType: 0,
  };
}

export const ClickButtonV2: MessageFns<ClickButtonV2> = {
  encode(message: ClickButtonV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.portraitText) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.landscapeText) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.portraitTextFocus) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.landscapeTextFocus) {
      writer.uint32(34).string(v!);
    }
    if (message.renderType !== 0) {
      writer.uint32(40).int32(message.renderType);
    }
    if (message.textInputPost !== false) {
      writer.uint32(48).bool(message.textInputPost);
    }
    if (message.exposureOnce !== false) {
      writer.uint32(56).bool(message.exposureOnce);
    }
    if (message.exposureType !== 0) {
      writer.uint32(64).int32(message.exposureType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClickButtonV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClickButtonV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portraitText.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.landscapeText.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.portraitTextFocus.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.landscapeTextFocus.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.textInputPost = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exposureOnce = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.exposureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClickButtonV2 {
    return {
      portraitText: globalThis.Array.isArray(object?.portraitText)
        ? object.portraitText.map((e: any) => globalThis.String(e))
        : [],
      landscapeText: globalThis.Array.isArray(object?.landscapeText)
        ? object.landscapeText.map((e: any) => globalThis.String(e))
        : [],
      portraitTextFocus: globalThis.Array.isArray(object?.portraitTextFocus)
        ? object.portraitTextFocus.map((e: any) => globalThis.String(e))
        : [],
      landscapeTextFocus: globalThis.Array.isArray(object?.landscapeTextFocus)
        ? object.landscapeTextFocus.map((e: any) => globalThis.String(e))
        : [],
      renderType: isSet(object.renderType) ? renderTypeFromJSON(object.renderType) : 0,
      textInputPost: isSet(object.textInputPost) ? globalThis.Boolean(object.textInputPost) : false,
      exposureOnce: isSet(object.exposureOnce) ? globalThis.Boolean(object.exposureOnce) : false,
      exposureType: isSet(object.exposureType) ? exposureTypeFromJSON(object.exposureType) : 0,
    };
  },

  toJSON(message: ClickButtonV2): unknown {
    const obj: any = {};
    if (message.portraitText?.length) {
      obj.portraitText = message.portraitText;
    }
    if (message.landscapeText?.length) {
      obj.landscapeText = message.landscapeText;
    }
    if (message.portraitTextFocus?.length) {
      obj.portraitTextFocus = message.portraitTextFocus;
    }
    if (message.landscapeTextFocus?.length) {
      obj.landscapeTextFocus = message.landscapeTextFocus;
    }
    if (message.renderType !== 0) {
      obj.renderType = renderTypeToJSON(message.renderType);
    }
    if (message.textInputPost !== false) {
      obj.textInputPost = message.textInputPost;
    }
    if (message.exposureOnce !== false) {
      obj.exposureOnce = message.exposureOnce;
    }
    if (message.exposureType !== 0) {
      obj.exposureType = exposureTypeToJSON(message.exposureType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClickButtonV2>, I>>(base?: I): ClickButtonV2 {
    return ClickButtonV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClickButtonV2>, I>>(object: I): ClickButtonV2 {
    const message = createBaseClickButtonV2();
    message.portraitText = object.portraitText?.map((e) => e) || [];
    message.landscapeText = object.landscapeText?.map((e) => e) || [];
    message.portraitTextFocus = object.portraitTextFocus?.map((e) => e) || [];
    message.landscapeTextFocus = object.landscapeTextFocus?.map((e) => e) || [];
    message.renderType = object.renderType ?? 0;
    message.textInputPost = object.textInputPost ?? false;
    message.exposureOnce = object.exposureOnce ?? false;
    message.exposureType = object.exposureType ?? 0;
    return message;
  },
};

function createBaseTextInputV2(): TextInputV2 {
  return {
    portraitPlaceholder: [],
    landscapePlaceholder: [],
    renderType: 0,
    placeholderPost: false,
    textInputLimit: 0,
  };
}

export const TextInputV2: MessageFns<TextInputV2> = {
  encode(message: TextInputV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.portraitPlaceholder) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.landscapePlaceholder) {
      writer.uint32(18).string(v!);
    }
    if (message.renderType !== 0) {
      writer.uint32(24).int32(message.renderType);
    }
    if (message.placeholderPost !== false) {
      writer.uint32(32).bool(message.placeholderPost);
    }
    if (message.textInputLimit !== 0) {
      writer.uint32(48).int32(message.textInputLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInputV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInputV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portraitPlaceholder.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.landscapePlaceholder.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.placeholderPost = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.textInputLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInputV2 {
    return {
      portraitPlaceholder: globalThis.Array.isArray(object?.portraitPlaceholder)
        ? object.portraitPlaceholder.map((e: any) => globalThis.String(e))
        : [],
      landscapePlaceholder: globalThis.Array.isArray(object?.landscapePlaceholder)
        ? object.landscapePlaceholder.map((e: any) => globalThis.String(e))
        : [],
      renderType: isSet(object.renderType) ? renderTypeFromJSON(object.renderType) : 0,
      placeholderPost: isSet(object.placeholderPost) ? globalThis.Boolean(object.placeholderPost) : false,
      textInputLimit: isSet(object.textInputLimit) ? globalThis.Number(object.textInputLimit) : 0,
    };
  },

  toJSON(message: TextInputV2): unknown {
    const obj: any = {};
    if (message.portraitPlaceholder?.length) {
      obj.portraitPlaceholder = message.portraitPlaceholder;
    }
    if (message.landscapePlaceholder?.length) {
      obj.landscapePlaceholder = message.landscapePlaceholder;
    }
    if (message.renderType !== 0) {
      obj.renderType = renderTypeToJSON(message.renderType);
    }
    if (message.placeholderPost !== false) {
      obj.placeholderPost = message.placeholderPost;
    }
    if (message.textInputLimit !== 0) {
      obj.textInputLimit = Math.round(message.textInputLimit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInputV2>, I>>(base?: I): TextInputV2 {
    return TextInputV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInputV2>, I>>(object: I): TextInputV2 {
    const message = createBaseTextInputV2();
    message.portraitPlaceholder = object.portraitPlaceholder?.map((e) => e) || [];
    message.landscapePlaceholder = object.landscapePlaceholder?.map((e) => e) || [];
    message.renderType = object.renderType ?? 0;
    message.placeholderPost = object.placeholderPost ?? false;
    message.textInputLimit = object.textInputLimit ?? 0;
    return message;
  },
};

function createBaseCheckBoxV2(): CheckBoxV2 {
  return { text: "", type: 0, defaultValue: false };
}

export const CheckBoxV2: MessageFns<CheckBoxV2> = {
  encode(message: CheckBoxV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.defaultValue !== false) {
      writer.uint32(24).bool(message.defaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBoxV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBoxV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBoxV2 {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      type: isSet(object.type) ? checkboxTypeFromJSON(object.type) : 0,
      defaultValue: isSet(object.defaultValue) ? globalThis.Boolean(object.defaultValue) : false,
    };
  },

  toJSON(message: CheckBoxV2): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.type !== 0) {
      obj.type = checkboxTypeToJSON(message.type);
    }
    if (message.defaultValue !== false) {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckBoxV2>, I>>(base?: I): CheckBoxV2 {
    return CheckBoxV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckBoxV2>, I>>(object: I): CheckBoxV2 {
    const message = createBaseCheckBoxV2();
    message.text = object.text ?? "";
    message.type = object.type ?? 0;
    message.defaultValue = object.defaultValue ?? false;
    return message;
  },
};

function createBaseToastV2(): ToastV2 {
  return { text: "", duration: 0, toastButtonV2: undefined };
}

export const ToastV2: MessageFns<ToastV2> = {
  encode(message: ToastV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int32(message.duration);
    }
    if (message.toastButtonV2 !== undefined) {
      ToastButtonV2.encode(message.toastButtonV2, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToastV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToastV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toastButtonV2 = ToastButtonV2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToastV2 {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      toastButtonV2: isSet(object.toastButtonV2) ? ToastButtonV2.fromJSON(object.toastButtonV2) : undefined,
    };
  },

  toJSON(message: ToastV2): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.toastButtonV2 !== undefined) {
      obj.toastButtonV2 = ToastButtonV2.toJSON(message.toastButtonV2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToastV2>, I>>(base?: I): ToastV2 {
    return ToastV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToastV2>, I>>(object: I): ToastV2 {
    const message = createBaseToastV2();
    message.text = object.text ?? "";
    message.duration = object.duration ?? 0;
    message.toastButtonV2 = (object.toastButtonV2 !== undefined && object.toastButtonV2 !== null)
      ? ToastButtonV2.fromPartial(object.toastButtonV2)
      : undefined;
    return message;
  },
};

function createBaseToastButtonV2(): ToastButtonV2 {
  return { text: "", action: 0 };
}

export const ToastButtonV2: MessageFns<ToastButtonV2> = {
  encode(message: ToastButtonV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToastButtonV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToastButtonV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToastButtonV2 {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      action: isSet(object.action) ? toastFunctionTypeFromJSON(object.action) : 0,
    };
  },

  toJSON(message: ToastButtonV2): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.action !== 0) {
      obj.action = toastFunctionTypeToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToastButtonV2>, I>>(base?: I): ToastButtonV2 {
    return ToastButtonV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToastButtonV2>, I>>(object: I): ToastButtonV2 {
    const message = createBaseToastButtonV2();
    message.text = object.text ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseBubbleV2(): BubbleV2 {
  return { text: "", url: "", bubbleType: 0, exposureOnce: false, exposureType: 0 };
}

export const BubbleV2: MessageFns<BubbleV2> = {
  encode(message: BubbleV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.bubbleType !== 0) {
      writer.uint32(24).int32(message.bubbleType);
    }
    if (message.exposureOnce !== false) {
      writer.uint32(32).bool(message.exposureOnce);
    }
    if (message.exposureType !== 0) {
      writer.uint32(40).int32(message.exposureType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BubbleV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBubbleV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bubbleType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exposureOnce = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.exposureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BubbleV2 {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      bubbleType: isSet(object.bubbleType) ? bubbleTypeFromJSON(object.bubbleType) : 0,
      exposureOnce: isSet(object.exposureOnce) ? globalThis.Boolean(object.exposureOnce) : false,
      exposureType: isSet(object.exposureType) ? exposureTypeFromJSON(object.exposureType) : 0,
    };
  },

  toJSON(message: BubbleV2): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.bubbleType !== 0) {
      obj.bubbleType = bubbleTypeToJSON(message.bubbleType);
    }
    if (message.exposureOnce !== false) {
      obj.exposureOnce = message.exposureOnce;
    }
    if (message.exposureType !== 0) {
      obj.exposureType = exposureTypeToJSON(message.exposureType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BubbleV2>, I>>(base?: I): BubbleV2 {
    return BubbleV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BubbleV2>, I>>(object: I): BubbleV2 {
    const message = createBaseBubbleV2();
    message.text = object.text ?? "";
    message.url = object.url ?? "";
    message.bubbleType = object.bubbleType ?? 0;
    message.exposureOnce = object.exposureOnce ?? false;
    message.exposureType = object.exposureType ?? 0;
    return message;
  },
};

function createBaseLabelV2(): LabelV2 {
  return { title: "", content: [], exposureOnce: false, exposureType: 0 };
}

export const LabelV2: MessageFns<LabelV2> = {
  encode(message: LabelV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.content) {
      writer.uint32(18).string(v!);
    }
    if (message.exposureOnce !== false) {
      writer.uint32(24).bool(message.exposureOnce);
    }
    if (message.exposureType !== 0) {
      writer.uint32(32).int32(message.exposureType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.exposureOnce = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exposureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelV2 {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: globalThis.Array.isArray(object?.content) ? object.content.map((e: any) => globalThis.String(e)) : [],
      exposureOnce: isSet(object.exposureOnce) ? globalThis.Boolean(object.exposureOnce) : false,
      exposureType: isSet(object.exposureType) ? exposureTypeFromJSON(object.exposureType) : 0,
    };
  },

  toJSON(message: LabelV2): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content?.length) {
      obj.content = message.content;
    }
    if (message.exposureOnce !== false) {
      obj.exposureOnce = message.exposureOnce;
    }
    if (message.exposureType !== 0) {
      obj.exposureType = exposureTypeToJSON(message.exposureType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LabelV2>, I>>(base?: I): LabelV2 {
    return LabelV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LabelV2>, I>>(object: I): LabelV2 {
    const message = createBaseLabelV2();
    message.title = object.title ?? "";
    message.content = object.content?.map((e) => e) || [];
    message.exposureOnce = object.exposureOnce ?? false;
    message.exposureType = object.exposureType ?? 0;
    return message;
  },
};

function createBaseDmSubView(): DmSubView {
  return { type: 0, oid: 0n, pid: 0n, postPanel2: [] };
}

export const DmSubView: MessageFns<DmSubView> = {
  encode(message: DmSubView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.oid !== 0n) {
      if (BigInt.asIntN(64, message.oid) !== message.oid) {
        throw new globalThis.Error("value provided for field message.oid of type int64 too large");
      }
      writer.uint32(16).int64(message.oid);
    }
    if (message.pid !== 0n) {
      if (BigInt.asIntN(64, message.pid) !== message.pid) {
        throw new globalThis.Error("value provided for field message.pid of type int64 too large");
      }
      writer.uint32(24).int64(message.pid);
    }
    for (const v of message.postPanel2) {
      PostPanelV2.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmSubView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmSubView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.oid = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pid = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postPanel2.push(PostPanelV2.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmSubView {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      oid: isSet(object.oid) ? BigInt(object.oid) : 0n,
      pid: isSet(object.pid) ? BigInt(object.pid) : 0n,
      postPanel2: globalThis.Array.isArray(object?.postPanel2)
        ? object.postPanel2.map((e: any) => PostPanelV2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DmSubView): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.oid !== 0n) {
      obj.oid = message.oid.toString();
    }
    if (message.pid !== 0n) {
      obj.pid = message.pid.toString();
    }
    if (message.postPanel2?.length) {
      obj.postPanel2 = message.postPanel2.map((e) => PostPanelV2.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DmSubView>, I>>(base?: I): DmSubView {
    return DmSubView.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DmSubView>, I>>(object: I): DmSubView {
    const message = createBaseDmSubView();
    message.type = object.type ?? 0;
    message.oid = object.oid ?? 0n;
    message.pid = object.pid ?? 0n;
    message.postPanel2 = object.postPanel2?.map((e) => PostPanelV2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQoeInfo(): QoeInfo {
  return { info: "" };
}

export const QoeInfo: MessageFns<QoeInfo> = {
  encode(message: QoeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== "") {
      writer.uint32(10).string(message.info);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QoeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQoeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.info = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QoeInfo {
    return { info: isSet(object.info) ? globalThis.String(object.info) : "" };
  },

  toJSON(message: QoeInfo): unknown {
    const obj: any = {};
    if (message.info !== "") {
      obj.info = message.info;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QoeInfo>, I>>(base?: I): QoeInfo {
    return QoeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QoeInfo>, I>>(object: I): QoeInfo {
    const message = createBaseQoeInfo();
    message.info = object.info ?? "";
    return message;
  },
};

function createBaseDmMaskWall(): DmMaskWall {
  return { start: 0n, end: 0n, content: "", contentType: 0, bizType: 0, contents: [] };
}

export const DmMaskWall: MessageFns<DmMaskWall> = {
  encode(message: DmMaskWall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0n) {
      if (BigInt.asIntN(64, message.start) !== message.start) {
        throw new globalThis.Error("value provided for field message.start of type int64 too large");
      }
      writer.uint32(8).int64(message.start);
    }
    if (message.end !== 0n) {
      if (BigInt.asIntN(64, message.end) !== message.end) {
        throw new globalThis.Error("value provided for field message.end of type int64 too large");
      }
      writer.uint32(16).int64(message.end);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.contentType !== 0) {
      writer.uint32(32).int32(message.contentType);
    }
    if (message.bizType !== 0) {
      writer.uint32(40).int32(message.bizType);
    }
    for (const v of message.contents) {
      DmMaskWallContent.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmMaskWall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmMaskWall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.bizType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contents.push(DmMaskWallContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmMaskWall {
    return {
      start: isSet(object.start) ? BigInt(object.start) : 0n,
      end: isSet(object.end) ? BigInt(object.end) : 0n,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      contentType: isSet(object.contentType) ? dmMaskWallContentTypeFromJSON(object.contentType) : 0,
      bizType: isSet(object.bizType) ? dmMaskWallBizTypeFromJSON(object.bizType) : 0,
      contents: globalThis.Array.isArray(object?.contents)
        ? object.contents.map((e: any) => DmMaskWallContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DmMaskWall): unknown {
    const obj: any = {};
    if (message.start !== 0n) {
      obj.start = message.start.toString();
    }
    if (message.end !== 0n) {
      obj.end = message.end.toString();
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.contentType !== 0) {
      obj.contentType = dmMaskWallContentTypeToJSON(message.contentType);
    }
    if (message.bizType !== 0) {
      obj.bizType = dmMaskWallBizTypeToJSON(message.bizType);
    }
    if (message.contents?.length) {
      obj.contents = message.contents.map((e) => DmMaskWallContent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DmMaskWall>, I>>(base?: I): DmMaskWall {
    return DmMaskWall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DmMaskWall>, I>>(object: I): DmMaskWall {
    const message = createBaseDmMaskWall();
    message.start = object.start ?? 0n;
    message.end = object.end ?? 0n;
    message.content = object.content ?? "";
    message.contentType = object.contentType ?? 0;
    message.bizType = object.bizType ?? 0;
    message.contents = object.contents?.map((e) => DmMaskWallContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDmMaskWallContent(): DmMaskWallContent {
  return { type: 0, content: "" };
}

export const DmMaskWallContent: MessageFns<DmMaskWallContent> = {
  encode(message: DmMaskWallContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DmMaskWallContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDmMaskWallContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DmMaskWallContent {
    return {
      type: isSet(object.type) ? dmMaskWallContentTypeFromJSON(object.type) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: DmMaskWallContent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = dmMaskWallContentTypeToJSON(message.type);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DmMaskWallContent>, I>>(base?: I): DmMaskWallContent {
    return DmMaskWallContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DmMaskWallContent>, I>>(object: I): DmMaskWallContent {
    const message = createBaseDmMaskWallContent();
    message.type = object.type ?? 0;
    message.content = object.content ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
