// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/pgc/gateway/player/v2/PlayViewBusinessInfo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bilibili.pgc.gateway.player.v2";

/** 跳过片头/片尾配置: Clip类型 */
export enum ClipType {
  NT_UNKNOWN = 0,
  /** CLIP_TYPE_OP - 跳过OP */
  CLIP_TYPE_OP = 1,
  /** CLIP_TYPE_ED - 跳过ED */
  CLIP_TYPE_ED = 2,
  CLIP_TYPE_HE = 3,
  CLIP_TYPE_MULTI_VIEW = 4,
  CLIP_TYPE_AD = 5,
  UNRECOGNIZED = -1,
}

export function clipTypeFromJSON(object: any): ClipType {
  switch (object) {
    case 0:
    case "NT_UNKNOWN":
      return ClipType.NT_UNKNOWN;
    case 1:
    case "CLIP_TYPE_OP":
      return ClipType.CLIP_TYPE_OP;
    case 2:
    case "CLIP_TYPE_ED":
      return ClipType.CLIP_TYPE_ED;
    case 3:
    case "CLIP_TYPE_HE":
      return ClipType.CLIP_TYPE_HE;
    case 4:
    case "CLIP_TYPE_MULTI_VIEW":
      return ClipType.CLIP_TYPE_MULTI_VIEW;
    case 5:
    case "CLIP_TYPE_AD":
      return ClipType.CLIP_TYPE_AD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClipType.UNRECOGNIZED;
  }
}

export function clipTypeToJSON(object: ClipType): string {
  switch (object) {
    case ClipType.NT_UNKNOWN:
      return "NT_UNKNOWN";
    case ClipType.CLIP_TYPE_OP:
      return "CLIP_TYPE_OP";
    case ClipType.CLIP_TYPE_ED:
      return "CLIP_TYPE_ED";
    case ClipType.CLIP_TYPE_HE:
      return "CLIP_TYPE_HE";
    case ClipType.CLIP_TYPE_MULTI_VIEW:
      return "CLIP_TYPE_MULTI_VIEW";
    case ClipType.CLIP_TYPE_AD:
      return "CLIP_TYPE_AD";
    case ClipType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InlineType {
  TYPE_UNKNOWN = 0,
  TYPE_WHOLE = 1,
  TYPE_HE_CLIP = 2,
  TYPE_PREVIEW = 3,
  UNRECOGNIZED = -1,
}

export function inlineTypeFromJSON(object: any): InlineType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return InlineType.TYPE_UNKNOWN;
    case 1:
    case "TYPE_WHOLE":
      return InlineType.TYPE_WHOLE;
    case 2:
    case "TYPE_HE_CLIP":
      return InlineType.TYPE_HE_CLIP;
    case 3:
    case "TYPE_PREVIEW":
      return InlineType.TYPE_PREVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InlineType.UNRECOGNIZED;
  }
}

export function inlineTypeToJSON(object: InlineType): string {
  switch (object) {
    case InlineType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case InlineType.TYPE_WHOLE:
      return "TYPE_WHOLE";
    case InlineType.TYPE_HE_CLIP:
      return "TYPE_HE_CLIP";
    case InlineType.TYPE_PREVIEW:
      return "TYPE_PREVIEW";
    case InlineType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DRM技术类型 */
export enum DrmTechType {
  NON = 0,
  FAIR_PLAY = 1,
  WIDE_VINE = 2,
  BILI_DRM = 3,
  UNRECOGNIZED = -1,
}

export function drmTechTypeFromJSON(object: any): DrmTechType {
  switch (object) {
    case 0:
    case "NON":
      return DrmTechType.NON;
    case 1:
    case "FAIR_PLAY":
      return DrmTechType.FAIR_PLAY;
    case 2:
    case "WIDE_VINE":
      return DrmTechType.WIDE_VINE;
    case 3:
    case "BILI_DRM":
      return DrmTechType.BILI_DRM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DrmTechType.UNRECOGNIZED;
  }
}

export function drmTechTypeToJSON(object: DrmTechType): string {
  switch (object) {
    case DrmTechType.NON:
      return "NON";
    case DrmTechType.FAIR_PLAY:
      return "FAIR_PLAY";
    case DrmTechType.WIDE_VINE:
      return "WIDE_VINE";
    case DrmTechType.BILI_DRM:
      return "BILI_DRM";
    case DrmTechType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 其他业务信息 */
export interface PlayViewBusinessInfo {
  /** 当前视频是否是预览 */
  isPreview: boolean;
  /** 用户是否承包过 */
  bp: boolean;
  /** drm使用 */
  marlinToken: string;
  /** 倍速动效色值 */
  playbackSpeedColor: string;
  continuePlayInfo:
    | ContinuePlayInfo
    | undefined;
  /** 跳过片头/片尾配置 */
  clipInfo: ClipInfo[];
  inlineType: InlineType;
  epWholeDuration: number;
  /** 当前分辨率信息 */
  dimension: Dimension | undefined;
  qualityExtMap: { [key: number]: QualityExtInfo };
  expMap: { [key: string]: number };
  /** DRM技术类型 */
  drmTechType: DrmTechType;
  limitActionType: number;
  isDrm: boolean;
  recordInfo: RecordInfo | undefined;
  vipStatus: number;
  isLivePre: boolean;
  episodeInfo: EpisodeInfo | undefined;
  episodeAdvertisementInfo: EpisodeAdvertisementInfo | undefined;
  userStatus: UserStatus | undefined;
}

export interface PlayViewBusinessInfo_QualityExtMapEntry {
  key: number;
  value: QualityExtInfo | undefined;
}

export interface PlayViewBusinessInfo_ExpMapEntry {
  key: string;
  value: number;
}

export interface ContinuePlayInfo {
  continuePlayEpId: bigint;
}

/** 跳过片头/片尾配置 */
export interface ClipInfo {
  materialNo: bigint;
  /** DASH分段始 */
  start: number;
  /** DASH分段终 */
  end: number;
  /** Clip类型 */
  clipType: ClipType;
  /** 跳过片头/片尾时的提示语 */
  toastText: string;
  multiView: MultiView | undefined;
}

export interface MultiView {
  buttonMaterial: string;
  epId: bigint;
  cid: bigint;
  avid: bigint;
}

/** 当前分辨率信息 */
export interface Dimension {
  /** 宽 */
  width: number;
  /** 长 */
  height: number;
  /** 旋转角度 */
  rotate: number;
}

/** 云控拓展视频画质信息 */
export interface QualityExtInfo {
  /** 是否支持试看 */
  trialSupport: boolean;
}

/** 备案信息 */
export interface RecordInfo {
  /** 记录 */
  record: string;
  /** 记录图标 */
  recordIcon: string;
}

/** EP信息 */
export interface EpisodeInfo {
  epId: number;
  cid: bigint;
  aid: bigint;
  epStatus: bigint;
  seasonInfo: SeasonInfo | undefined;
  cover: string;
  title: string;
  interaction: Interaction | undefined;
  longTitle: string;
}

/** PGC SEASON 信息 */
export interface SeasonInfo {
  /** PGC SEASON ID */
  seasonId: number;
  /** PGC SEASON 类型 */
  seasonType: number;
  /** PGC SEASON 状态 */
  seasonStatus: number;
  /** 封面 */
  cover: string;
  /** 标题 */
  title: string;
  /** 权限信息 */
  rights:
    | Rights
    | undefined;
  /** 模式 */
  mode: number;
}

/** 权限信息 */
export interface Rights {
  /** 是否可以观看 */
  canWatch: number;
}

/** 交互信息 */
export interface Interaction {
  /** 历史节点 */
  historyNode:
    | HistoryNode
    | undefined;
  /** 版本 */
  graphVersion: bigint;
  /** 交互消息 */
  msg: string;
  /** 是否为交互 */
  isInteraction: boolean;
}

/** 历史记录节点 */
export interface HistoryNode {
  /** 节点ID */
  nodeId: bigint;
  /** 节点标题 */
  title: string;
  /** 对应CID */
  cid: bigint;
}

/** 剧集广告信息 */
export interface EpisodeAdvertisementInfo {
  aid: bigint;
  title: string;
  link: string;
  followVideoBntFlag: number;
  nextVideoTitle: string;
  nextVideoLink: string;
  cid: bigint;
  seasonId: number;
  follow: number;
}

/** 用户状态信息 */
export interface UserStatus {
  /** 是否支付 */
  payCheck: boolean;
  /** 是否承包 */
  sponsor: boolean;
  /** 观看进度 */
  watchProgress:
    | WatchProgress
    | undefined;
  /** 系列观看进度 */
  aidWatchProgress: WatchProgress | undefined;
}

/** 观看进度信息 */
export interface WatchProgress {
  /** 上次观看的 EP ID */
  lastEpId: number;
  /** 上次观看到的EP INDEX */
  lastEpIndex: string;
  /** 上次观看的进度 */
  progress: bigint;
  /** 上次观看的 CID */
  lastPlayCid: bigint;
  /** 带时间的提示信息 */
  toast:
    | Toast
    | undefined;
  /** 不带时间的提示信息 */
  toastWithoutTime:
    | Toast
    | undefined;
  /** 上次观看的 AID */
  lastPlayAid: bigint;
}

export interface Toast {
  /** toast文案 老字段 */
  text: string;
  /** toast按钮 */
  button:
    | ButtonInfo
    | undefined;
  /** 显示样式类型 */
  showStyleType: number;
  /** 图标 */
  icon: string;
  /** toast文案 新字段 */
  toastText:
    | TextInfo
    | undefined;
  /** 埋点上报信息 */
  report: Report | undefined;
  orderReportParams: { [key: string]: string };
}

export interface Toast_OrderReportParamsEntry {
  key: string;
  value: string;
}

/** 按钮信息 */
export interface ButtonInfo {
  /** 按钮文案 */
  text: string;
  /** 按钮字体色值 */
  textColor: string;
  /** 按钮字体色值-夜间模式 */
  textColorNight: string;
  /** 按钮背景色 */
  bgColor: string;
  /** 按钮背景色-夜间模式 */
  bgColorNight: string;
  /** 按钮链接 */
  link: string;
  /** 按钮动作类型 */
  actionType: string;
  /** 角标信息 */
  badgeInfo:
    | BadgeInfo
    | undefined;
  /** 埋点上报信息 */
  report:
    | Report
    | undefined;
  /** 左侧删除线样式文案 */
  leftStrikethroughText: string;
  /** 缩略按钮文案信息 */
  simpleTextInfo:
    | TextInfo
    | undefined;
  /** 缩略按钮背景色值 */
  simpleBgColor: string;
  /** 缩略按钮字体色值-夜间模式 */
  simpleBgColorNight: string;
  bgGradientColor: GradientColor | undefined;
  orderReportParams: { [key: string]: string };
  taskParam: TaskParam | undefined;
  pcLink: string;
}

export interface ButtonInfo_OrderReportParamsEntry {
  key: string;
  value: string;
}

/** 角标信息 */
export interface BadgeInfo {
  /** 角标文案 */
  text: string;
  /** 角标色值 */
  bgColor: string;
  /** 角标色值-夜间模式 */
  bgColorNight: string;
  /** 文案色值 */
  textColor: string;
  /** ? 新版本客户端已弃用此项 */
  bgGradientColor: GradientColor | undefined;
  img: string;
}

/** 渐变色信息 */
export interface GradientColor {
  startColor: string;
  endColor: string;
}

/** 埋点上报信息 */
export interface Report {
  /** 曝光事件 */
  showEventId: string;
  /** 点击事件 */
  clickEventId: string;
  /** 埋点透传参数 */
  extends: string;
}

/** 文案信息 */
export interface TextInfo {
  /** 文案 */
  text: string;
  /** 字体色值 */
  textColor: string;
  /** 字体色值-夜间模式 */
  textColorNight: string;
}

/** 任务参数信息 */
export interface TaskParam {
  /** 任务类型 */
  taskType: string;
  /** 活动ID */
  activityId: bigint;
  /** 提示ID */
  tipsId: bigint;
}

function createBasePlayViewBusinessInfo(): PlayViewBusinessInfo {
  return {
    isPreview: false,
    bp: false,
    marlinToken: "",
    playbackSpeedColor: "",
    continuePlayInfo: undefined,
    clipInfo: [],
    inlineType: 0,
    epWholeDuration: 0,
    dimension: undefined,
    qualityExtMap: {},
    expMap: {},
    drmTechType: 0,
    limitActionType: 0,
    isDrm: false,
    recordInfo: undefined,
    vipStatus: 0,
    isLivePre: false,
    episodeInfo: undefined,
    episodeAdvertisementInfo: undefined,
    userStatus: undefined,
  };
}

export const PlayViewBusinessInfo: MessageFns<PlayViewBusinessInfo> = {
  encode(message: PlayViewBusinessInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isPreview !== false) {
      writer.uint32(8).bool(message.isPreview);
    }
    if (message.bp !== false) {
      writer.uint32(16).bool(message.bp);
    }
    if (message.marlinToken !== "") {
      writer.uint32(26).string(message.marlinToken);
    }
    if (message.playbackSpeedColor !== "") {
      writer.uint32(34).string(message.playbackSpeedColor);
    }
    if (message.continuePlayInfo !== undefined) {
      ContinuePlayInfo.encode(message.continuePlayInfo, writer.uint32(42).fork()).join();
    }
    for (const v of message.clipInfo) {
      ClipInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.inlineType !== 0) {
      writer.uint32(56).int32(message.inlineType);
    }
    if (message.epWholeDuration !== 0) {
      writer.uint32(64).int32(message.epWholeDuration);
    }
    if (message.dimension !== undefined) {
      Dimension.encode(message.dimension, writer.uint32(74).fork()).join();
    }
    Object.entries(message.qualityExtMap).forEach(([key, value]) => {
      PlayViewBusinessInfo_QualityExtMapEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    Object.entries(message.expMap).forEach(([key, value]) => {
      PlayViewBusinessInfo_ExpMapEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.drmTechType !== 0) {
      writer.uint32(96).int32(message.drmTechType);
    }
    if (message.limitActionType !== 0) {
      writer.uint32(104).int32(message.limitActionType);
    }
    if (message.isDrm !== false) {
      writer.uint32(112).bool(message.isDrm);
    }
    if (message.recordInfo !== undefined) {
      RecordInfo.encode(message.recordInfo, writer.uint32(122).fork()).join();
    }
    if (message.vipStatus !== 0) {
      writer.uint32(128).int32(message.vipStatus);
    }
    if (message.isLivePre !== false) {
      writer.uint32(136).bool(message.isLivePre);
    }
    if (message.episodeInfo !== undefined) {
      EpisodeInfo.encode(message.episodeInfo, writer.uint32(146).fork()).join();
    }
    if (message.episodeAdvertisementInfo !== undefined) {
      EpisodeAdvertisementInfo.encode(message.episodeAdvertisementInfo, writer.uint32(154).fork()).join();
    }
    if (message.userStatus !== undefined) {
      UserStatus.encode(message.userStatus, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayViewBusinessInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayViewBusinessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isPreview = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bp = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.marlinToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.playbackSpeedColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.continuePlayInfo = ContinuePlayInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clipInfo.push(ClipInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.inlineType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.epWholeDuration = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dimension = Dimension.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = PlayViewBusinessInfo_QualityExtMapEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.qualityExtMap[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = PlayViewBusinessInfo_ExpMapEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.expMap[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.drmTechType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.limitActionType = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isDrm = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.recordInfo = RecordInfo.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.vipStatus = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isLivePre = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.episodeInfo = EpisodeInfo.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.episodeAdvertisementInfo = EpisodeAdvertisementInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.userStatus = UserStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayViewBusinessInfo {
    return {
      isPreview: isSet(object.isPreview) ? globalThis.Boolean(object.isPreview) : false,
      bp: isSet(object.bp) ? globalThis.Boolean(object.bp) : false,
      marlinToken: isSet(object.marlinToken) ? globalThis.String(object.marlinToken) : "",
      playbackSpeedColor: isSet(object.playbackSpeedColor) ? globalThis.String(object.playbackSpeedColor) : "",
      continuePlayInfo: isSet(object.continuePlayInfo) ? ContinuePlayInfo.fromJSON(object.continuePlayInfo) : undefined,
      clipInfo: globalThis.Array.isArray(object?.clipInfo) ? object.clipInfo.map((e: any) => ClipInfo.fromJSON(e)) : [],
      inlineType: isSet(object.inlineType) ? inlineTypeFromJSON(object.inlineType) : 0,
      epWholeDuration: isSet(object.epWholeDuration) ? globalThis.Number(object.epWholeDuration) : 0,
      dimension: isSet(object.dimension) ? Dimension.fromJSON(object.dimension) : undefined,
      qualityExtMap: isObject(object.qualityExtMap)
        ? Object.entries(object.qualityExtMap).reduce<{ [key: number]: QualityExtInfo }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = QualityExtInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      expMap: isObject(object.expMap)
        ? Object.entries(object.expMap).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      drmTechType: isSet(object.drmTechType) ? drmTechTypeFromJSON(object.drmTechType) : 0,
      limitActionType: isSet(object.limitActionType) ? globalThis.Number(object.limitActionType) : 0,
      isDrm: isSet(object.isDrm) ? globalThis.Boolean(object.isDrm) : false,
      recordInfo: isSet(object.recordInfo) ? RecordInfo.fromJSON(object.recordInfo) : undefined,
      vipStatus: isSet(object.vipStatus) ? globalThis.Number(object.vipStatus) : 0,
      isLivePre: isSet(object.isLivePre) ? globalThis.Boolean(object.isLivePre) : false,
      episodeInfo: isSet(object.episodeInfo) ? EpisodeInfo.fromJSON(object.episodeInfo) : undefined,
      episodeAdvertisementInfo: isSet(object.episodeAdvertisementInfo)
        ? EpisodeAdvertisementInfo.fromJSON(object.episodeAdvertisementInfo)
        : undefined,
      userStatus: isSet(object.userStatus) ? UserStatus.fromJSON(object.userStatus) : undefined,
    };
  },

  toJSON(message: PlayViewBusinessInfo): unknown {
    const obj: any = {};
    if (message.isPreview !== false) {
      obj.isPreview = message.isPreview;
    }
    if (message.bp !== false) {
      obj.bp = message.bp;
    }
    if (message.marlinToken !== "") {
      obj.marlinToken = message.marlinToken;
    }
    if (message.playbackSpeedColor !== "") {
      obj.playbackSpeedColor = message.playbackSpeedColor;
    }
    if (message.continuePlayInfo !== undefined) {
      obj.continuePlayInfo = ContinuePlayInfo.toJSON(message.continuePlayInfo);
    }
    if (message.clipInfo?.length) {
      obj.clipInfo = message.clipInfo.map((e) => ClipInfo.toJSON(e));
    }
    if (message.inlineType !== 0) {
      obj.inlineType = inlineTypeToJSON(message.inlineType);
    }
    if (message.epWholeDuration !== 0) {
      obj.epWholeDuration = Math.round(message.epWholeDuration);
    }
    if (message.dimension !== undefined) {
      obj.dimension = Dimension.toJSON(message.dimension);
    }
    if (message.qualityExtMap) {
      const entries = Object.entries(message.qualityExtMap);
      if (entries.length > 0) {
        obj.qualityExtMap = {};
        entries.forEach(([k, v]) => {
          obj.qualityExtMap[k] = QualityExtInfo.toJSON(v);
        });
      }
    }
    if (message.expMap) {
      const entries = Object.entries(message.expMap);
      if (entries.length > 0) {
        obj.expMap = {};
        entries.forEach(([k, v]) => {
          obj.expMap[k] = Math.round(v);
        });
      }
    }
    if (message.drmTechType !== 0) {
      obj.drmTechType = drmTechTypeToJSON(message.drmTechType);
    }
    if (message.limitActionType !== 0) {
      obj.limitActionType = Math.round(message.limitActionType);
    }
    if (message.isDrm !== false) {
      obj.isDrm = message.isDrm;
    }
    if (message.recordInfo !== undefined) {
      obj.recordInfo = RecordInfo.toJSON(message.recordInfo);
    }
    if (message.vipStatus !== 0) {
      obj.vipStatus = Math.round(message.vipStatus);
    }
    if (message.isLivePre !== false) {
      obj.isLivePre = message.isLivePre;
    }
    if (message.episodeInfo !== undefined) {
      obj.episodeInfo = EpisodeInfo.toJSON(message.episodeInfo);
    }
    if (message.episodeAdvertisementInfo !== undefined) {
      obj.episodeAdvertisementInfo = EpisodeAdvertisementInfo.toJSON(message.episodeAdvertisementInfo);
    }
    if (message.userStatus !== undefined) {
      obj.userStatus = UserStatus.toJSON(message.userStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayViewBusinessInfo>, I>>(base?: I): PlayViewBusinessInfo {
    return PlayViewBusinessInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayViewBusinessInfo>, I>>(object: I): PlayViewBusinessInfo {
    const message = createBasePlayViewBusinessInfo();
    message.isPreview = object.isPreview ?? false;
    message.bp = object.bp ?? false;
    message.marlinToken = object.marlinToken ?? "";
    message.playbackSpeedColor = object.playbackSpeedColor ?? "";
    message.continuePlayInfo = (object.continuePlayInfo !== undefined && object.continuePlayInfo !== null)
      ? ContinuePlayInfo.fromPartial(object.continuePlayInfo)
      : undefined;
    message.clipInfo = object.clipInfo?.map((e) => ClipInfo.fromPartial(e)) || [];
    message.inlineType = object.inlineType ?? 0;
    message.epWholeDuration = object.epWholeDuration ?? 0;
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? Dimension.fromPartial(object.dimension)
      : undefined;
    message.qualityExtMap = Object.entries(object.qualityExtMap ?? {}).reduce<{ [key: number]: QualityExtInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = QualityExtInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.expMap = Object.entries(object.expMap ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.drmTechType = object.drmTechType ?? 0;
    message.limitActionType = object.limitActionType ?? 0;
    message.isDrm = object.isDrm ?? false;
    message.recordInfo = (object.recordInfo !== undefined && object.recordInfo !== null)
      ? RecordInfo.fromPartial(object.recordInfo)
      : undefined;
    message.vipStatus = object.vipStatus ?? 0;
    message.isLivePre = object.isLivePre ?? false;
    message.episodeInfo = (object.episodeInfo !== undefined && object.episodeInfo !== null)
      ? EpisodeInfo.fromPartial(object.episodeInfo)
      : undefined;
    message.episodeAdvertisementInfo =
      (object.episodeAdvertisementInfo !== undefined && object.episodeAdvertisementInfo !== null)
        ? EpisodeAdvertisementInfo.fromPartial(object.episodeAdvertisementInfo)
        : undefined;
    message.userStatus = (object.userStatus !== undefined && object.userStatus !== null)
      ? UserStatus.fromPartial(object.userStatus)
      : undefined;
    return message;
  },
};

function createBasePlayViewBusinessInfo_QualityExtMapEntry(): PlayViewBusinessInfo_QualityExtMapEntry {
  return { key: 0, value: undefined };
}

export const PlayViewBusinessInfo_QualityExtMapEntry: MessageFns<PlayViewBusinessInfo_QualityExtMapEntry> = {
  encode(message: PlayViewBusinessInfo_QualityExtMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      QualityExtInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayViewBusinessInfo_QualityExtMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayViewBusinessInfo_QualityExtMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = QualityExtInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayViewBusinessInfo_QualityExtMapEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? QualityExtInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PlayViewBusinessInfo_QualityExtMapEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = QualityExtInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayViewBusinessInfo_QualityExtMapEntry>, I>>(
    base?: I,
  ): PlayViewBusinessInfo_QualityExtMapEntry {
    return PlayViewBusinessInfo_QualityExtMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayViewBusinessInfo_QualityExtMapEntry>, I>>(
    object: I,
  ): PlayViewBusinessInfo_QualityExtMapEntry {
    const message = createBasePlayViewBusinessInfo_QualityExtMapEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? QualityExtInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePlayViewBusinessInfo_ExpMapEntry(): PlayViewBusinessInfo_ExpMapEntry {
  return { key: "", value: 0 };
}

export const PlayViewBusinessInfo_ExpMapEntry: MessageFns<PlayViewBusinessInfo_ExpMapEntry> = {
  encode(message: PlayViewBusinessInfo_ExpMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayViewBusinessInfo_ExpMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayViewBusinessInfo_ExpMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayViewBusinessInfo_ExpMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: PlayViewBusinessInfo_ExpMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayViewBusinessInfo_ExpMapEntry>, I>>(
    base?: I,
  ): PlayViewBusinessInfo_ExpMapEntry {
    return PlayViewBusinessInfo_ExpMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayViewBusinessInfo_ExpMapEntry>, I>>(
    object: I,
  ): PlayViewBusinessInfo_ExpMapEntry {
    const message = createBasePlayViewBusinessInfo_ExpMapEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseContinuePlayInfo(): ContinuePlayInfo {
  return { continuePlayEpId: 0n };
}

export const ContinuePlayInfo: MessageFns<ContinuePlayInfo> = {
  encode(message: ContinuePlayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.continuePlayEpId !== 0n) {
      if (BigInt.asIntN(64, message.continuePlayEpId) !== message.continuePlayEpId) {
        throw new globalThis.Error("value provided for field message.continuePlayEpId of type int64 too large");
      }
      writer.uint32(8).int64(message.continuePlayEpId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContinuePlayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContinuePlayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.continuePlayEpId = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContinuePlayInfo {
    return { continuePlayEpId: isSet(object.continuePlayEpId) ? BigInt(object.continuePlayEpId) : 0n };
  },

  toJSON(message: ContinuePlayInfo): unknown {
    const obj: any = {};
    if (message.continuePlayEpId !== 0n) {
      obj.continuePlayEpId = message.continuePlayEpId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContinuePlayInfo>, I>>(base?: I): ContinuePlayInfo {
    return ContinuePlayInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContinuePlayInfo>, I>>(object: I): ContinuePlayInfo {
    const message = createBaseContinuePlayInfo();
    message.continuePlayEpId = object.continuePlayEpId ?? 0n;
    return message;
  },
};

function createBaseClipInfo(): ClipInfo {
  return { materialNo: 0n, start: 0, end: 0, clipType: 0, toastText: "", multiView: undefined };
}

export const ClipInfo: MessageFns<ClipInfo> = {
  encode(message: ClipInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.materialNo !== 0n) {
      if (BigInt.asIntN(64, message.materialNo) !== message.materialNo) {
        throw new globalThis.Error("value provided for field message.materialNo of type int64 too large");
      }
      writer.uint32(8).int64(message.materialNo);
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(24).int32(message.end);
    }
    if (message.clipType !== 0) {
      writer.uint32(32).int32(message.clipType);
    }
    if (message.toastText !== "") {
      writer.uint32(42).string(message.toastText);
    }
    if (message.multiView !== undefined) {
      MultiView.encode(message.multiView, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.materialNo = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.end = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.clipType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toastText = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.multiView = MultiView.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipInfo {
    return {
      materialNo: isSet(object.materialNo) ? BigInt(object.materialNo) : 0n,
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      clipType: isSet(object.clipType) ? clipTypeFromJSON(object.clipType) : 0,
      toastText: isSet(object.toastText) ? globalThis.String(object.toastText) : "",
      multiView: isSet(object.multiView) ? MultiView.fromJSON(object.multiView) : undefined,
    };
  },

  toJSON(message: ClipInfo): unknown {
    const obj: any = {};
    if (message.materialNo !== 0n) {
      obj.materialNo = message.materialNo.toString();
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.clipType !== 0) {
      obj.clipType = clipTypeToJSON(message.clipType);
    }
    if (message.toastText !== "") {
      obj.toastText = message.toastText;
    }
    if (message.multiView !== undefined) {
      obj.multiView = MultiView.toJSON(message.multiView);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClipInfo>, I>>(base?: I): ClipInfo {
    return ClipInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClipInfo>, I>>(object: I): ClipInfo {
    const message = createBaseClipInfo();
    message.materialNo = object.materialNo ?? 0n;
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.clipType = object.clipType ?? 0;
    message.toastText = object.toastText ?? "";
    message.multiView = (object.multiView !== undefined && object.multiView !== null)
      ? MultiView.fromPartial(object.multiView)
      : undefined;
    return message;
  },
};

function createBaseMultiView(): MultiView {
  return { buttonMaterial: "", epId: 0n, cid: 0n, avid: 0n };
}

export const MultiView: MessageFns<MultiView> = {
  encode(message: MultiView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buttonMaterial !== "") {
      writer.uint32(10).string(message.buttonMaterial);
    }
    if (message.epId !== 0n) {
      if (BigInt.asIntN(64, message.epId) !== message.epId) {
        throw new globalThis.Error("value provided for field message.epId of type int64 too large");
      }
      writer.uint32(16).int64(message.epId);
    }
    if (message.cid !== 0n) {
      if (BigInt.asIntN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type int64 too large");
      }
      writer.uint32(24).int64(message.cid);
    }
    if (message.avid !== 0n) {
      if (BigInt.asIntN(64, message.avid) !== message.avid) {
        throw new globalThis.Error("value provided for field message.avid of type int64 too large");
      }
      writer.uint32(32).int64(message.avid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buttonMaterial = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.epId = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cid = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.avid = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiView {
    return {
      buttonMaterial: isSet(object.buttonMaterial) ? globalThis.String(object.buttonMaterial) : "",
      epId: isSet(object.epId) ? BigInt(object.epId) : 0n,
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
      avid: isSet(object.avid) ? BigInt(object.avid) : 0n,
    };
  },

  toJSON(message: MultiView): unknown {
    const obj: any = {};
    if (message.buttonMaterial !== "") {
      obj.buttonMaterial = message.buttonMaterial;
    }
    if (message.epId !== 0n) {
      obj.epId = message.epId.toString();
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    if (message.avid !== 0n) {
      obj.avid = message.avid.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiView>, I>>(base?: I): MultiView {
    return MultiView.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiView>, I>>(object: I): MultiView {
    const message = createBaseMultiView();
    message.buttonMaterial = object.buttonMaterial ?? "";
    message.epId = object.epId ?? 0n;
    message.cid = object.cid ?? 0n;
    message.avid = object.avid ?? 0n;
    return message;
  },
};

function createBaseDimension(): Dimension {
  return { width: 0, height: 0, rotate: 0 };
}

export const Dimension: MessageFns<Dimension> = {
  encode(message: Dimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.rotate !== 0) {
      writer.uint32(24).int32(message.rotate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rotate = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimension {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      rotate: isSet(object.rotate) ? globalThis.Number(object.rotate) : 0,
    };
  },

  toJSON(message: Dimension): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.rotate !== 0) {
      obj.rotate = Math.round(message.rotate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dimension>, I>>(base?: I): Dimension {
    return Dimension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dimension>, I>>(object: I): Dimension {
    const message = createBaseDimension();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.rotate = object.rotate ?? 0;
    return message;
  },
};

function createBaseQualityExtInfo(): QualityExtInfo {
  return { trialSupport: false };
}

export const QualityExtInfo: MessageFns<QualityExtInfo> = {
  encode(message: QualityExtInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trialSupport !== false) {
      writer.uint32(8).bool(message.trialSupport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QualityExtInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQualityExtInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trialSupport = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QualityExtInfo {
    return { trialSupport: isSet(object.trialSupport) ? globalThis.Boolean(object.trialSupport) : false };
  },

  toJSON(message: QualityExtInfo): unknown {
    const obj: any = {};
    if (message.trialSupport !== false) {
      obj.trialSupport = message.trialSupport;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QualityExtInfo>, I>>(base?: I): QualityExtInfo {
    return QualityExtInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QualityExtInfo>, I>>(object: I): QualityExtInfo {
    const message = createBaseQualityExtInfo();
    message.trialSupport = object.trialSupport ?? false;
    return message;
  },
};

function createBaseRecordInfo(): RecordInfo {
  return { record: "", recordIcon: "" };
}

export const RecordInfo: MessageFns<RecordInfo> = {
  encode(message: RecordInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== "") {
      writer.uint32(10).string(message.record);
    }
    if (message.recordIcon !== "") {
      writer.uint32(18).string(message.recordIcon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recordIcon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordInfo {
    return {
      record: isSet(object.record) ? globalThis.String(object.record) : "",
      recordIcon: isSet(object.recordIcon) ? globalThis.String(object.recordIcon) : "",
    };
  },

  toJSON(message: RecordInfo): unknown {
    const obj: any = {};
    if (message.record !== "") {
      obj.record = message.record;
    }
    if (message.recordIcon !== "") {
      obj.recordIcon = message.recordIcon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordInfo>, I>>(base?: I): RecordInfo {
    return RecordInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordInfo>, I>>(object: I): RecordInfo {
    const message = createBaseRecordInfo();
    message.record = object.record ?? "";
    message.recordIcon = object.recordIcon ?? "";
    return message;
  },
};

function createBaseEpisodeInfo(): EpisodeInfo {
  return {
    epId: 0,
    cid: 0n,
    aid: 0n,
    epStatus: 0n,
    seasonInfo: undefined,
    cover: "",
    title: "",
    interaction: undefined,
    longTitle: "",
  };
}

export const EpisodeInfo: MessageFns<EpisodeInfo> = {
  encode(message: EpisodeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epId !== 0) {
      writer.uint32(8).int32(message.epId);
    }
    if (message.cid !== 0n) {
      if (BigInt.asIntN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type int64 too large");
      }
      writer.uint32(16).int64(message.cid);
    }
    if (message.aid !== 0n) {
      if (BigInt.asIntN(64, message.aid) !== message.aid) {
        throw new globalThis.Error("value provided for field message.aid of type int64 too large");
      }
      writer.uint32(24).int64(message.aid);
    }
    if (message.epStatus !== 0n) {
      if (BigInt.asIntN(64, message.epStatus) !== message.epStatus) {
        throw new globalThis.Error("value provided for field message.epStatus of type int64 too large");
      }
      writer.uint32(32).int64(message.epStatus);
    }
    if (message.seasonInfo !== undefined) {
      SeasonInfo.encode(message.seasonInfo, writer.uint32(42).fork()).join();
    }
    if (message.cover !== "") {
      writer.uint32(50).string(message.cover);
    }
    if (message.title !== "") {
      writer.uint32(58).string(message.title);
    }
    if (message.interaction !== undefined) {
      Interaction.encode(message.interaction, writer.uint32(66).fork()).join();
    }
    if (message.longTitle !== "") {
      writer.uint32(74).string(message.longTitle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpisodeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpisodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cid = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aid = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.epStatus = reader.int64() as bigint;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.seasonInfo = SeasonInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cover = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.title = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.interaction = Interaction.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.longTitle = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpisodeInfo {
    return {
      epId: isSet(object.epId) ? globalThis.Number(object.epId) : 0,
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
      aid: isSet(object.aid) ? BigInt(object.aid) : 0n,
      epStatus: isSet(object.epStatus) ? BigInt(object.epStatus) : 0n,
      seasonInfo: isSet(object.seasonInfo) ? SeasonInfo.fromJSON(object.seasonInfo) : undefined,
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      interaction: isSet(object.interaction) ? Interaction.fromJSON(object.interaction) : undefined,
      longTitle: isSet(object.longTitle) ? globalThis.String(object.longTitle) : "",
    };
  },

  toJSON(message: EpisodeInfo): unknown {
    const obj: any = {};
    if (message.epId !== 0) {
      obj.epId = Math.round(message.epId);
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    if (message.aid !== 0n) {
      obj.aid = message.aid.toString();
    }
    if (message.epStatus !== 0n) {
      obj.epStatus = message.epStatus.toString();
    }
    if (message.seasonInfo !== undefined) {
      obj.seasonInfo = SeasonInfo.toJSON(message.seasonInfo);
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.interaction !== undefined) {
      obj.interaction = Interaction.toJSON(message.interaction);
    }
    if (message.longTitle !== "") {
      obj.longTitle = message.longTitle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpisodeInfo>, I>>(base?: I): EpisodeInfo {
    return EpisodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpisodeInfo>, I>>(object: I): EpisodeInfo {
    const message = createBaseEpisodeInfo();
    message.epId = object.epId ?? 0;
    message.cid = object.cid ?? 0n;
    message.aid = object.aid ?? 0n;
    message.epStatus = object.epStatus ?? 0n;
    message.seasonInfo = (object.seasonInfo !== undefined && object.seasonInfo !== null)
      ? SeasonInfo.fromPartial(object.seasonInfo)
      : undefined;
    message.cover = object.cover ?? "";
    message.title = object.title ?? "";
    message.interaction = (object.interaction !== undefined && object.interaction !== null)
      ? Interaction.fromPartial(object.interaction)
      : undefined;
    message.longTitle = object.longTitle ?? "";
    return message;
  },
};

function createBaseSeasonInfo(): SeasonInfo {
  return { seasonId: 0, seasonType: 0, seasonStatus: 0, cover: "", title: "", rights: undefined, mode: 0 };
}

export const SeasonInfo: MessageFns<SeasonInfo> = {
  encode(message: SeasonInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seasonId !== 0) {
      writer.uint32(8).int32(message.seasonId);
    }
    if (message.seasonType !== 0) {
      writer.uint32(16).int32(message.seasonType);
    }
    if (message.seasonStatus !== 0) {
      writer.uint32(24).int32(message.seasonStatus);
    }
    if (message.cover !== "") {
      writer.uint32(34).string(message.cover);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.rights !== undefined) {
      Rights.encode(message.rights, writer.uint32(50).fork()).join();
    }
    if (message.mode !== 0) {
      writer.uint32(56).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeasonInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeasonInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seasonId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seasonType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.seasonStatus = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cover = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rights = Rights.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeasonInfo {
    return {
      seasonId: isSet(object.seasonId) ? globalThis.Number(object.seasonId) : 0,
      seasonType: isSet(object.seasonType) ? globalThis.Number(object.seasonType) : 0,
      seasonStatus: isSet(object.seasonStatus) ? globalThis.Number(object.seasonStatus) : 0,
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      rights: isSet(object.rights) ? Rights.fromJSON(object.rights) : undefined,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: SeasonInfo): unknown {
    const obj: any = {};
    if (message.seasonId !== 0) {
      obj.seasonId = Math.round(message.seasonId);
    }
    if (message.seasonType !== 0) {
      obj.seasonType = Math.round(message.seasonType);
    }
    if (message.seasonStatus !== 0) {
      obj.seasonStatus = Math.round(message.seasonStatus);
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.rights !== undefined) {
      obj.rights = Rights.toJSON(message.rights);
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SeasonInfo>, I>>(base?: I): SeasonInfo {
    return SeasonInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SeasonInfo>, I>>(object: I): SeasonInfo {
    const message = createBaseSeasonInfo();
    message.seasonId = object.seasonId ?? 0;
    message.seasonType = object.seasonType ?? 0;
    message.seasonStatus = object.seasonStatus ?? 0;
    message.cover = object.cover ?? "";
    message.title = object.title ?? "";
    message.rights = (object.rights !== undefined && object.rights !== null)
      ? Rights.fromPartial(object.rights)
      : undefined;
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseRights(): Rights {
  return { canWatch: 0 };
}

export const Rights: MessageFns<Rights> = {
  encode(message: Rights, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canWatch !== 0) {
      writer.uint32(8).int32(message.canWatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rights {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRights();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.canWatch = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rights {
    return { canWatch: isSet(object.canWatch) ? globalThis.Number(object.canWatch) : 0 };
  },

  toJSON(message: Rights): unknown {
    const obj: any = {};
    if (message.canWatch !== 0) {
      obj.canWatch = Math.round(message.canWatch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rights>, I>>(base?: I): Rights {
    return Rights.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rights>, I>>(object: I): Rights {
    const message = createBaseRights();
    message.canWatch = object.canWatch ?? 0;
    return message;
  },
};

function createBaseInteraction(): Interaction {
  return { historyNode: undefined, graphVersion: 0n, msg: "", isInteraction: false };
}

export const Interaction: MessageFns<Interaction> = {
  encode(message: Interaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.historyNode !== undefined) {
      HistoryNode.encode(message.historyNode, writer.uint32(10).fork()).join();
    }
    if (message.graphVersion !== 0n) {
      if (BigInt.asIntN(64, message.graphVersion) !== message.graphVersion) {
        throw new globalThis.Error("value provided for field message.graphVersion of type int64 too large");
      }
      writer.uint32(16).int64(message.graphVersion);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    if (message.isInteraction !== false) {
      writer.uint32(32).bool(message.isInteraction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.historyNode = HistoryNode.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.graphVersion = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isInteraction = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interaction {
    return {
      historyNode: isSet(object.historyNode) ? HistoryNode.fromJSON(object.historyNode) : undefined,
      graphVersion: isSet(object.graphVersion) ? BigInt(object.graphVersion) : 0n,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      isInteraction: isSet(object.isInteraction) ? globalThis.Boolean(object.isInteraction) : false,
    };
  },

  toJSON(message: Interaction): unknown {
    const obj: any = {};
    if (message.historyNode !== undefined) {
      obj.historyNode = HistoryNode.toJSON(message.historyNode);
    }
    if (message.graphVersion !== 0n) {
      obj.graphVersion = message.graphVersion.toString();
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.isInteraction !== false) {
      obj.isInteraction = message.isInteraction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Interaction>, I>>(base?: I): Interaction {
    return Interaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Interaction>, I>>(object: I): Interaction {
    const message = createBaseInteraction();
    message.historyNode = (object.historyNode !== undefined && object.historyNode !== null)
      ? HistoryNode.fromPartial(object.historyNode)
      : undefined;
    message.graphVersion = object.graphVersion ?? 0n;
    message.msg = object.msg ?? "";
    message.isInteraction = object.isInteraction ?? false;
    return message;
  },
};

function createBaseHistoryNode(): HistoryNode {
  return { nodeId: 0n, title: "", cid: 0n };
}

export const HistoryNode: MessageFns<HistoryNode> = {
  encode(message: HistoryNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0n) {
      if (BigInt.asIntN(64, message.nodeId) !== message.nodeId) {
        throw new globalThis.Error("value provided for field message.nodeId of type int64 too large");
      }
      writer.uint32(8).int64(message.nodeId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.cid !== 0n) {
      if (BigInt.asIntN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type int64 too large");
      }
      writer.uint32(24).int64(message.cid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoryNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoryNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cid = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistoryNode {
    return {
      nodeId: isSet(object.nodeId) ? BigInt(object.nodeId) : 0n,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
    };
  },

  toJSON(message: HistoryNode): unknown {
    const obj: any = {};
    if (message.nodeId !== 0n) {
      obj.nodeId = message.nodeId.toString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistoryNode>, I>>(base?: I): HistoryNode {
    return HistoryNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistoryNode>, I>>(object: I): HistoryNode {
    const message = createBaseHistoryNode();
    message.nodeId = object.nodeId ?? 0n;
    message.title = object.title ?? "";
    message.cid = object.cid ?? 0n;
    return message;
  },
};

function createBaseEpisodeAdvertisementInfo(): EpisodeAdvertisementInfo {
  return {
    aid: 0n,
    title: "",
    link: "",
    followVideoBntFlag: 0,
    nextVideoTitle: "",
    nextVideoLink: "",
    cid: 0n,
    seasonId: 0,
    follow: 0,
  };
}

export const EpisodeAdvertisementInfo: MessageFns<EpisodeAdvertisementInfo> = {
  encode(message: EpisodeAdvertisementInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aid !== 0n) {
      if (BigInt.asIntN(64, message.aid) !== message.aid) {
        throw new globalThis.Error("value provided for field message.aid of type int64 too large");
      }
      writer.uint32(8).int64(message.aid);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.link !== "") {
      writer.uint32(26).string(message.link);
    }
    if (message.followVideoBntFlag !== 0) {
      writer.uint32(32).int32(message.followVideoBntFlag);
    }
    if (message.nextVideoTitle !== "") {
      writer.uint32(42).string(message.nextVideoTitle);
    }
    if (message.nextVideoLink !== "") {
      writer.uint32(50).string(message.nextVideoLink);
    }
    if (message.cid !== 0n) {
      if (BigInt.asIntN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type int64 too large");
      }
      writer.uint32(56).int64(message.cid);
    }
    if (message.seasonId !== 0) {
      writer.uint32(64).int32(message.seasonId);
    }
    if (message.follow !== 0) {
      writer.uint32(72).int32(message.follow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EpisodeAdvertisementInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpisodeAdvertisementInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.aid = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.link = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.followVideoBntFlag = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nextVideoTitle = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nextVideoLink = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cid = reader.int64() as bigint;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.seasonId = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.follow = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EpisodeAdvertisementInfo {
    return {
      aid: isSet(object.aid) ? BigInt(object.aid) : 0n,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      followVideoBntFlag: isSet(object.followVideoBntFlag) ? globalThis.Number(object.followVideoBntFlag) : 0,
      nextVideoTitle: isSet(object.nextVideoTitle) ? globalThis.String(object.nextVideoTitle) : "",
      nextVideoLink: isSet(object.nextVideoLink) ? globalThis.String(object.nextVideoLink) : "",
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
      seasonId: isSet(object.seasonId) ? globalThis.Number(object.seasonId) : 0,
      follow: isSet(object.follow) ? globalThis.Number(object.follow) : 0,
    };
  },

  toJSON(message: EpisodeAdvertisementInfo): unknown {
    const obj: any = {};
    if (message.aid !== 0n) {
      obj.aid = message.aid.toString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.followVideoBntFlag !== 0) {
      obj.followVideoBntFlag = Math.round(message.followVideoBntFlag);
    }
    if (message.nextVideoTitle !== "") {
      obj.nextVideoTitle = message.nextVideoTitle;
    }
    if (message.nextVideoLink !== "") {
      obj.nextVideoLink = message.nextVideoLink;
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    if (message.seasonId !== 0) {
      obj.seasonId = Math.round(message.seasonId);
    }
    if (message.follow !== 0) {
      obj.follow = Math.round(message.follow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EpisodeAdvertisementInfo>, I>>(base?: I): EpisodeAdvertisementInfo {
    return EpisodeAdvertisementInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EpisodeAdvertisementInfo>, I>>(object: I): EpisodeAdvertisementInfo {
    const message = createBaseEpisodeAdvertisementInfo();
    message.aid = object.aid ?? 0n;
    message.title = object.title ?? "";
    message.link = object.link ?? "";
    message.followVideoBntFlag = object.followVideoBntFlag ?? 0;
    message.nextVideoTitle = object.nextVideoTitle ?? "";
    message.nextVideoLink = object.nextVideoLink ?? "";
    message.cid = object.cid ?? 0n;
    message.seasonId = object.seasonId ?? 0;
    message.follow = object.follow ?? 0;
    return message;
  },
};

function createBaseUserStatus(): UserStatus {
  return { payCheck: false, sponsor: false, watchProgress: undefined, aidWatchProgress: undefined };
}

export const UserStatus: MessageFns<UserStatus> = {
  encode(message: UserStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payCheck !== false) {
      writer.uint32(8).bool(message.payCheck);
    }
    if (message.sponsor !== false) {
      writer.uint32(16).bool(message.sponsor);
    }
    if (message.watchProgress !== undefined) {
      WatchProgress.encode(message.watchProgress, writer.uint32(26).fork()).join();
    }
    if (message.aidWatchProgress !== undefined) {
      WatchProgress.encode(message.aidWatchProgress, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.payCheck = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sponsor = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.watchProgress = WatchProgress.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aidWatchProgress = WatchProgress.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatus {
    return {
      payCheck: isSet(object.payCheck) ? globalThis.Boolean(object.payCheck) : false,
      sponsor: isSet(object.sponsor) ? globalThis.Boolean(object.sponsor) : false,
      watchProgress: isSet(object.watchProgress) ? WatchProgress.fromJSON(object.watchProgress) : undefined,
      aidWatchProgress: isSet(object.aidWatchProgress) ? WatchProgress.fromJSON(object.aidWatchProgress) : undefined,
    };
  },

  toJSON(message: UserStatus): unknown {
    const obj: any = {};
    if (message.payCheck !== false) {
      obj.payCheck = message.payCheck;
    }
    if (message.sponsor !== false) {
      obj.sponsor = message.sponsor;
    }
    if (message.watchProgress !== undefined) {
      obj.watchProgress = WatchProgress.toJSON(message.watchProgress);
    }
    if (message.aidWatchProgress !== undefined) {
      obj.aidWatchProgress = WatchProgress.toJSON(message.aidWatchProgress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatus>, I>>(base?: I): UserStatus {
    return UserStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatus>, I>>(object: I): UserStatus {
    const message = createBaseUserStatus();
    message.payCheck = object.payCheck ?? false;
    message.sponsor = object.sponsor ?? false;
    message.watchProgress = (object.watchProgress !== undefined && object.watchProgress !== null)
      ? WatchProgress.fromPartial(object.watchProgress)
      : undefined;
    message.aidWatchProgress = (object.aidWatchProgress !== undefined && object.aidWatchProgress !== null)
      ? WatchProgress.fromPartial(object.aidWatchProgress)
      : undefined;
    return message;
  },
};

function createBaseWatchProgress(): WatchProgress {
  return {
    lastEpId: 0,
    lastEpIndex: "",
    progress: 0n,
    lastPlayCid: 0n,
    toast: undefined,
    toastWithoutTime: undefined,
    lastPlayAid: 0n,
  };
}

export const WatchProgress: MessageFns<WatchProgress> = {
  encode(message: WatchProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastEpId !== 0) {
      writer.uint32(8).int32(message.lastEpId);
    }
    if (message.lastEpIndex !== "") {
      writer.uint32(18).string(message.lastEpIndex);
    }
    if (message.progress !== 0n) {
      if (BigInt.asIntN(64, message.progress) !== message.progress) {
        throw new globalThis.Error("value provided for field message.progress of type int64 too large");
      }
      writer.uint32(24).int64(message.progress);
    }
    if (message.lastPlayCid !== 0n) {
      if (BigInt.asIntN(64, message.lastPlayCid) !== message.lastPlayCid) {
        throw new globalThis.Error("value provided for field message.lastPlayCid of type int64 too large");
      }
      writer.uint32(32).int64(message.lastPlayCid);
    }
    if (message.toast !== undefined) {
      Toast.encode(message.toast, writer.uint32(42).fork()).join();
    }
    if (message.toastWithoutTime !== undefined) {
      Toast.encode(message.toastWithoutTime, writer.uint32(50).fork()).join();
    }
    if (message.lastPlayAid !== 0n) {
      if (BigInt.asIntN(64, message.lastPlayAid) !== message.lastPlayAid) {
        throw new globalThis.Error("value provided for field message.lastPlayAid of type int64 too large");
      }
      writer.uint32(56).int64(message.lastPlayAid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WatchProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastEpId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastEpIndex = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.progress = reader.int64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastPlayCid = reader.int64() as bigint;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toast = Toast.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.toastWithoutTime = Toast.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.lastPlayAid = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchProgress {
    return {
      lastEpId: isSet(object.lastEpId) ? globalThis.Number(object.lastEpId) : 0,
      lastEpIndex: isSet(object.lastEpIndex) ? globalThis.String(object.lastEpIndex) : "",
      progress: isSet(object.progress) ? BigInt(object.progress) : 0n,
      lastPlayCid: isSet(object.lastPlayCid) ? BigInt(object.lastPlayCid) : 0n,
      toast: isSet(object.toast) ? Toast.fromJSON(object.toast) : undefined,
      toastWithoutTime: isSet(object.toastWithoutTime) ? Toast.fromJSON(object.toastWithoutTime) : undefined,
      lastPlayAid: isSet(object.lastPlayAid) ? BigInt(object.lastPlayAid) : 0n,
    };
  },

  toJSON(message: WatchProgress): unknown {
    const obj: any = {};
    if (message.lastEpId !== 0) {
      obj.lastEpId = Math.round(message.lastEpId);
    }
    if (message.lastEpIndex !== "") {
      obj.lastEpIndex = message.lastEpIndex;
    }
    if (message.progress !== 0n) {
      obj.progress = message.progress.toString();
    }
    if (message.lastPlayCid !== 0n) {
      obj.lastPlayCid = message.lastPlayCid.toString();
    }
    if (message.toast !== undefined) {
      obj.toast = Toast.toJSON(message.toast);
    }
    if (message.toastWithoutTime !== undefined) {
      obj.toastWithoutTime = Toast.toJSON(message.toastWithoutTime);
    }
    if (message.lastPlayAid !== 0n) {
      obj.lastPlayAid = message.lastPlayAid.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchProgress>, I>>(base?: I): WatchProgress {
    return WatchProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchProgress>, I>>(object: I): WatchProgress {
    const message = createBaseWatchProgress();
    message.lastEpId = object.lastEpId ?? 0;
    message.lastEpIndex = object.lastEpIndex ?? "";
    message.progress = object.progress ?? 0n;
    message.lastPlayCid = object.lastPlayCid ?? 0n;
    message.toast = (object.toast !== undefined && object.toast !== null) ? Toast.fromPartial(object.toast) : undefined;
    message.toastWithoutTime = (object.toastWithoutTime !== undefined && object.toastWithoutTime !== null)
      ? Toast.fromPartial(object.toastWithoutTime)
      : undefined;
    message.lastPlayAid = object.lastPlayAid ?? 0n;
    return message;
  },
};

function createBaseToast(): Toast {
  return {
    text: "",
    button: undefined,
    showStyleType: 0,
    icon: "",
    toastText: undefined,
    report: undefined,
    orderReportParams: {},
  };
}

export const Toast: MessageFns<Toast> = {
  encode(message: Toast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.button !== undefined) {
      ButtonInfo.encode(message.button, writer.uint32(18).fork()).join();
    }
    if (message.showStyleType !== 0) {
      writer.uint32(24).int32(message.showStyleType);
    }
    if (message.icon !== "") {
      writer.uint32(34).string(message.icon);
    }
    if (message.toastText !== undefined) {
      TextInfo.encode(message.toastText, writer.uint32(42).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(50).fork()).join();
    }
    Object.entries(message.orderReportParams).forEach(([key, value]) => {
      Toast_OrderReportParamsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Toast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.button = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.showStyleType = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toastText = TextInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Toast_OrderReportParamsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.orderReportParams[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Toast {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      button: isSet(object.button) ? ButtonInfo.fromJSON(object.button) : undefined,
      showStyleType: isSet(object.showStyleType) ? globalThis.Number(object.showStyleType) : 0,
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      toastText: isSet(object.toastText) ? TextInfo.fromJSON(object.toastText) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      orderReportParams: isObject(object.orderReportParams)
        ? Object.entries(object.orderReportParams).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Toast): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.button !== undefined) {
      obj.button = ButtonInfo.toJSON(message.button);
    }
    if (message.showStyleType !== 0) {
      obj.showStyleType = Math.round(message.showStyleType);
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.toastText !== undefined) {
      obj.toastText = TextInfo.toJSON(message.toastText);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.orderReportParams) {
      const entries = Object.entries(message.orderReportParams);
      if (entries.length > 0) {
        obj.orderReportParams = {};
        entries.forEach(([k, v]) => {
          obj.orderReportParams[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Toast>, I>>(base?: I): Toast {
    return Toast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Toast>, I>>(object: I): Toast {
    const message = createBaseToast();
    message.text = object.text ?? "";
    message.button = (object.button !== undefined && object.button !== null)
      ? ButtonInfo.fromPartial(object.button)
      : undefined;
    message.showStyleType = object.showStyleType ?? 0;
    message.icon = object.icon ?? "";
    message.toastText = (object.toastText !== undefined && object.toastText !== null)
      ? TextInfo.fromPartial(object.toastText)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.orderReportParams = Object.entries(object.orderReportParams ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseToast_OrderReportParamsEntry(): Toast_OrderReportParamsEntry {
  return { key: "", value: "" };
}

export const Toast_OrderReportParamsEntry: MessageFns<Toast_OrderReportParamsEntry> = {
  encode(message: Toast_OrderReportParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Toast_OrderReportParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToast_OrderReportParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Toast_OrderReportParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Toast_OrderReportParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Toast_OrderReportParamsEntry>, I>>(base?: I): Toast_OrderReportParamsEntry {
    return Toast_OrderReportParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Toast_OrderReportParamsEntry>, I>>(object: I): Toast_OrderReportParamsEntry {
    const message = createBaseToast_OrderReportParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseButtonInfo(): ButtonInfo {
  return {
    text: "",
    textColor: "",
    textColorNight: "",
    bgColor: "",
    bgColorNight: "",
    link: "",
    actionType: "",
    badgeInfo: undefined,
    report: undefined,
    leftStrikethroughText: "",
    simpleTextInfo: undefined,
    simpleBgColor: "",
    simpleBgColorNight: "",
    bgGradientColor: undefined,
    orderReportParams: {},
    taskParam: undefined,
    pcLink: "",
  };
}

export const ButtonInfo: MessageFns<ButtonInfo> = {
  encode(message: ButtonInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(18).string(message.textColor);
    }
    if (message.textColorNight !== "") {
      writer.uint32(26).string(message.textColorNight);
    }
    if (message.bgColor !== "") {
      writer.uint32(34).string(message.bgColor);
    }
    if (message.bgColorNight !== "") {
      writer.uint32(42).string(message.bgColorNight);
    }
    if (message.link !== "") {
      writer.uint32(50).string(message.link);
    }
    if (message.actionType !== "") {
      writer.uint32(58).string(message.actionType);
    }
    if (message.badgeInfo !== undefined) {
      BadgeInfo.encode(message.badgeInfo, writer.uint32(66).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(74).fork()).join();
    }
    if (message.leftStrikethroughText !== "") {
      writer.uint32(82).string(message.leftStrikethroughText);
    }
    if (message.simpleTextInfo !== undefined) {
      TextInfo.encode(message.simpleTextInfo, writer.uint32(90).fork()).join();
    }
    if (message.simpleBgColor !== "") {
      writer.uint32(98).string(message.simpleBgColor);
    }
    if (message.simpleBgColorNight !== "") {
      writer.uint32(106).string(message.simpleBgColorNight);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(114).fork()).join();
    }
    Object.entries(message.orderReportParams).forEach(([key, value]) => {
      ButtonInfo_OrderReportParamsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.taskParam !== undefined) {
      TaskParam.encode(message.taskParam, writer.uint32(130).fork()).join();
    }
    if (message.pcLink !== "") {
      writer.uint32(138).string(message.pcLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ButtonInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textColorNight = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bgColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgColorNight = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.link = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.actionType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.badgeInfo = BadgeInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.leftStrikethroughText = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.simpleTextInfo = TextInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.simpleBgColor = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.simpleBgColorNight = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = ButtonInfo_OrderReportParamsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.orderReportParams[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.taskParam = TaskParam.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.pcLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      textColorNight: isSet(object.textColorNight) ? globalThis.String(object.textColorNight) : "",
      bgColor: isSet(object.bgColor) ? globalThis.String(object.bgColor) : "",
      bgColorNight: isSet(object.bgColorNight) ? globalThis.String(object.bgColorNight) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      actionType: isSet(object.actionType) ? globalThis.String(object.actionType) : "",
      badgeInfo: isSet(object.badgeInfo) ? BadgeInfo.fromJSON(object.badgeInfo) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      leftStrikethroughText: isSet(object.leftStrikethroughText) ? globalThis.String(object.leftStrikethroughText) : "",
      simpleTextInfo: isSet(object.simpleTextInfo) ? TextInfo.fromJSON(object.simpleTextInfo) : undefined,
      simpleBgColor: isSet(object.simpleBgColor) ? globalThis.String(object.simpleBgColor) : "",
      simpleBgColorNight: isSet(object.simpleBgColorNight) ? globalThis.String(object.simpleBgColorNight) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      orderReportParams: isObject(object.orderReportParams)
        ? Object.entries(object.orderReportParams).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      taskParam: isSet(object.taskParam) ? TaskParam.fromJSON(object.taskParam) : undefined,
      pcLink: isSet(object.pcLink) ? globalThis.String(object.pcLink) : "",
    };
  },

  toJSON(message: ButtonInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textColorNight !== "") {
      obj.textColorNight = message.textColorNight;
    }
    if (message.bgColor !== "") {
      obj.bgColor = message.bgColor;
    }
    if (message.bgColorNight !== "") {
      obj.bgColorNight = message.bgColorNight;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.actionType !== "") {
      obj.actionType = message.actionType;
    }
    if (message.badgeInfo !== undefined) {
      obj.badgeInfo = BadgeInfo.toJSON(message.badgeInfo);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.leftStrikethroughText !== "") {
      obj.leftStrikethroughText = message.leftStrikethroughText;
    }
    if (message.simpleTextInfo !== undefined) {
      obj.simpleTextInfo = TextInfo.toJSON(message.simpleTextInfo);
    }
    if (message.simpleBgColor !== "") {
      obj.simpleBgColor = message.simpleBgColor;
    }
    if (message.simpleBgColorNight !== "") {
      obj.simpleBgColorNight = message.simpleBgColorNight;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.orderReportParams) {
      const entries = Object.entries(message.orderReportParams);
      if (entries.length > 0) {
        obj.orderReportParams = {};
        entries.forEach(([k, v]) => {
          obj.orderReportParams[k] = v;
        });
      }
    }
    if (message.taskParam !== undefined) {
      obj.taskParam = TaskParam.toJSON(message.taskParam);
    }
    if (message.pcLink !== "") {
      obj.pcLink = message.pcLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonInfo>, I>>(base?: I): ButtonInfo {
    return ButtonInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonInfo>, I>>(object: I): ButtonInfo {
    const message = createBaseButtonInfo();
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textColorNight = object.textColorNight ?? "";
    message.bgColor = object.bgColor ?? "";
    message.bgColorNight = object.bgColorNight ?? "";
    message.link = object.link ?? "";
    message.actionType = object.actionType ?? "";
    message.badgeInfo = (object.badgeInfo !== undefined && object.badgeInfo !== null)
      ? BadgeInfo.fromPartial(object.badgeInfo)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.leftStrikethroughText = object.leftStrikethroughText ?? "";
    message.simpleTextInfo = (object.simpleTextInfo !== undefined && object.simpleTextInfo !== null)
      ? TextInfo.fromPartial(object.simpleTextInfo)
      : undefined;
    message.simpleBgColor = object.simpleBgColor ?? "";
    message.simpleBgColorNight = object.simpleBgColorNight ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.orderReportParams = Object.entries(object.orderReportParams ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.taskParam = (object.taskParam !== undefined && object.taskParam !== null)
      ? TaskParam.fromPartial(object.taskParam)
      : undefined;
    message.pcLink = object.pcLink ?? "";
    return message;
  },
};

function createBaseButtonInfo_OrderReportParamsEntry(): ButtonInfo_OrderReportParamsEntry {
  return { key: "", value: "" };
}

export const ButtonInfo_OrderReportParamsEntry: MessageFns<ButtonInfo_OrderReportParamsEntry> = {
  encode(message: ButtonInfo_OrderReportParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ButtonInfo_OrderReportParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonInfo_OrderReportParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonInfo_OrderReportParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ButtonInfo_OrderReportParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonInfo_OrderReportParamsEntry>, I>>(
    base?: I,
  ): ButtonInfo_OrderReportParamsEntry {
    return ButtonInfo_OrderReportParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonInfo_OrderReportParamsEntry>, I>>(
    object: I,
  ): ButtonInfo_OrderReportParamsEntry {
    const message = createBaseButtonInfo_OrderReportParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBadgeInfo(): BadgeInfo {
  return { text: "", bgColor: "", bgColorNight: "", textColor: "", bgGradientColor: undefined, img: "" };
}

export const BadgeInfo: MessageFns<BadgeInfo> = {
  encode(message: BadgeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.bgColor !== "") {
      writer.uint32(18).string(message.bgColor);
    }
    if (message.bgColorNight !== "") {
      writer.uint32(26).string(message.bgColorNight);
    }
    if (message.textColor !== "") {
      writer.uint32(34).string(message.textColor);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(42).fork()).join();
    }
    if (message.img !== "") {
      writer.uint32(50).string(message.img);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bgColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bgColorNight = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.img = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BadgeInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      bgColor: isSet(object.bgColor) ? globalThis.String(object.bgColor) : "",
      bgColorNight: isSet(object.bgColorNight) ? globalThis.String(object.bgColorNight) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      img: isSet(object.img) ? globalThis.String(object.img) : "",
    };
  },

  toJSON(message: BadgeInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.bgColor !== "") {
      obj.bgColor = message.bgColor;
    }
    if (message.bgColorNight !== "") {
      obj.bgColorNight = message.bgColorNight;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.img !== "") {
      obj.img = message.img;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadgeInfo>, I>>(base?: I): BadgeInfo {
    return BadgeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeInfo>, I>>(object: I): BadgeInfo {
    const message = createBaseBadgeInfo();
    message.text = object.text ?? "";
    message.bgColor = object.bgColor ?? "";
    message.bgColorNight = object.bgColorNight ?? "";
    message.textColor = object.textColor ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.img = object.img ?? "";
    return message;
  },
};

function createBaseGradientColor(): GradientColor {
  return { startColor: "", endColor: "" };
}

export const GradientColor: MessageFns<GradientColor> = {
  encode(message: GradientColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startColor !== "") {
      writer.uint32(10).string(message.startColor);
    }
    if (message.endColor !== "") {
      writer.uint32(18).string(message.endColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GradientColor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGradientColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startColor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GradientColor {
    return {
      startColor: isSet(object.startColor) ? globalThis.String(object.startColor) : "",
      endColor: isSet(object.endColor) ? globalThis.String(object.endColor) : "",
    };
  },

  toJSON(message: GradientColor): unknown {
    const obj: any = {};
    if (message.startColor !== "") {
      obj.startColor = message.startColor;
    }
    if (message.endColor !== "") {
      obj.endColor = message.endColor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GradientColor>, I>>(base?: I): GradientColor {
    return GradientColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GradientColor>, I>>(object: I): GradientColor {
    const message = createBaseGradientColor();
    message.startColor = object.startColor ?? "";
    message.endColor = object.endColor ?? "";
    return message;
  },
};

function createBaseReport(): Report {
  return { showEventId: "", clickEventId: "", extends: "" };
}

export const Report: MessageFns<Report> = {
  encode(message: Report, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.showEventId !== "") {
      writer.uint32(10).string(message.showEventId);
    }
    if (message.clickEventId !== "") {
      writer.uint32(18).string(message.clickEventId);
    }
    if (message.extends !== "") {
      writer.uint32(26).string(message.extends);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.showEventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clickEventId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extends = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report {
    return {
      showEventId: isSet(object.showEventId) ? globalThis.String(object.showEventId) : "",
      clickEventId: isSet(object.clickEventId) ? globalThis.String(object.clickEventId) : "",
      extends: isSet(object.extends) ? globalThis.String(object.extends) : "",
    };
  },

  toJSON(message: Report): unknown {
    const obj: any = {};
    if (message.showEventId !== "") {
      obj.showEventId = message.showEventId;
    }
    if (message.clickEventId !== "") {
      obj.clickEventId = message.clickEventId;
    }
    if (message.extends !== "") {
      obj.extends = message.extends;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Report>, I>>(base?: I): Report {
    return Report.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Report>, I>>(object: I): Report {
    const message = createBaseReport();
    message.showEventId = object.showEventId ?? "";
    message.clickEventId = object.clickEventId ?? "";
    message.extends = object.extends ?? "";
    return message;
  },
};

function createBaseTextInfo(): TextInfo {
  return { text: "", textColor: "", textColorNight: "" };
}

export const TextInfo: MessageFns<TextInfo> = {
  encode(message: TextInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(18).string(message.textColor);
    }
    if (message.textColorNight !== "") {
      writer.uint32(26).string(message.textColorNight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textColorNight = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      textColorNight: isSet(object.textColorNight) ? globalThis.String(object.textColorNight) : "",
    };
  },

  toJSON(message: TextInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textColorNight !== "") {
      obj.textColorNight = message.textColorNight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInfo>, I>>(base?: I): TextInfo {
    return TextInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInfo>, I>>(object: I): TextInfo {
    const message = createBaseTextInfo();
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textColorNight = object.textColorNight ?? "";
    return message;
  },
};

function createBaseTaskParam(): TaskParam {
  return { taskType: "", activityId: 0n, tipsId: 0n };
}

export const TaskParam: MessageFns<TaskParam> = {
  encode(message: TaskParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskType !== "") {
      writer.uint32(10).string(message.taskType);
    }
    if (message.activityId !== 0n) {
      if (BigInt.asIntN(64, message.activityId) !== message.activityId) {
        throw new globalThis.Error("value provided for field message.activityId of type int64 too large");
      }
      writer.uint32(16).int64(message.activityId);
    }
    if (message.tipsId !== 0n) {
      if (BigInt.asIntN(64, message.tipsId) !== message.tipsId) {
        throw new globalThis.Error("value provided for field message.tipsId of type int64 too large");
      }
      writer.uint32(24).int64(message.tipsId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.activityId = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tipsId = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskParam {
    return {
      taskType: isSet(object.taskType) ? globalThis.String(object.taskType) : "",
      activityId: isSet(object.activityId) ? BigInt(object.activityId) : 0n,
      tipsId: isSet(object.tipsId) ? BigInt(object.tipsId) : 0n,
    };
  },

  toJSON(message: TaskParam): unknown {
    const obj: any = {};
    if (message.taskType !== "") {
      obj.taskType = message.taskType;
    }
    if (message.activityId !== 0n) {
      obj.activityId = message.activityId.toString();
    }
    if (message.tipsId !== 0n) {
      obj.tipsId = message.tipsId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskParam>, I>>(base?: I): TaskParam {
    return TaskParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskParam>, I>>(object: I): TaskParam {
    const message = createBaseTaskParam();
    message.taskType = object.taskType ?? "";
    message.activityId = object.activityId ?? 0n;
    message.tipsId = object.tipsId ?? 0n;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
