// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/pgc/gateway/player/v2/ViewInfo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BadgeInfo, ButtonInfo, GradientColor, Report, TextInfo, Toast } from "./PlayViewBusinessInfo";

export const protobufPackage = "bilibili.pgc.gateway.player.v2";

/** 展示信息 */
export interface ViewInfo {
  /** 弹窗 */
  dialog:
    | Dialog
    | undefined;
  /** Toast */
  toast:
    | Toast
    | undefined;
  /** 优惠券信息 */
  couponInfo:
    | CouponInfo
    | undefined;
  /** 未支付剧集ID列表 */
  demandNoPayEpids: bigint[];
  /** 结束页 */
  endPage:
    | EndPage
    | undefined;
  /** 扩展配置 */
  expConfig: { [key: string]: boolean };
  /** 弹窗 */
  popWin:
    | PopWin
    | undefined;
  /** 试看提示栏 */
  tryWatchPromptBar:
    | PromptBar
    | undefined;
  /** 支付提示信息 */
  payTip:
    | PayTip
    | undefined;
  /** 高清试看提示信息 */
  highDefinitionTrialInfo:
    | HighDefinitionTrialInfo
    | undefined;
  /** 弹窗扩展 */
  extDialog: { [key: string]: Dialog };
  /** 动画 */
  animation:
    | Animation
    | undefined;
  /** Toast扩展 */
  extToast: { [key: string]: Toast };
}

export interface ViewInfo_ExpConfigEntry {
  key: string;
  value: boolean;
}

export interface ViewInfo_ExtDialogEntry {
  key: string;
  value: Dialog | undefined;
}

export interface ViewInfo_ExtToastEntry {
  key: string;
  value: Toast | undefined;
}

/** 鉴权浮层 */
export interface Dialog {
  /** 鉴权限制码 */
  code: bigint;
  /** 鉴权限制信息 */
  msg: string;
  /** 浮层类型 */
  type: string;
  /** 浮层样式类型 */
  styleType: string;
  /** 浮层配置 */
  config:
    | DialogConfig
    | undefined;
  /** 标题 */
  title:
    | TextInfo
    | undefined;
  /** 副标题 */
  subtitle:
    | TextInfo
    | undefined;
  /** 图片信息 */
  image:
    | ImageInfo
    | undefined;
  /** 按钮列表 */
  button: ButtonInfo[];
  /** 底部描述 */
  bottomDesc:
    | ButtonInfo
    | undefined;
  /** 埋点上报信息 */
  report:
    | Report
    | undefined;
  /** 倒计时 秒 */
  countDownSec: number;
  /** 右下描述 */
  rightBottomDesc: TextInfo | undefined;
  bottomDisplay: BottomDisplay[];
  playList: PlayList[];
}

/** 鉴权浮层配置 */
export interface DialogConfig {
  /** 是否显示高斯模糊背景图 */
  isShowCover: boolean;
  /** 是否响应转屏 */
  isOrientationEnable: boolean;
  /** 是否响应上滑吸顶 */
  isNestedScrollEnable: boolean;
  /** 是否强制竖屏 */
  isForceHalfscreenEnable: boolean;
  /** 是否启用背景半透明 */
  isBackgroundTranslucentEnable: boolean;
}

/** 图片信息 */
export interface ImageInfo {
  /** 图片链接 */
  url: string;
}

/** Dialog组件: 底部显示 */
export interface BottomDisplay {
  /** 文案 */
  title:
    | TextInfo
    | undefined;
  /** 图标 */
  icon: string;
}

export interface PlayList {
  seasonId: number;
  title: string;
  cover: string;
  link: string;
  badgeInfo: BadgeInfo | undefined;
}

/** 优惠券信息 */
export interface CouponInfo {
  /** 提示框信息 */
  toast:
    | CouponToast
    | undefined;
  /** 弹窗信息 */
  popWin: PopWin | undefined;
}

/** 优惠券提示框信息 */
export interface CouponToast {
  /** 提示框文案信息 */
  textInfo:
    | CouponTextInfo
    | undefined;
  /** 提示框按钮 */
  button: ButtonInfo | undefined;
}

/** 优惠券提示框文案信息 */
export interface CouponTextInfo {
  /** 提示框文案-播正片6分钟预览 */
  positivePreview: string;
  /** 提示框文案-播非正片分节ep */
  section: string;
}

/** 弹窗信息 */
export interface PopWin {
  /** 弹窗标题 老字段 */
  title: string;
  /** 优惠券列表 */
  coupon: Coupon[];
  /** 弹窗按钮列表 */
  button: ButtonInfo[];
  /** 底部文案 老字段 */
  bottomText: string;
  /** 弹窗标题 新字段 */
  popTitle:
    | TextInfo
    | undefined;
  /** 弹窗副标题 */
  subtitle:
    | TextInfo
    | undefined;
  /** 底部描述 新字段 */
  bottomDesc:
    | ButtonInfo
    | undefined;
  /** 弹窗小图 */
  cover: string;
  /** 弹窗类型 */
  popType: string;
}

/** 优惠券 */
export interface Coupon {
  /** 优惠券token */
  couponToken: string;
  /**
   * 优惠券类型
   * | 1 | 2 | 3 |
   * | :-: | :-: | :-: |
   * | 折扣券 | 满减券 | 兑换券 |
   */
  type: bigint;
  /** 优惠券面值 */
  value: string;
  /** 优惠券使用描述 */
  useDesc: string;
  /** 优惠券标题 */
  title: string;
  /** 优惠券描述 */
  desc: string;
  /** 优惠券支付按钮文案 */
  payButtonText: string;
  /** 优惠券支付按钮删除线文案 */
  payButtonTextLineThrough: string;
  /** 实付金额 */
  realAmount: string;
  /** 使用过期时间 */
  expireTime: Timestamp | undefined;
  otype: bigint;
  amount: string;
}

/** 广告组件: 竖屏时视频下部提示栏 */
export interface PromptBar {
  /** 主标题, 如: "本片含大会员专享内容" */
  title:
    | TextInfo
    | undefined;
  /** 副标题, 如: "成为大会员可免费看全部剧集" */
  subTitle:
    | TextInfo
    | undefined;
  /** 副标题前面的icon */
  subTitleIcon: string;
  /** 背景图 */
  bgImage: string;
  /** 背景渐变色 */
  bgGradientColor:
    | GradientColor
    | undefined;
  /** 按钮 */
  button: ButtonInfo[];
  /** 埋点上报信息 */
  report: Report | undefined;
  fullScreenIpIcon: string;
  fullScreenBgGradientColor: GradientColor | undefined;
}

/** 大会员广告: 支付提示信息 */
export interface PayTip {
  /** 标题 */
  title: string;
  /** 跳转链接 */
  url: string;
  /** 图标 */
  icon: string;
  /** 浮层类型 */
  type: number;
  /** 显示类型 */
  showType: number;
  /** 图片信息 */
  img: string;
  /** 白天背景颜色 */
  bgDayColor: string;
  /** 夜间背景颜色 */
  bgNightColor: string;
  /** 白天线条颜色 */
  bgLineColor: string;
  /** 夜间线条颜色 */
  bgNightLineColor: string;
  /** 文字颜色 */
  textColor: string;
  /** 夜间文字颜色 */
  textNightColor: string;
  /** 视图展示起始时间 */
  viewStartTime: bigint;
  /** 按钮列表 */
  button: ButtonInfo[];
  /** 跳转链接打开方式 */
  urlOpenType: number;
  /** 埋点上报信息 */
  report:
    | Report
    | undefined;
  /** 角度样式 */
  angleStyle: number;
  /** 埋点上报类型 */
  reportType: number;
  /** 订单埋点上报参数 */
  orderReportParams: { [key: string]: string };
  /** 巨屏图片信息 */
  giantScreenImg: string;
}

export interface PayTip_OrderReportParamsEntry {
  key: string;
  value: string;
}

/** 高画质试看信息 */
export interface HighDefinitionTrialInfo {
  trialAble: boolean;
  remainingTimes: number;
  start: number;
  timeLength: number;
  startToast: Toast | undefined;
  endToast: Toast | undefined;
  report: Report | undefined;
  qualityOpenTipBtn: ButtonInfo | undefined;
  noLongerTrialBtn: ButtonInfo | undefined;
}

export interface Animation {
  qnSvgaAnimationMap: { [key: string]: string };
}

export interface Animation_QnSvgaAnimationMapEntry {
  key: string;
  value: string;
}

/** 播放结束后的尾页Dialog */
export interface EndPage {
  dialog: Dialog | undefined;
  hide: boolean;
}

export interface Timestamp {
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds: bigint;
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive.
   */
  nanos: number;
}

function createBaseViewInfo(): ViewInfo {
  return {
    dialog: undefined,
    toast: undefined,
    couponInfo: undefined,
    demandNoPayEpids: [],
    endPage: undefined,
    expConfig: {},
    popWin: undefined,
    tryWatchPromptBar: undefined,
    payTip: undefined,
    highDefinitionTrialInfo: undefined,
    extDialog: {},
    animation: undefined,
    extToast: {},
  };
}

export const ViewInfo: MessageFns<ViewInfo> = {
  encode(message: ViewInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialog !== undefined) {
      Dialog.encode(message.dialog, writer.uint32(10).fork()).join();
    }
    if (message.toast !== undefined) {
      Toast.encode(message.toast, writer.uint32(18).fork()).join();
    }
    if (message.couponInfo !== undefined) {
      CouponInfo.encode(message.couponInfo, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.demandNoPayEpids) {
      if (BigInt.asIntN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field demandNoPayEpids of type int64 is too large");
      }
      writer.int64(v);
    }
    writer.join();
    if (message.endPage !== undefined) {
      EndPage.encode(message.endPage, writer.uint32(42).fork()).join();
    }
    Object.entries(message.expConfig).forEach(([key, value]) => {
      ViewInfo_ExpConfigEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.popWin !== undefined) {
      PopWin.encode(message.popWin, writer.uint32(58).fork()).join();
    }
    if (message.tryWatchPromptBar !== undefined) {
      PromptBar.encode(message.tryWatchPromptBar, writer.uint32(66).fork()).join();
    }
    if (message.payTip !== undefined) {
      PayTip.encode(message.payTip, writer.uint32(74).fork()).join();
    }
    if (message.highDefinitionTrialInfo !== undefined) {
      HighDefinitionTrialInfo.encode(message.highDefinitionTrialInfo, writer.uint32(82).fork()).join();
    }
    Object.entries(message.extDialog).forEach(([key, value]) => {
      ViewInfo_ExtDialogEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.animation !== undefined) {
      Animation.encode(message.animation, writer.uint32(98).fork()).join();
    }
    Object.entries(message.extToast).forEach(([key, value]) => {
      ViewInfo_ExtToastEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialog = Dialog.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toast = Toast.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.couponInfo = CouponInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag === 32) {
            message.demandNoPayEpids.push(reader.int64() as bigint);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.demandNoPayEpids.push(reader.int64() as bigint);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endPage = EndPage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ViewInfo_ExpConfigEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.expConfig[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.popWin = PopWin.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tryWatchPromptBar = PromptBar.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.payTip = PayTip.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.highDefinitionTrialInfo = HighDefinitionTrialInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = ViewInfo_ExtDialogEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.extDialog[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.animation = Animation.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = ViewInfo_ExtToastEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.extToast[entry13.key] = entry13.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo {
    return {
      dialog: isSet(object.dialog) ? Dialog.fromJSON(object.dialog) : undefined,
      toast: isSet(object.toast) ? Toast.fromJSON(object.toast) : undefined,
      couponInfo: isSet(object.couponInfo) ? CouponInfo.fromJSON(object.couponInfo) : undefined,
      demandNoPayEpids: globalThis.Array.isArray(object?.demandNoPayEpids)
        ? object.demandNoPayEpids.map((e: any) => BigInt(e))
        : [],
      endPage: isSet(object.endPage) ? EndPage.fromJSON(object.endPage) : undefined,
      expConfig: isObject(object.expConfig)
        ? Object.entries(object.expConfig).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
          acc[key] = Boolean(value);
          return acc;
        }, {})
        : {},
      popWin: isSet(object.popWin) ? PopWin.fromJSON(object.popWin) : undefined,
      tryWatchPromptBar: isSet(object.tryWatchPromptBar) ? PromptBar.fromJSON(object.tryWatchPromptBar) : undefined,
      payTip: isSet(object.payTip) ? PayTip.fromJSON(object.payTip) : undefined,
      highDefinitionTrialInfo: isSet(object.highDefinitionTrialInfo)
        ? HighDefinitionTrialInfo.fromJSON(object.highDefinitionTrialInfo)
        : undefined,
      extDialog: isObject(object.extDialog)
        ? Object.entries(object.extDialog).reduce<{ [key: string]: Dialog }>((acc, [key, value]) => {
          acc[key] = Dialog.fromJSON(value);
          return acc;
        }, {})
        : {},
      animation: isSet(object.animation) ? Animation.fromJSON(object.animation) : undefined,
      extToast: isObject(object.extToast)
        ? Object.entries(object.extToast).reduce<{ [key: string]: Toast }>((acc, [key, value]) => {
          acc[key] = Toast.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ViewInfo): unknown {
    const obj: any = {};
    if (message.dialog !== undefined) {
      obj.dialog = Dialog.toJSON(message.dialog);
    }
    if (message.toast !== undefined) {
      obj.toast = Toast.toJSON(message.toast);
    }
    if (message.couponInfo !== undefined) {
      obj.couponInfo = CouponInfo.toJSON(message.couponInfo);
    }
    if (message.demandNoPayEpids?.length) {
      obj.demandNoPayEpids = message.demandNoPayEpids.map((e) => e.toString());
    }
    if (message.endPage !== undefined) {
      obj.endPage = EndPage.toJSON(message.endPage);
    }
    if (message.expConfig) {
      const entries = Object.entries(message.expConfig);
      if (entries.length > 0) {
        obj.expConfig = {};
        entries.forEach(([k, v]) => {
          obj.expConfig[k] = v;
        });
      }
    }
    if (message.popWin !== undefined) {
      obj.popWin = PopWin.toJSON(message.popWin);
    }
    if (message.tryWatchPromptBar !== undefined) {
      obj.tryWatchPromptBar = PromptBar.toJSON(message.tryWatchPromptBar);
    }
    if (message.payTip !== undefined) {
      obj.payTip = PayTip.toJSON(message.payTip);
    }
    if (message.highDefinitionTrialInfo !== undefined) {
      obj.highDefinitionTrialInfo = HighDefinitionTrialInfo.toJSON(message.highDefinitionTrialInfo);
    }
    if (message.extDialog) {
      const entries = Object.entries(message.extDialog);
      if (entries.length > 0) {
        obj.extDialog = {};
        entries.forEach(([k, v]) => {
          obj.extDialog[k] = Dialog.toJSON(v);
        });
      }
    }
    if (message.animation !== undefined) {
      obj.animation = Animation.toJSON(message.animation);
    }
    if (message.extToast) {
      const entries = Object.entries(message.extToast);
      if (entries.length > 0) {
        obj.extToast = {};
        entries.forEach(([k, v]) => {
          obj.extToast[k] = Toast.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo>, I>>(base?: I): ViewInfo {
    return ViewInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo>, I>>(object: I): ViewInfo {
    const message = createBaseViewInfo();
    message.dialog = (object.dialog !== undefined && object.dialog !== null)
      ? Dialog.fromPartial(object.dialog)
      : undefined;
    message.toast = (object.toast !== undefined && object.toast !== null) ? Toast.fromPartial(object.toast) : undefined;
    message.couponInfo = (object.couponInfo !== undefined && object.couponInfo !== null)
      ? CouponInfo.fromPartial(object.couponInfo)
      : undefined;
    message.demandNoPayEpids = object.demandNoPayEpids?.map((e) => e) || [];
    message.endPage = (object.endPage !== undefined && object.endPage !== null)
      ? EndPage.fromPartial(object.endPage)
      : undefined;
    message.expConfig = Object.entries(object.expConfig ?? {}).reduce<{ [key: string]: boolean }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Boolean(value);
        }
        return acc;
      },
      {},
    );
    message.popWin = (object.popWin !== undefined && object.popWin !== null)
      ? PopWin.fromPartial(object.popWin)
      : undefined;
    message.tryWatchPromptBar = (object.tryWatchPromptBar !== undefined && object.tryWatchPromptBar !== null)
      ? PromptBar.fromPartial(object.tryWatchPromptBar)
      : undefined;
    message.payTip = (object.payTip !== undefined && object.payTip !== null)
      ? PayTip.fromPartial(object.payTip)
      : undefined;
    message.highDefinitionTrialInfo =
      (object.highDefinitionTrialInfo !== undefined && object.highDefinitionTrialInfo !== null)
        ? HighDefinitionTrialInfo.fromPartial(object.highDefinitionTrialInfo)
        : undefined;
    message.extDialog = Object.entries(object.extDialog ?? {}).reduce<{ [key: string]: Dialog }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Dialog.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.animation = (object.animation !== undefined && object.animation !== null)
      ? Animation.fromPartial(object.animation)
      : undefined;
    message.extToast = Object.entries(object.extToast ?? {}).reduce<{ [key: string]: Toast }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Toast.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseViewInfo_ExpConfigEntry(): ViewInfo_ExpConfigEntry {
  return { key: "", value: false };
}

export const ViewInfo_ExpConfigEntry: MessageFns<ViewInfo_ExpConfigEntry> = {
  encode(message: ViewInfo_ExpConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo_ExpConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo_ExpConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo_ExpConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: ViewInfo_ExpConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo_ExpConfigEntry>, I>>(base?: I): ViewInfo_ExpConfigEntry {
    return ViewInfo_ExpConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo_ExpConfigEntry>, I>>(object: I): ViewInfo_ExpConfigEntry {
    const message = createBaseViewInfo_ExpConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseViewInfo_ExtDialogEntry(): ViewInfo_ExtDialogEntry {
  return { key: "", value: undefined };
}

export const ViewInfo_ExtDialogEntry: MessageFns<ViewInfo_ExtDialogEntry> = {
  encode(message: ViewInfo_ExtDialogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Dialog.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo_ExtDialogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo_ExtDialogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Dialog.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo_ExtDialogEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Dialog.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ViewInfo_ExtDialogEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Dialog.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo_ExtDialogEntry>, I>>(base?: I): ViewInfo_ExtDialogEntry {
    return ViewInfo_ExtDialogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo_ExtDialogEntry>, I>>(object: I): ViewInfo_ExtDialogEntry {
    const message = createBaseViewInfo_ExtDialogEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Dialog.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseViewInfo_ExtToastEntry(): ViewInfo_ExtToastEntry {
  return { key: "", value: undefined };
}

export const ViewInfo_ExtToastEntry: MessageFns<ViewInfo_ExtToastEntry> = {
  encode(message: ViewInfo_ExtToastEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Toast.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo_ExtToastEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo_ExtToastEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Toast.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo_ExtToastEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Toast.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ViewInfo_ExtToastEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Toast.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo_ExtToastEntry>, I>>(base?: I): ViewInfo_ExtToastEntry {
    return ViewInfo_ExtToastEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo_ExtToastEntry>, I>>(object: I): ViewInfo_ExtToastEntry {
    const message = createBaseViewInfo_ExtToastEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Toast.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseDialog(): Dialog {
  return {
    code: 0n,
    msg: "",
    type: "",
    styleType: "",
    config: undefined,
    title: undefined,
    subtitle: undefined,
    image: undefined,
    button: [],
    bottomDesc: undefined,
    report: undefined,
    countDownSec: 0,
    rightBottomDesc: undefined,
    bottomDisplay: [],
    playList: [],
  };
}

export const Dialog: MessageFns<Dialog> = {
  encode(message: Dialog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0n) {
      if (BigInt.asIntN(64, message.code) !== message.code) {
        throw new globalThis.Error("value provided for field message.code of type int64 too large");
      }
      writer.uint32(8).int64(message.code);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.styleType !== "") {
      writer.uint32(34).string(message.styleType);
    }
    if (message.config !== undefined) {
      DialogConfig.encode(message.config, writer.uint32(42).fork()).join();
    }
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(50).fork()).join();
    }
    if (message.subtitle !== undefined) {
      TextInfo.encode(message.subtitle, writer.uint32(58).fork()).join();
    }
    if (message.image !== undefined) {
      ImageInfo.encode(message.image, writer.uint32(66).fork()).join();
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.bottomDesc !== undefined) {
      ButtonInfo.encode(message.bottomDesc, writer.uint32(82).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(90).fork()).join();
    }
    if (message.countDownSec !== 0) {
      writer.uint32(96).int32(message.countDownSec);
    }
    if (message.rightBottomDesc !== undefined) {
      TextInfo.encode(message.rightBottomDesc, writer.uint32(106).fork()).join();
    }
    for (const v of message.bottomDisplay) {
      BottomDisplay.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.playList) {
      PlayList.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dialog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.styleType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.config = DialogConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subtitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.image = ImageInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bottomDesc = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.countDownSec = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.rightBottomDesc = TextInfo.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.bottomDisplay.push(BottomDisplay.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.playList.push(PlayList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dialog {
    return {
      code: isSet(object.code) ? BigInt(object.code) : 0n,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      styleType: isSet(object.styleType) ? globalThis.String(object.styleType) : "",
      config: isSet(object.config) ? DialogConfig.fromJSON(object.config) : undefined,
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      subtitle: isSet(object.subtitle) ? TextInfo.fromJSON(object.subtitle) : undefined,
      image: isSet(object.image) ? ImageInfo.fromJSON(object.image) : undefined,
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      bottomDesc: isSet(object.bottomDesc) ? ButtonInfo.fromJSON(object.bottomDesc) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      countDownSec: isSet(object.countDownSec) ? globalThis.Number(object.countDownSec) : 0,
      rightBottomDesc: isSet(object.rightBottomDesc) ? TextInfo.fromJSON(object.rightBottomDesc) : undefined,
      bottomDisplay: globalThis.Array.isArray(object?.bottomDisplay)
        ? object.bottomDisplay.map((e: any) => BottomDisplay.fromJSON(e))
        : [],
      playList: globalThis.Array.isArray(object?.playList) ? object.playList.map((e: any) => PlayList.fromJSON(e)) : [],
    };
  },

  toJSON(message: Dialog): unknown {
    const obj: any = {};
    if (message.code !== 0n) {
      obj.code = message.code.toString();
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.styleType !== "") {
      obj.styleType = message.styleType;
    }
    if (message.config !== undefined) {
      obj.config = DialogConfig.toJSON(message.config);
    }
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.subtitle !== undefined) {
      obj.subtitle = TextInfo.toJSON(message.subtitle);
    }
    if (message.image !== undefined) {
      obj.image = ImageInfo.toJSON(message.image);
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.bottomDesc !== undefined) {
      obj.bottomDesc = ButtonInfo.toJSON(message.bottomDesc);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.countDownSec !== 0) {
      obj.countDownSec = Math.round(message.countDownSec);
    }
    if (message.rightBottomDesc !== undefined) {
      obj.rightBottomDesc = TextInfo.toJSON(message.rightBottomDesc);
    }
    if (message.bottomDisplay?.length) {
      obj.bottomDisplay = message.bottomDisplay.map((e) => BottomDisplay.toJSON(e));
    }
    if (message.playList?.length) {
      obj.playList = message.playList.map((e) => PlayList.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dialog>, I>>(base?: I): Dialog {
    return Dialog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dialog>, I>>(object: I): Dialog {
    const message = createBaseDialog();
    message.code = object.code ?? 0n;
    message.msg = object.msg ?? "";
    message.type = object.type ?? "";
    message.styleType = object.styleType ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? DialogConfig.fromPartial(object.config)
      : undefined;
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.subtitle = (object.subtitle !== undefined && object.subtitle !== null)
      ? TextInfo.fromPartial(object.subtitle)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? ImageInfo.fromPartial(object.image)
      : undefined;
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.bottomDesc = (object.bottomDesc !== undefined && object.bottomDesc !== null)
      ? ButtonInfo.fromPartial(object.bottomDesc)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.countDownSec = object.countDownSec ?? 0;
    message.rightBottomDesc = (object.rightBottomDesc !== undefined && object.rightBottomDesc !== null)
      ? TextInfo.fromPartial(object.rightBottomDesc)
      : undefined;
    message.bottomDisplay = object.bottomDisplay?.map((e) => BottomDisplay.fromPartial(e)) || [];
    message.playList = object.playList?.map((e) => PlayList.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDialogConfig(): DialogConfig {
  return {
    isShowCover: false,
    isOrientationEnable: false,
    isNestedScrollEnable: false,
    isForceHalfscreenEnable: false,
    isBackgroundTranslucentEnable: false,
  };
}

export const DialogConfig: MessageFns<DialogConfig> = {
  encode(message: DialogConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isShowCover !== false) {
      writer.uint32(8).bool(message.isShowCover);
    }
    if (message.isOrientationEnable !== false) {
      writer.uint32(16).bool(message.isOrientationEnable);
    }
    if (message.isNestedScrollEnable !== false) {
      writer.uint32(24).bool(message.isNestedScrollEnable);
    }
    if (message.isForceHalfscreenEnable !== false) {
      writer.uint32(32).bool(message.isForceHalfscreenEnable);
    }
    if (message.isBackgroundTranslucentEnable !== false) {
      writer.uint32(40).bool(message.isBackgroundTranslucentEnable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isShowCover = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isOrientationEnable = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isNestedScrollEnable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isForceHalfscreenEnable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isBackgroundTranslucentEnable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogConfig {
    return {
      isShowCover: isSet(object.isShowCover) ? globalThis.Boolean(object.isShowCover) : false,
      isOrientationEnable: isSet(object.isOrientationEnable) ? globalThis.Boolean(object.isOrientationEnable) : false,
      isNestedScrollEnable: isSet(object.isNestedScrollEnable)
        ? globalThis.Boolean(object.isNestedScrollEnable)
        : false,
      isForceHalfscreenEnable: isSet(object.isForceHalfscreenEnable)
        ? globalThis.Boolean(object.isForceHalfscreenEnable)
        : false,
      isBackgroundTranslucentEnable: isSet(object.isBackgroundTranslucentEnable)
        ? globalThis.Boolean(object.isBackgroundTranslucentEnable)
        : false,
    };
  },

  toJSON(message: DialogConfig): unknown {
    const obj: any = {};
    if (message.isShowCover !== false) {
      obj.isShowCover = message.isShowCover;
    }
    if (message.isOrientationEnable !== false) {
      obj.isOrientationEnable = message.isOrientationEnable;
    }
    if (message.isNestedScrollEnable !== false) {
      obj.isNestedScrollEnable = message.isNestedScrollEnable;
    }
    if (message.isForceHalfscreenEnable !== false) {
      obj.isForceHalfscreenEnable = message.isForceHalfscreenEnable;
    }
    if (message.isBackgroundTranslucentEnable !== false) {
      obj.isBackgroundTranslucentEnable = message.isBackgroundTranslucentEnable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogConfig>, I>>(base?: I): DialogConfig {
    return DialogConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogConfig>, I>>(object: I): DialogConfig {
    const message = createBaseDialogConfig();
    message.isShowCover = object.isShowCover ?? false;
    message.isOrientationEnable = object.isOrientationEnable ?? false;
    message.isNestedScrollEnable = object.isNestedScrollEnable ?? false;
    message.isForceHalfscreenEnable = object.isForceHalfscreenEnable ?? false;
    message.isBackgroundTranslucentEnable = object.isBackgroundTranslucentEnable ?? false;
    return message;
  },
};

function createBaseImageInfo(): ImageInfo {
  return { url: "" };
}

export const ImageInfo: MessageFns<ImageInfo> = {
  encode(message: ImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageInfo {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: ImageInfo): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageInfo>, I>>(base?: I): ImageInfo {
    return ImageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageInfo>, I>>(object: I): ImageInfo {
    const message = createBaseImageInfo();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseBottomDisplay(): BottomDisplay {
  return { title: undefined, icon: "" };
}

export const BottomDisplay: MessageFns<BottomDisplay> = {
  encode(message: BottomDisplay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(10).fork()).join();
    }
    if (message.icon !== "") {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BottomDisplay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBottomDisplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BottomDisplay {
    return {
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
    };
  },

  toJSON(message: BottomDisplay): unknown {
    const obj: any = {};
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BottomDisplay>, I>>(base?: I): BottomDisplay {
    return BottomDisplay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BottomDisplay>, I>>(object: I): BottomDisplay {
    const message = createBaseBottomDisplay();
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.icon = object.icon ?? "";
    return message;
  },
};

function createBasePlayList(): PlayList {
  return { seasonId: 0, title: "", cover: "", link: "", badgeInfo: undefined };
}

export const PlayList: MessageFns<PlayList> = {
  encode(message: PlayList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seasonId !== 0) {
      writer.uint32(8).int32(message.seasonId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.cover !== "") {
      writer.uint32(26).string(message.cover);
    }
    if (message.link !== "") {
      writer.uint32(34).string(message.link);
    }
    if (message.badgeInfo !== undefined) {
      BadgeInfo.encode(message.badgeInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seasonId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cover = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.link = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.badgeInfo = BadgeInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayList {
    return {
      seasonId: isSet(object.seasonId) ? globalThis.Number(object.seasonId) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      badgeInfo: isSet(object.badgeInfo) ? BadgeInfo.fromJSON(object.badgeInfo) : undefined,
    };
  },

  toJSON(message: PlayList): unknown {
    const obj: any = {};
    if (message.seasonId !== 0) {
      obj.seasonId = Math.round(message.seasonId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.badgeInfo !== undefined) {
      obj.badgeInfo = BadgeInfo.toJSON(message.badgeInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayList>, I>>(base?: I): PlayList {
    return PlayList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayList>, I>>(object: I): PlayList {
    const message = createBasePlayList();
    message.seasonId = object.seasonId ?? 0;
    message.title = object.title ?? "";
    message.cover = object.cover ?? "";
    message.link = object.link ?? "";
    message.badgeInfo = (object.badgeInfo !== undefined && object.badgeInfo !== null)
      ? BadgeInfo.fromPartial(object.badgeInfo)
      : undefined;
    return message;
  },
};

function createBaseCouponInfo(): CouponInfo {
  return { toast: undefined, popWin: undefined };
}

export const CouponInfo: MessageFns<CouponInfo> = {
  encode(message: CouponInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toast !== undefined) {
      CouponToast.encode(message.toast, writer.uint32(10).fork()).join();
    }
    if (message.popWin !== undefined) {
      PopWin.encode(message.popWin, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CouponInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCouponInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toast = CouponToast.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.popWin = PopWin.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CouponInfo {
    return {
      toast: isSet(object.toast) ? CouponToast.fromJSON(object.toast) : undefined,
      popWin: isSet(object.popWin) ? PopWin.fromJSON(object.popWin) : undefined,
    };
  },

  toJSON(message: CouponInfo): unknown {
    const obj: any = {};
    if (message.toast !== undefined) {
      obj.toast = CouponToast.toJSON(message.toast);
    }
    if (message.popWin !== undefined) {
      obj.popWin = PopWin.toJSON(message.popWin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CouponInfo>, I>>(base?: I): CouponInfo {
    return CouponInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CouponInfo>, I>>(object: I): CouponInfo {
    const message = createBaseCouponInfo();
    message.toast = (object.toast !== undefined && object.toast !== null)
      ? CouponToast.fromPartial(object.toast)
      : undefined;
    message.popWin = (object.popWin !== undefined && object.popWin !== null)
      ? PopWin.fromPartial(object.popWin)
      : undefined;
    return message;
  },
};

function createBaseCouponToast(): CouponToast {
  return { textInfo: undefined, button: undefined };
}

export const CouponToast: MessageFns<CouponToast> = {
  encode(message: CouponToast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textInfo !== undefined) {
      CouponTextInfo.encode(message.textInfo, writer.uint32(10).fork()).join();
    }
    if (message.button !== undefined) {
      ButtonInfo.encode(message.button, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CouponToast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCouponToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textInfo = CouponTextInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.button = ButtonInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CouponToast {
    return {
      textInfo: isSet(object.textInfo) ? CouponTextInfo.fromJSON(object.textInfo) : undefined,
      button: isSet(object.button) ? ButtonInfo.fromJSON(object.button) : undefined,
    };
  },

  toJSON(message: CouponToast): unknown {
    const obj: any = {};
    if (message.textInfo !== undefined) {
      obj.textInfo = CouponTextInfo.toJSON(message.textInfo);
    }
    if (message.button !== undefined) {
      obj.button = ButtonInfo.toJSON(message.button);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CouponToast>, I>>(base?: I): CouponToast {
    return CouponToast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CouponToast>, I>>(object: I): CouponToast {
    const message = createBaseCouponToast();
    message.textInfo = (object.textInfo !== undefined && object.textInfo !== null)
      ? CouponTextInfo.fromPartial(object.textInfo)
      : undefined;
    message.button = (object.button !== undefined && object.button !== null)
      ? ButtonInfo.fromPartial(object.button)
      : undefined;
    return message;
  },
};

function createBaseCouponTextInfo(): CouponTextInfo {
  return { positivePreview: "", section: "" };
}

export const CouponTextInfo: MessageFns<CouponTextInfo> = {
  encode(message: CouponTextInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.positivePreview !== "") {
      writer.uint32(10).string(message.positivePreview);
    }
    if (message.section !== "") {
      writer.uint32(18).string(message.section);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CouponTextInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCouponTextInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.positivePreview = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.section = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CouponTextInfo {
    return {
      positivePreview: isSet(object.positivePreview) ? globalThis.String(object.positivePreview) : "",
      section: isSet(object.section) ? globalThis.String(object.section) : "",
    };
  },

  toJSON(message: CouponTextInfo): unknown {
    const obj: any = {};
    if (message.positivePreview !== "") {
      obj.positivePreview = message.positivePreview;
    }
    if (message.section !== "") {
      obj.section = message.section;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CouponTextInfo>, I>>(base?: I): CouponTextInfo {
    return CouponTextInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CouponTextInfo>, I>>(object: I): CouponTextInfo {
    const message = createBaseCouponTextInfo();
    message.positivePreview = object.positivePreview ?? "";
    message.section = object.section ?? "";
    return message;
  },
};

function createBasePopWin(): PopWin {
  return {
    title: "",
    coupon: [],
    button: [],
    bottomText: "",
    popTitle: undefined,
    subtitle: undefined,
    bottomDesc: undefined,
    cover: "",
    popType: "",
  };
}

export const PopWin: MessageFns<PopWin> = {
  encode(message: PopWin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.coupon) {
      Coupon.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.bottomText !== "") {
      writer.uint32(34).string(message.bottomText);
    }
    if (message.popTitle !== undefined) {
      TextInfo.encode(message.popTitle, writer.uint32(42).fork()).join();
    }
    if (message.subtitle !== undefined) {
      TextInfo.encode(message.subtitle, writer.uint32(50).fork()).join();
    }
    if (message.bottomDesc !== undefined) {
      ButtonInfo.encode(message.bottomDesc, writer.uint32(58).fork()).join();
    }
    if (message.cover !== "") {
      writer.uint32(66).string(message.cover);
    }
    if (message.popType !== "") {
      writer.uint32(74).string(message.popType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopWin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopWin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.coupon.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bottomText = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.popTitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subtitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bottomDesc = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cover = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.popType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopWin {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      coupon: globalThis.Array.isArray(object?.coupon) ? object.coupon.map((e: any) => Coupon.fromJSON(e)) : [],
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      bottomText: isSet(object.bottomText) ? globalThis.String(object.bottomText) : "",
      popTitle: isSet(object.popTitle) ? TextInfo.fromJSON(object.popTitle) : undefined,
      subtitle: isSet(object.subtitle) ? TextInfo.fromJSON(object.subtitle) : undefined,
      bottomDesc: isSet(object.bottomDesc) ? ButtonInfo.fromJSON(object.bottomDesc) : undefined,
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      popType: isSet(object.popType) ? globalThis.String(object.popType) : "",
    };
  },

  toJSON(message: PopWin): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.coupon?.length) {
      obj.coupon = message.coupon.map((e) => Coupon.toJSON(e));
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.bottomText !== "") {
      obj.bottomText = message.bottomText;
    }
    if (message.popTitle !== undefined) {
      obj.popTitle = TextInfo.toJSON(message.popTitle);
    }
    if (message.subtitle !== undefined) {
      obj.subtitle = TextInfo.toJSON(message.subtitle);
    }
    if (message.bottomDesc !== undefined) {
      obj.bottomDesc = ButtonInfo.toJSON(message.bottomDesc);
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.popType !== "") {
      obj.popType = message.popType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PopWin>, I>>(base?: I): PopWin {
    return PopWin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PopWin>, I>>(object: I): PopWin {
    const message = createBasePopWin();
    message.title = object.title ?? "";
    message.coupon = object.coupon?.map((e) => Coupon.fromPartial(e)) || [];
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.bottomText = object.bottomText ?? "";
    message.popTitle = (object.popTitle !== undefined && object.popTitle !== null)
      ? TextInfo.fromPartial(object.popTitle)
      : undefined;
    message.subtitle = (object.subtitle !== undefined && object.subtitle !== null)
      ? TextInfo.fromPartial(object.subtitle)
      : undefined;
    message.bottomDesc = (object.bottomDesc !== undefined && object.bottomDesc !== null)
      ? ButtonInfo.fromPartial(object.bottomDesc)
      : undefined;
    message.cover = object.cover ?? "";
    message.popType = object.popType ?? "";
    return message;
  },
};

function createBaseCoupon(): Coupon {
  return {
    couponToken: "",
    type: 0n,
    value: "",
    useDesc: "",
    title: "",
    desc: "",
    payButtonText: "",
    payButtonTextLineThrough: "",
    realAmount: "",
    expireTime: undefined,
    otype: 0n,
    amount: "",
  };
}

export const Coupon: MessageFns<Coupon> = {
  encode(message: Coupon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.couponToken !== "") {
      writer.uint32(10).string(message.couponToken);
    }
    if (message.type !== 0n) {
      if (BigInt.asIntN(64, message.type) !== message.type) {
        throw new globalThis.Error("value provided for field message.type of type int64 too large");
      }
      writer.uint32(16).int64(message.type);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.useDesc !== "") {
      writer.uint32(34).string(message.useDesc);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.desc !== "") {
      writer.uint32(50).string(message.desc);
    }
    if (message.payButtonText !== "") {
      writer.uint32(58).string(message.payButtonText);
    }
    if (message.payButtonTextLineThrough !== "") {
      writer.uint32(66).string(message.payButtonTextLineThrough);
    }
    if (message.realAmount !== "") {
      writer.uint32(74).string(message.realAmount);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(message.expireTime, writer.uint32(82).fork()).join();
    }
    if (message.otype !== 0n) {
      if (BigInt.asIntN(64, message.otype) !== message.otype) {
        throw new globalThis.Error("value provided for field message.otype of type int64 too large");
      }
      writer.uint32(88).int64(message.otype);
    }
    if (message.amount !== "") {
      writer.uint32(98).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Coupon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoupon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.couponToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.useDesc = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.desc = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payButtonText = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.payButtonTextLineThrough = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.realAmount = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.expireTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.otype = reader.int64() as bigint;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Coupon {
    return {
      couponToken: isSet(object.couponToken) ? globalThis.String(object.couponToken) : "",
      type: isSet(object.type) ? BigInt(object.type) : 0n,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      useDesc: isSet(object.useDesc) ? globalThis.String(object.useDesc) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      payButtonText: isSet(object.payButtonText) ? globalThis.String(object.payButtonText) : "",
      payButtonTextLineThrough: isSet(object.payButtonTextLineThrough)
        ? globalThis.String(object.payButtonTextLineThrough)
        : "",
      realAmount: isSet(object.realAmount) ? globalThis.String(object.realAmount) : "",
      expireTime: isSet(object.expireTime) ? Timestamp.fromJSON(object.expireTime) : undefined,
      otype: isSet(object.otype) ? BigInt(object.otype) : 0n,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: Coupon): unknown {
    const obj: any = {};
    if (message.couponToken !== "") {
      obj.couponToken = message.couponToken;
    }
    if (message.type !== 0n) {
      obj.type = message.type.toString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.useDesc !== "") {
      obj.useDesc = message.useDesc;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.payButtonText !== "") {
      obj.payButtonText = message.payButtonText;
    }
    if (message.payButtonTextLineThrough !== "") {
      obj.payButtonTextLineThrough = message.payButtonTextLineThrough;
    }
    if (message.realAmount !== "") {
      obj.realAmount = message.realAmount;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = Timestamp.toJSON(message.expireTime);
    }
    if (message.otype !== 0n) {
      obj.otype = message.otype.toString();
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Coupon>, I>>(base?: I): Coupon {
    return Coupon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Coupon>, I>>(object: I): Coupon {
    const message = createBaseCoupon();
    message.couponToken = object.couponToken ?? "";
    message.type = object.type ?? 0n;
    message.value = object.value ?? "";
    message.useDesc = object.useDesc ?? "";
    message.title = object.title ?? "";
    message.desc = object.desc ?? "";
    message.payButtonText = object.payButtonText ?? "";
    message.payButtonTextLineThrough = object.payButtonTextLineThrough ?? "";
    message.realAmount = object.realAmount ?? "";
    message.expireTime = (object.expireTime !== undefined && object.expireTime !== null)
      ? Timestamp.fromPartial(object.expireTime)
      : undefined;
    message.otype = object.otype ?? 0n;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBasePromptBar(): PromptBar {
  return {
    title: undefined,
    subTitle: undefined,
    subTitleIcon: "",
    bgImage: "",
    bgGradientColor: undefined,
    button: [],
    report: undefined,
    fullScreenIpIcon: "",
    fullScreenBgGradientColor: undefined,
  };
}

export const PromptBar: MessageFns<PromptBar> = {
  encode(message: PromptBar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(10).fork()).join();
    }
    if (message.subTitle !== undefined) {
      TextInfo.encode(message.subTitle, writer.uint32(18).fork()).join();
    }
    if (message.subTitleIcon !== "") {
      writer.uint32(26).string(message.subTitleIcon);
    }
    if (message.bgImage !== "") {
      writer.uint32(34).string(message.bgImage);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(42).fork()).join();
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(58).fork()).join();
    }
    if (message.fullScreenIpIcon !== "") {
      writer.uint32(66).string(message.fullScreenIpIcon);
    }
    if (message.fullScreenBgGradientColor !== undefined) {
      GradientColor.encode(message.fullScreenBgGradientColor, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptBar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptBar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subTitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subTitleIcon = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bgImage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fullScreenIpIcon = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fullScreenBgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptBar {
    return {
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      subTitle: isSet(object.subTitle) ? TextInfo.fromJSON(object.subTitle) : undefined,
      subTitleIcon: isSet(object.subTitleIcon) ? globalThis.String(object.subTitleIcon) : "",
      bgImage: isSet(object.bgImage) ? globalThis.String(object.bgImage) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      fullScreenIpIcon: isSet(object.fullScreenIpIcon) ? globalThis.String(object.fullScreenIpIcon) : "",
      fullScreenBgGradientColor: isSet(object.fullScreenBgGradientColor)
        ? GradientColor.fromJSON(object.fullScreenBgGradientColor)
        : undefined,
    };
  },

  toJSON(message: PromptBar): unknown {
    const obj: any = {};
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.subTitle !== undefined) {
      obj.subTitle = TextInfo.toJSON(message.subTitle);
    }
    if (message.subTitleIcon !== "") {
      obj.subTitleIcon = message.subTitleIcon;
    }
    if (message.bgImage !== "") {
      obj.bgImage = message.bgImage;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.fullScreenIpIcon !== "") {
      obj.fullScreenIpIcon = message.fullScreenIpIcon;
    }
    if (message.fullScreenBgGradientColor !== undefined) {
      obj.fullScreenBgGradientColor = GradientColor.toJSON(message.fullScreenBgGradientColor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PromptBar>, I>>(base?: I): PromptBar {
    return PromptBar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PromptBar>, I>>(object: I): PromptBar {
    const message = createBasePromptBar();
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.subTitle = (object.subTitle !== undefined && object.subTitle !== null)
      ? TextInfo.fromPartial(object.subTitle)
      : undefined;
    message.subTitleIcon = object.subTitleIcon ?? "";
    message.bgImage = object.bgImage ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.fullScreenIpIcon = object.fullScreenIpIcon ?? "";
    message.fullScreenBgGradientColor =
      (object.fullScreenBgGradientColor !== undefined && object.fullScreenBgGradientColor !== null)
        ? GradientColor.fromPartial(object.fullScreenBgGradientColor)
        : undefined;
    return message;
  },
};

function createBasePayTip(): PayTip {
  return {
    title: "",
    url: "",
    icon: "",
    type: 0,
    showType: 0,
    img: "",
    bgDayColor: "",
    bgNightColor: "",
    bgLineColor: "",
    bgNightLineColor: "",
    textColor: "",
    textNightColor: "",
    viewStartTime: 0n,
    button: [],
    urlOpenType: 0,
    report: undefined,
    angleStyle: 0,
    reportType: 0,
    orderReportParams: {},
    giantScreenImg: "",
  };
}

export const PayTip: MessageFns<PayTip> = {
  encode(message: PayTip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.icon !== "") {
      writer.uint32(26).string(message.icon);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.showType !== 0) {
      writer.uint32(40).int32(message.showType);
    }
    if (message.img !== "") {
      writer.uint32(50).string(message.img);
    }
    if (message.bgDayColor !== "") {
      writer.uint32(58).string(message.bgDayColor);
    }
    if (message.bgNightColor !== "") {
      writer.uint32(66).string(message.bgNightColor);
    }
    if (message.bgLineColor !== "") {
      writer.uint32(74).string(message.bgLineColor);
    }
    if (message.bgNightLineColor !== "") {
      writer.uint32(82).string(message.bgNightLineColor);
    }
    if (message.textColor !== "") {
      writer.uint32(90).string(message.textColor);
    }
    if (message.textNightColor !== "") {
      writer.uint32(98).string(message.textNightColor);
    }
    if (message.viewStartTime !== 0n) {
      if (BigInt.asIntN(64, message.viewStartTime) !== message.viewStartTime) {
        throw new globalThis.Error("value provided for field message.viewStartTime of type int64 too large");
      }
      writer.uint32(104).int64(message.viewStartTime);
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.urlOpenType !== 0) {
      writer.uint32(120).int32(message.urlOpenType);
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(130).fork()).join();
    }
    if (message.angleStyle !== 0) {
      writer.uint32(136).int32(message.angleStyle);
    }
    if (message.reportType !== 0) {
      writer.uint32(144).int32(message.reportType);
    }
    Object.entries(message.orderReportParams).forEach(([key, value]) => {
      PayTip_OrderReportParamsEntry.encode({ key: key as any, value }, writer.uint32(154).fork()).join();
    });
    if (message.giantScreenImg !== "") {
      writer.uint32(162).string(message.giantScreenImg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayTip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.showType = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.img = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bgDayColor = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bgNightColor = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.bgLineColor = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bgNightLineColor = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.textNightColor = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.viewStartTime = reader.int64() as bigint;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.urlOpenType = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.angleStyle = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.reportType = reader.int32();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          const entry19 = PayTip_OrderReportParamsEntry.decode(reader, reader.uint32());
          if (entry19.value !== undefined) {
            message.orderReportParams[entry19.key] = entry19.value;
          }
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.giantScreenImg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayTip {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      showType: isSet(object.showType) ? globalThis.Number(object.showType) : 0,
      img: isSet(object.img) ? globalThis.String(object.img) : "",
      bgDayColor: isSet(object.bgDayColor) ? globalThis.String(object.bgDayColor) : "",
      bgNightColor: isSet(object.bgNightColor) ? globalThis.String(object.bgNightColor) : "",
      bgLineColor: isSet(object.bgLineColor) ? globalThis.String(object.bgLineColor) : "",
      bgNightLineColor: isSet(object.bgNightLineColor) ? globalThis.String(object.bgNightLineColor) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      textNightColor: isSet(object.textNightColor) ? globalThis.String(object.textNightColor) : "",
      viewStartTime: isSet(object.viewStartTime) ? BigInt(object.viewStartTime) : 0n,
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      urlOpenType: isSet(object.urlOpenType) ? globalThis.Number(object.urlOpenType) : 0,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      angleStyle: isSet(object.angleStyle) ? globalThis.Number(object.angleStyle) : 0,
      reportType: isSet(object.reportType) ? globalThis.Number(object.reportType) : 0,
      orderReportParams: isObject(object.orderReportParams)
        ? Object.entries(object.orderReportParams).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      giantScreenImg: isSet(object.giantScreenImg) ? globalThis.String(object.giantScreenImg) : "",
    };
  },

  toJSON(message: PayTip): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.showType !== 0) {
      obj.showType = Math.round(message.showType);
    }
    if (message.img !== "") {
      obj.img = message.img;
    }
    if (message.bgDayColor !== "") {
      obj.bgDayColor = message.bgDayColor;
    }
    if (message.bgNightColor !== "") {
      obj.bgNightColor = message.bgNightColor;
    }
    if (message.bgLineColor !== "") {
      obj.bgLineColor = message.bgLineColor;
    }
    if (message.bgNightLineColor !== "") {
      obj.bgNightLineColor = message.bgNightLineColor;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textNightColor !== "") {
      obj.textNightColor = message.textNightColor;
    }
    if (message.viewStartTime !== 0n) {
      obj.viewStartTime = message.viewStartTime.toString();
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.urlOpenType !== 0) {
      obj.urlOpenType = Math.round(message.urlOpenType);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.angleStyle !== 0) {
      obj.angleStyle = Math.round(message.angleStyle);
    }
    if (message.reportType !== 0) {
      obj.reportType = Math.round(message.reportType);
    }
    if (message.orderReportParams) {
      const entries = Object.entries(message.orderReportParams);
      if (entries.length > 0) {
        obj.orderReportParams = {};
        entries.forEach(([k, v]) => {
          obj.orderReportParams[k] = v;
        });
      }
    }
    if (message.giantScreenImg !== "") {
      obj.giantScreenImg = message.giantScreenImg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayTip>, I>>(base?: I): PayTip {
    return PayTip.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayTip>, I>>(object: I): PayTip {
    const message = createBasePayTip();
    message.title = object.title ?? "";
    message.url = object.url ?? "";
    message.icon = object.icon ?? "";
    message.type = object.type ?? 0;
    message.showType = object.showType ?? 0;
    message.img = object.img ?? "";
    message.bgDayColor = object.bgDayColor ?? "";
    message.bgNightColor = object.bgNightColor ?? "";
    message.bgLineColor = object.bgLineColor ?? "";
    message.bgNightLineColor = object.bgNightLineColor ?? "";
    message.textColor = object.textColor ?? "";
    message.textNightColor = object.textNightColor ?? "";
    message.viewStartTime = object.viewStartTime ?? 0n;
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.urlOpenType = object.urlOpenType ?? 0;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.angleStyle = object.angleStyle ?? 0;
    message.reportType = object.reportType ?? 0;
    message.orderReportParams = Object.entries(object.orderReportParams ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.giantScreenImg = object.giantScreenImg ?? "";
    return message;
  },
};

function createBasePayTip_OrderReportParamsEntry(): PayTip_OrderReportParamsEntry {
  return { key: "", value: "" };
}

export const PayTip_OrderReportParamsEntry: MessageFns<PayTip_OrderReportParamsEntry> = {
  encode(message: PayTip_OrderReportParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayTip_OrderReportParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayTip_OrderReportParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayTip_OrderReportParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PayTip_OrderReportParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayTip_OrderReportParamsEntry>, I>>(base?: I): PayTip_OrderReportParamsEntry {
    return PayTip_OrderReportParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayTip_OrderReportParamsEntry>, I>>(
    object: I,
  ): PayTip_OrderReportParamsEntry {
    const message = createBasePayTip_OrderReportParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHighDefinitionTrialInfo(): HighDefinitionTrialInfo {
  return {
    trialAble: false,
    remainingTimes: 0,
    start: 0,
    timeLength: 0,
    startToast: undefined,
    endToast: undefined,
    report: undefined,
    qualityOpenTipBtn: undefined,
    noLongerTrialBtn: undefined,
  };
}

export const HighDefinitionTrialInfo: MessageFns<HighDefinitionTrialInfo> = {
  encode(message: HighDefinitionTrialInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trialAble !== false) {
      writer.uint32(8).bool(message.trialAble);
    }
    if (message.remainingTimes !== 0) {
      writer.uint32(16).int32(message.remainingTimes);
    }
    if (message.start !== 0) {
      writer.uint32(24).int32(message.start);
    }
    if (message.timeLength !== 0) {
      writer.uint32(32).int32(message.timeLength);
    }
    if (message.startToast !== undefined) {
      Toast.encode(message.startToast, writer.uint32(42).fork()).join();
    }
    if (message.endToast !== undefined) {
      Toast.encode(message.endToast, writer.uint32(50).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(58).fork()).join();
    }
    if (message.qualityOpenTipBtn !== undefined) {
      ButtonInfo.encode(message.qualityOpenTipBtn, writer.uint32(66).fork()).join();
    }
    if (message.noLongerTrialBtn !== undefined) {
      ButtonInfo.encode(message.noLongerTrialBtn, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighDefinitionTrialInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighDefinitionTrialInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trialAble = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remainingTimes = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeLength = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startToast = Toast.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endToast = Toast.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.qualityOpenTipBtn = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.noLongerTrialBtn = ButtonInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HighDefinitionTrialInfo {
    return {
      trialAble: isSet(object.trialAble) ? globalThis.Boolean(object.trialAble) : false,
      remainingTimes: isSet(object.remainingTimes) ? globalThis.Number(object.remainingTimes) : 0,
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      timeLength: isSet(object.timeLength) ? globalThis.Number(object.timeLength) : 0,
      startToast: isSet(object.startToast) ? Toast.fromJSON(object.startToast) : undefined,
      endToast: isSet(object.endToast) ? Toast.fromJSON(object.endToast) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      qualityOpenTipBtn: isSet(object.qualityOpenTipBtn) ? ButtonInfo.fromJSON(object.qualityOpenTipBtn) : undefined,
      noLongerTrialBtn: isSet(object.noLongerTrialBtn) ? ButtonInfo.fromJSON(object.noLongerTrialBtn) : undefined,
    };
  },

  toJSON(message: HighDefinitionTrialInfo): unknown {
    const obj: any = {};
    if (message.trialAble !== false) {
      obj.trialAble = message.trialAble;
    }
    if (message.remainingTimes !== 0) {
      obj.remainingTimes = Math.round(message.remainingTimes);
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.timeLength !== 0) {
      obj.timeLength = Math.round(message.timeLength);
    }
    if (message.startToast !== undefined) {
      obj.startToast = Toast.toJSON(message.startToast);
    }
    if (message.endToast !== undefined) {
      obj.endToast = Toast.toJSON(message.endToast);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.qualityOpenTipBtn !== undefined) {
      obj.qualityOpenTipBtn = ButtonInfo.toJSON(message.qualityOpenTipBtn);
    }
    if (message.noLongerTrialBtn !== undefined) {
      obj.noLongerTrialBtn = ButtonInfo.toJSON(message.noLongerTrialBtn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HighDefinitionTrialInfo>, I>>(base?: I): HighDefinitionTrialInfo {
    return HighDefinitionTrialInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HighDefinitionTrialInfo>, I>>(object: I): HighDefinitionTrialInfo {
    const message = createBaseHighDefinitionTrialInfo();
    message.trialAble = object.trialAble ?? false;
    message.remainingTimes = object.remainingTimes ?? 0;
    message.start = object.start ?? 0;
    message.timeLength = object.timeLength ?? 0;
    message.startToast = (object.startToast !== undefined && object.startToast !== null)
      ? Toast.fromPartial(object.startToast)
      : undefined;
    message.endToast = (object.endToast !== undefined && object.endToast !== null)
      ? Toast.fromPartial(object.endToast)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.qualityOpenTipBtn = (object.qualityOpenTipBtn !== undefined && object.qualityOpenTipBtn !== null)
      ? ButtonInfo.fromPartial(object.qualityOpenTipBtn)
      : undefined;
    message.noLongerTrialBtn = (object.noLongerTrialBtn !== undefined && object.noLongerTrialBtn !== null)
      ? ButtonInfo.fromPartial(object.noLongerTrialBtn)
      : undefined;
    return message;
  },
};

function createBaseAnimation(): Animation {
  return { qnSvgaAnimationMap: {} };
}

export const Animation: MessageFns<Animation> = {
  encode(message: Animation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.qnSvgaAnimationMap).forEach(([key, value]) => {
      Animation_QnSvgaAnimationMapEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Animation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Animation_QnSvgaAnimationMapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.qnSvgaAnimationMap[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Animation {
    return {
      qnSvgaAnimationMap: isObject(object.qnSvgaAnimationMap)
        ? Object.entries(object.qnSvgaAnimationMap).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Animation): unknown {
    const obj: any = {};
    if (message.qnSvgaAnimationMap) {
      const entries = Object.entries(message.qnSvgaAnimationMap);
      if (entries.length > 0) {
        obj.qnSvgaAnimationMap = {};
        entries.forEach(([k, v]) => {
          obj.qnSvgaAnimationMap[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Animation>, I>>(base?: I): Animation {
    return Animation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Animation>, I>>(object: I): Animation {
    const message = createBaseAnimation();
    message.qnSvgaAnimationMap = Object.entries(object.qnSvgaAnimationMap ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnimation_QnSvgaAnimationMapEntry(): Animation_QnSvgaAnimationMapEntry {
  return { key: "", value: "" };
}

export const Animation_QnSvgaAnimationMapEntry: MessageFns<Animation_QnSvgaAnimationMapEntry> = {
  encode(message: Animation_QnSvgaAnimationMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Animation_QnSvgaAnimationMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimation_QnSvgaAnimationMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Animation_QnSvgaAnimationMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Animation_QnSvgaAnimationMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Animation_QnSvgaAnimationMapEntry>, I>>(
    base?: I,
  ): Animation_QnSvgaAnimationMapEntry {
    return Animation_QnSvgaAnimationMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Animation_QnSvgaAnimationMapEntry>, I>>(
    object: I,
  ): Animation_QnSvgaAnimationMapEntry {
    const message = createBaseAnimation_QnSvgaAnimationMapEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEndPage(): EndPage {
  return { dialog: undefined, hide: false };
}

export const EndPage: MessageFns<EndPage> = {
  encode(message: EndPage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialog !== undefined) {
      Dialog.encode(message.dialog, writer.uint32(10).fork()).join();
    }
    if (message.hide !== false) {
      writer.uint32(16).bool(message.hide);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndPage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialog = Dialog.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hide = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndPage {
    return {
      dialog: isSet(object.dialog) ? Dialog.fromJSON(object.dialog) : undefined,
      hide: isSet(object.hide) ? globalThis.Boolean(object.hide) : false,
    };
  },

  toJSON(message: EndPage): unknown {
    const obj: any = {};
    if (message.dialog !== undefined) {
      obj.dialog = Dialog.toJSON(message.dialog);
    }
    if (message.hide !== false) {
      obj.hide = message.hide;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndPage>, I>>(base?: I): EndPage {
    return EndPage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndPage>, I>>(object: I): EndPage {
    const message = createBaseEndPage();
    message.dialog = (object.dialog !== undefined && object.dialog !== null)
      ? Dialog.fromPartial(object.dialog)
      : undefined;
    message.hide = object.hide ?? false;
    return message;
  },
};

function createBaseTimestamp(): Timestamp {
  return { seconds: 0n, nanos: 0 };
}

export const Timestamp: MessageFns<Timestamp> = {
  encode(message: Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== 0n) {
      if (BigInt.asIntN(64, message.seconds) !== message.seconds) {
        throw new globalThis.Error("value provided for field message.seconds of type int64 too large");
      }
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seconds = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Timestamp {
    return {
      seconds: isSet(object.seconds) ? BigInt(object.seconds) : 0n,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: Timestamp): unknown {
    const obj: any = {};
    if (message.seconds !== 0n) {
      obj.seconds = message.seconds.toString();
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Timestamp>, I>>(base?: I): Timestamp {
    return Timestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(object: I): Timestamp {
    const message = createBaseTimestamp();
    message.seconds = object.seconds ?? 0n;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
