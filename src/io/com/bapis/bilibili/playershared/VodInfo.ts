// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/playershared/VodInfo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bilibili.playershared";

/** 播放页信息-响应: VOD音视频信息 */
export interface VodInfo {
  /** 视频清晰度 */
  quality: number;
  /** 视频格式 */
  format: string;
  /** 视频时长 */
  timelength: bigint;
  /** 视频编码id */
  videoCodecid: number;
  /** 视频流 */
  streamList: Stream[];
  /** 伴音流 */
  dashAudio: DashItem[];
  /** 杜比伴音流 */
  dolby?:
    | DolbyItem
    | undefined;
  /** 响度均衡操作信息 */
  volume?:
    | VolumeInfo
    | undefined;
  /** HIRES伴音流信息 */
  lossLessItem?:
    | LossLessItem
    | undefined;
  /** 是否支持投屏 */
  supportProject?: boolean | undefined;
}

/** 视频流信息 */
export interface Stream {
  /** 元数据 */
  streamInfo:
    | StreamInfo
    | undefined;
  /** dash流 */
  dashVideo?:
    | DashVideo
    | undefined;
  /** 分段流 */
  segmentVideo?: SegmentVideo | undefined;
}

/** 视频流信息: 元数据 */
export interface StreamInfo {
  /** 清晰度 */
  quality: number;
  /** 格式 */
  format: string;
  /** 格式描述 */
  description: string;
  /** 错误码 */
  errCode?:
    | number
    | undefined;
  /** 不满足条件信息 */
  limit:
    | StreamLimit
    | undefined;
  /** 是否需要vip */
  needVip: boolean;
  /** 是否需要登录 */
  needLogin: boolean;
  /** 是否完整 */
  intact: boolean;
  /** 是否非全二压 */
  noRexcode?:
    | boolean
    | undefined;
  /** 清晰度属性位 */
  attribute?:
    | bigint
    | undefined;
  /** 新版格式描述 */
  newDescription: string;
  /** 格式文字 */
  displayDesc: string;
  /** 新版格式描述备注 */
  superscript: string;
  vipFree?: boolean | undefined;
  subtitle?:
    | string
    | undefined;
  /** 方案 */
  scheme:
    | Scheme
    | undefined;
  /** 支持drm */
  supportDrm: boolean;
}

/** 视频流信息: 流媒体元数据: 清晰度不满足条件信息 */
export interface StreamLimit {
  /** 标题 */
  title: string;
  /** 跳转地址 */
  uri: string;
  /** 提示信息 */
  msg: string;
}

/** 方案 */
export interface Scheme {
  actionType: Scheme_ActionType;
  toast: string;
}

export enum Scheme_ActionType {
  UNKNOWN = 0,
  SHOW_TOAST = 1,
  UNRECOGNIZED = -1,
}

export function scheme_ActionTypeFromJSON(object: any): Scheme_ActionType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Scheme_ActionType.UNKNOWN;
    case 1:
    case "SHOW_TOAST":
      return Scheme_ActionType.SHOW_TOAST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scheme_ActionType.UNRECOGNIZED;
  }
}

export function scheme_ActionTypeToJSON(object: Scheme_ActionType): string {
  switch (object) {
    case Scheme_ActionType.UNKNOWN:
      return "UNKNOWN";
    case Scheme_ActionType.SHOW_TOAST:
      return "SHOW_TOAST";
    case Scheme_ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 视频流信息: dash流 */
export interface DashVideo {
  /** 主线流 */
  baseUrl: string;
  /** 备用流 */
  backupUrl: string[];
  /** 带宽 */
  bandwidth: number;
  /** 编码id */
  codecid: number;
  /** md5 */
  md5?:
    | string
    | undefined;
  /** 大小 */
  size: bigint;
  /** 伴音质量id */
  audioId: number;
  /** 是否非全二压 */
  noRexcode?:
    | boolean
    | undefined;
  /** 帧率 */
  frameRate: string;
  /** 宽 */
  width: number;
  /** 高 */
  height: number;
  /** DRM密钥 */
  widevinePssh?: string | undefined;
}

/** 视频流信息: 分段流 */
export interface SegmentVideo {
  segment: ResponseUrl[];
}

/** 分段流条目 */
export interface ResponseUrl {
  /** 分段序号 */
  order: number;
  /** 分段时长 */
  length: bigint;
  /** 分段大小 */
  size: bigint;
  /** 主线流 */
  url: string;
  /** 备用流 */
  backupUrl: string[];
  /** md5 */
  md5?: string | undefined;
}

/** Dash条目 */
export interface DashItem {
  /** 清晰度 */
  id: number;
  /** 主线流 */
  baseUrl: string;
  /** 备用流 */
  backupUrl: string[];
  /** 带宽 */
  bandwidth: number;
  /** 编码id */
  codecid?:
    | number
    | undefined;
  /** md5 */
  md5?:
    | string
    | undefined;
  /** 大小 */
  size: bigint;
  /** 帧率 */
  frameRate?:
    | string
    | undefined;
  /** DRM密钥 */
  widevinePssh?: string | undefined;
}

/** 杜比伴音流信息 */
export interface DolbyItem {
  /** 杜比类型 */
  type: DolbyItem_Type;
  /** 音频流 */
  audio: DashItem[];
}

/** 杜比类型 */
export enum DolbyItem_Type {
  /** NONE - NONE */
  NONE = 0,
  /** COMMON - 普通杜比音效 */
  COMMON = 1,
  /** ATMOS - 全景杜比音效 */
  ATMOS = 2,
  UNRECOGNIZED = -1,
}

export function dolbyItem_TypeFromJSON(object: any): DolbyItem_Type {
  switch (object) {
    case 0:
    case "NONE":
      return DolbyItem_Type.NONE;
    case 1:
    case "COMMON":
      return DolbyItem_Type.COMMON;
    case 2:
    case "ATMOS":
      return DolbyItem_Type.ATMOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DolbyItem_Type.UNRECOGNIZED;
  }
}

export function dolbyItem_TypeToJSON(object: DolbyItem_Type): string {
  switch (object) {
    case DolbyItem_Type.NONE:
      return "NONE";
    case DolbyItem_Type.COMMON:
      return "COMMON";
    case DolbyItem_Type.ATMOS:
      return "ATMOS";
    case DolbyItem_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 响度均衡操作信息 */
export interface VolumeInfo {
  /** Measured integrated loudness 实际综合响度 */
  measuredI: number;
  /** Measured loudness range 实际响度范围 */
  measuredLra: number;
  /** Measured true peak 实际响度真峰值 */
  measuredTp: number;
  /** Measured threshold 实际响度阈值 */
  measuredThreshold: number;
  /** Target offset gain(Gain is applied before the true-peak limiter) 目标增益Offset(增益在真实峰值限制器之前应用) */
  targetOffset: number;
  /** Target integrated loudness 目标综合响度 */
  targetI: number;
  /** Target true peak 目标响度真峰值 */
  targetTp: number;
}

/** HIRES伴音流信息 */
export interface LossLessItem {
  /** 是否为hires */
  isLosslessAudio: boolean;
  /** 音频流信息 */
  audio:
    | DashItem
    | undefined;
  /** 是否需要大会员 */
  needVip: boolean;
}

function createBaseVodInfo(): VodInfo {
  return { quality: 0, format: "", timelength: 0n, videoCodecid: 0, streamList: [], dashAudio: [] };
}

export const VodInfo: MessageFns<VodInfo> = {
  encode(message: VodInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quality !== 0) {
      writer.uint32(8).uint32(message.quality);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.timelength !== 0n) {
      if (BigInt.asUintN(64, message.timelength) !== message.timelength) {
        throw new globalThis.Error("value provided for field message.timelength of type uint64 too large");
      }
      writer.uint32(24).uint64(message.timelength);
    }
    if (message.videoCodecid !== 0) {
      writer.uint32(32).uint32(message.videoCodecid);
    }
    for (const v of message.streamList) {
      Stream.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.dashAudio) {
      DashItem.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.dolby !== undefined) {
      DolbyItem.encode(message.dolby, writer.uint32(58).fork()).join();
    }
    if (message.volume !== undefined) {
      VolumeInfo.encode(message.volume, writer.uint32(66).fork()).join();
    }
    if (message.lossLessItem !== undefined) {
      LossLessItem.encode(message.lossLessItem, writer.uint32(74).fork()).join();
    }
    if (message.supportProject !== undefined) {
      writer.uint32(80).bool(message.supportProject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timelength = reader.uint64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.videoCodecid = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.streamList.push(Stream.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dashAudio.push(DashItem.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dolby = DolbyItem.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.volume = VolumeInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lossLessItem = LossLessItem.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.supportProject = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodInfo {
    return {
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      timelength: isSet(object.timelength) ? BigInt(object.timelength) : 0n,
      videoCodecid: isSet(object.videoCodecid) ? globalThis.Number(object.videoCodecid) : 0,
      streamList: globalThis.Array.isArray(object?.streamList)
        ? object.streamList.map((e: any) => Stream.fromJSON(e))
        : [],
      dashAudio: globalThis.Array.isArray(object?.dashAudio)
        ? object.dashAudio.map((e: any) => DashItem.fromJSON(e))
        : [],
      dolby: isSet(object.dolby) ? DolbyItem.fromJSON(object.dolby) : undefined,
      volume: isSet(object.volume) ? VolumeInfo.fromJSON(object.volume) : undefined,
      lossLessItem: isSet(object.lossLessItem) ? LossLessItem.fromJSON(object.lossLessItem) : undefined,
      supportProject: isSet(object.supportProject) ? globalThis.Boolean(object.supportProject) : undefined,
    };
  },

  toJSON(message: VodInfo): unknown {
    const obj: any = {};
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.timelength !== 0n) {
      obj.timelength = message.timelength.toString();
    }
    if (message.videoCodecid !== 0) {
      obj.videoCodecid = Math.round(message.videoCodecid);
    }
    if (message.streamList?.length) {
      obj.streamList = message.streamList.map((e) => Stream.toJSON(e));
    }
    if (message.dashAudio?.length) {
      obj.dashAudio = message.dashAudio.map((e) => DashItem.toJSON(e));
    }
    if (message.dolby !== undefined) {
      obj.dolby = DolbyItem.toJSON(message.dolby);
    }
    if (message.volume !== undefined) {
      obj.volume = VolumeInfo.toJSON(message.volume);
    }
    if (message.lossLessItem !== undefined) {
      obj.lossLessItem = LossLessItem.toJSON(message.lossLessItem);
    }
    if (message.supportProject !== undefined) {
      obj.supportProject = message.supportProject;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VodInfo>, I>>(base?: I): VodInfo {
    return VodInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VodInfo>, I>>(object: I): VodInfo {
    const message = createBaseVodInfo();
    message.quality = object.quality ?? 0;
    message.format = object.format ?? "";
    message.timelength = object.timelength ?? 0n;
    message.videoCodecid = object.videoCodecid ?? 0;
    message.streamList = object.streamList?.map((e) => Stream.fromPartial(e)) || [];
    message.dashAudio = object.dashAudio?.map((e) => DashItem.fromPartial(e)) || [];
    message.dolby = (object.dolby !== undefined && object.dolby !== null)
      ? DolbyItem.fromPartial(object.dolby)
      : undefined;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? VolumeInfo.fromPartial(object.volume)
      : undefined;
    message.lossLessItem = (object.lossLessItem !== undefined && object.lossLessItem !== null)
      ? LossLessItem.fromPartial(object.lossLessItem)
      : undefined;
    message.supportProject = object.supportProject ?? undefined;
    return message;
  },
};

function createBaseStream(): Stream {
  return { streamInfo: undefined };
}

export const Stream: MessageFns<Stream> = {
  encode(message: Stream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamInfo !== undefined) {
      StreamInfo.encode(message.streamInfo, writer.uint32(10).fork()).join();
    }
    if (message.dashVideo !== undefined) {
      DashVideo.encode(message.dashVideo, writer.uint32(18).fork()).join();
    }
    if (message.segmentVideo !== undefined) {
      SegmentVideo.encode(message.segmentVideo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamInfo = StreamInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dashVideo = DashVideo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.segmentVideo = SegmentVideo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream {
    return {
      streamInfo: isSet(object.streamInfo) ? StreamInfo.fromJSON(object.streamInfo) : undefined,
      dashVideo: isSet(object.dashVideo) ? DashVideo.fromJSON(object.dashVideo) : undefined,
      segmentVideo: isSet(object.segmentVideo) ? SegmentVideo.fromJSON(object.segmentVideo) : undefined,
    };
  },

  toJSON(message: Stream): unknown {
    const obj: any = {};
    if (message.streamInfo !== undefined) {
      obj.streamInfo = StreamInfo.toJSON(message.streamInfo);
    }
    if (message.dashVideo !== undefined) {
      obj.dashVideo = DashVideo.toJSON(message.dashVideo);
    }
    if (message.segmentVideo !== undefined) {
      obj.segmentVideo = SegmentVideo.toJSON(message.segmentVideo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stream>, I>>(base?: I): Stream {
    return Stream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stream>, I>>(object: I): Stream {
    const message = createBaseStream();
    message.streamInfo = (object.streamInfo !== undefined && object.streamInfo !== null)
      ? StreamInfo.fromPartial(object.streamInfo)
      : undefined;
    message.dashVideo = (object.dashVideo !== undefined && object.dashVideo !== null)
      ? DashVideo.fromPartial(object.dashVideo)
      : undefined;
    message.segmentVideo = (object.segmentVideo !== undefined && object.segmentVideo !== null)
      ? SegmentVideo.fromPartial(object.segmentVideo)
      : undefined;
    return message;
  },
};

function createBaseStreamInfo(): StreamInfo {
  return {
    quality: 0,
    format: "",
    description: "",
    limit: undefined,
    needVip: false,
    needLogin: false,
    intact: false,
    newDescription: "",
    displayDesc: "",
    superscript: "",
    scheme: undefined,
    supportDrm: false,
  };
}

export const StreamInfo: MessageFns<StreamInfo> = {
  encode(message: StreamInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quality !== 0) {
      writer.uint32(8).uint32(message.quality);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.errCode !== undefined) {
      writer.uint32(32).uint32(message.errCode);
    }
    if (message.limit !== undefined) {
      StreamLimit.encode(message.limit, writer.uint32(42).fork()).join();
    }
    if (message.needVip !== false) {
      writer.uint32(48).bool(message.needVip);
    }
    if (message.needLogin !== false) {
      writer.uint32(56).bool(message.needLogin);
    }
    if (message.intact !== false) {
      writer.uint32(64).bool(message.intact);
    }
    if (message.noRexcode !== undefined) {
      writer.uint32(72).bool(message.noRexcode);
    }
    if (message.attribute !== undefined) {
      if (BigInt.asIntN(64, message.attribute) !== message.attribute) {
        throw new globalThis.Error("value provided for field message.attribute of type int64 too large");
      }
      writer.uint32(80).int64(message.attribute);
    }
    if (message.newDescription !== "") {
      writer.uint32(90).string(message.newDescription);
    }
    if (message.displayDesc !== "") {
      writer.uint32(98).string(message.displayDesc);
    }
    if (message.superscript !== "") {
      writer.uint32(106).string(message.superscript);
    }
    if (message.vipFree !== undefined) {
      writer.uint32(112).bool(message.vipFree);
    }
    if (message.subtitle !== undefined) {
      writer.uint32(122).string(message.subtitle);
    }
    if (message.scheme !== undefined) {
      Scheme.encode(message.scheme, writer.uint32(130).fork()).join();
    }
    if (message.supportDrm !== false) {
      writer.uint32(136).bool(message.supportDrm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.errCode = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.limit = StreamLimit.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.needVip = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.needLogin = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.intact = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.noRexcode = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.attribute = reader.int64() as bigint;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.newDescription = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.displayDesc = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.superscript = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.vipFree = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.subtitle = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.scheme = Scheme.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.supportDrm = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamInfo {
    return {
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      errCode: isSet(object.errCode) ? globalThis.Number(object.errCode) : undefined,
      limit: isSet(object.limit) ? StreamLimit.fromJSON(object.limit) : undefined,
      needVip: isSet(object.needVip) ? globalThis.Boolean(object.needVip) : false,
      needLogin: isSet(object.needLogin) ? globalThis.Boolean(object.needLogin) : false,
      intact: isSet(object.intact) ? globalThis.Boolean(object.intact) : false,
      noRexcode: isSet(object.noRexcode) ? globalThis.Boolean(object.noRexcode) : undefined,
      attribute: isSet(object.attribute) ? BigInt(object.attribute) : undefined,
      newDescription: isSet(object.newDescription) ? globalThis.String(object.newDescription) : "",
      displayDesc: isSet(object.displayDesc) ? globalThis.String(object.displayDesc) : "",
      superscript: isSet(object.superscript) ? globalThis.String(object.superscript) : "",
      vipFree: isSet(object.vipFree) ? globalThis.Boolean(object.vipFree) : undefined,
      subtitle: isSet(object.subtitle) ? globalThis.String(object.subtitle) : undefined,
      scheme: isSet(object.scheme) ? Scheme.fromJSON(object.scheme) : undefined,
      supportDrm: isSet(object.supportDrm) ? globalThis.Boolean(object.supportDrm) : false,
    };
  },

  toJSON(message: StreamInfo): unknown {
    const obj: any = {};
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.errCode !== undefined) {
      obj.errCode = Math.round(message.errCode);
    }
    if (message.limit !== undefined) {
      obj.limit = StreamLimit.toJSON(message.limit);
    }
    if (message.needVip !== false) {
      obj.needVip = message.needVip;
    }
    if (message.needLogin !== false) {
      obj.needLogin = message.needLogin;
    }
    if (message.intact !== false) {
      obj.intact = message.intact;
    }
    if (message.noRexcode !== undefined) {
      obj.noRexcode = message.noRexcode;
    }
    if (message.attribute !== undefined) {
      obj.attribute = message.attribute.toString();
    }
    if (message.newDescription !== "") {
      obj.newDescription = message.newDescription;
    }
    if (message.displayDesc !== "") {
      obj.displayDesc = message.displayDesc;
    }
    if (message.superscript !== "") {
      obj.superscript = message.superscript;
    }
    if (message.vipFree !== undefined) {
      obj.vipFree = message.vipFree;
    }
    if (message.subtitle !== undefined) {
      obj.subtitle = message.subtitle;
    }
    if (message.scheme !== undefined) {
      obj.scheme = Scheme.toJSON(message.scheme);
    }
    if (message.supportDrm !== false) {
      obj.supportDrm = message.supportDrm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamInfo>, I>>(base?: I): StreamInfo {
    return StreamInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamInfo>, I>>(object: I): StreamInfo {
    const message = createBaseStreamInfo();
    message.quality = object.quality ?? 0;
    message.format = object.format ?? "";
    message.description = object.description ?? "";
    message.errCode = object.errCode ?? undefined;
    message.limit = (object.limit !== undefined && object.limit !== null)
      ? StreamLimit.fromPartial(object.limit)
      : undefined;
    message.needVip = object.needVip ?? false;
    message.needLogin = object.needLogin ?? false;
    message.intact = object.intact ?? false;
    message.noRexcode = object.noRexcode ?? undefined;
    message.attribute = object.attribute ?? undefined;
    message.newDescription = object.newDescription ?? "";
    message.displayDesc = object.displayDesc ?? "";
    message.superscript = object.superscript ?? "";
    message.vipFree = object.vipFree ?? undefined;
    message.subtitle = object.subtitle ?? undefined;
    message.scheme = (object.scheme !== undefined && object.scheme !== null)
      ? Scheme.fromPartial(object.scheme)
      : undefined;
    message.supportDrm = object.supportDrm ?? false;
    return message;
  },
};

function createBaseStreamLimit(): StreamLimit {
  return { title: "", uri: "", msg: "" };
}

export const StreamLimit: MessageFns<StreamLimit> = {
  encode(message: StreamLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamLimit {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: StreamLimit): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamLimit>, I>>(base?: I): StreamLimit {
    return StreamLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamLimit>, I>>(object: I): StreamLimit {
    const message = createBaseStreamLimit();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseScheme(): Scheme {
  return { actionType: 0, toast: "" };
}

export const Scheme: MessageFns<Scheme> = {
  encode(message: Scheme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionType !== 0) {
      writer.uint32(8).int32(message.actionType);
    }
    if (message.toast !== "") {
      writer.uint32(18).string(message.toast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scheme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toast = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scheme {
    return {
      actionType: isSet(object.actionType) ? scheme_ActionTypeFromJSON(object.actionType) : 0,
      toast: isSet(object.toast) ? globalThis.String(object.toast) : "",
    };
  },

  toJSON(message: Scheme): unknown {
    const obj: any = {};
    if (message.actionType !== 0) {
      obj.actionType = scheme_ActionTypeToJSON(message.actionType);
    }
    if (message.toast !== "") {
      obj.toast = message.toast;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scheme>, I>>(base?: I): Scheme {
    return Scheme.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scheme>, I>>(object: I): Scheme {
    const message = createBaseScheme();
    message.actionType = object.actionType ?? 0;
    message.toast = object.toast ?? "";
    return message;
  },
};

function createBaseDashVideo(): DashVideo {
  return {
    baseUrl: "",
    backupUrl: [],
    bandwidth: 0,
    codecid: 0,
    size: 0n,
    audioId: 0,
    frameRate: "",
    width: 0,
    height: 0,
  };
}

export const DashVideo: MessageFns<DashVideo> = {
  encode(message: DashVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseUrl !== "") {
      writer.uint32(10).string(message.baseUrl);
    }
    for (const v of message.backupUrl) {
      writer.uint32(18).string(v!);
    }
    if (message.bandwidth !== 0) {
      writer.uint32(24).uint32(message.bandwidth);
    }
    if (message.codecid !== 0) {
      writer.uint32(32).uint32(message.codecid);
    }
    if (message.md5 !== undefined) {
      writer.uint32(42).string(message.md5);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(48).uint64(message.size);
    }
    if (message.audioId !== 0) {
      writer.uint32(56).uint32(message.audioId);
    }
    if (message.noRexcode !== undefined) {
      writer.uint32(64).bool(message.noRexcode);
    }
    if (message.frameRate !== "") {
      writer.uint32(74).string(message.frameRate);
    }
    if (message.width !== 0) {
      writer.uint32(80).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(88).int32(message.height);
    }
    if (message.widevinePssh !== undefined) {
      writer.uint32(98).string(message.widevinePssh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DashVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDashVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupUrl.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bandwidth = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.codecid = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.md5 = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.audioId = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.noRexcode = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.frameRate = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.widevinePssh = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DashVideo {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      backupUrl: globalThis.Array.isArray(object?.backupUrl)
        ? object.backupUrl.map((e: any) => globalThis.String(e))
        : [],
      bandwidth: isSet(object.bandwidth) ? globalThis.Number(object.bandwidth) : 0,
      codecid: isSet(object.codecid) ? globalThis.Number(object.codecid) : 0,
      md5: isSet(object.md5) ? globalThis.String(object.md5) : undefined,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      audioId: isSet(object.audioId) ? globalThis.Number(object.audioId) : 0,
      noRexcode: isSet(object.noRexcode) ? globalThis.Boolean(object.noRexcode) : undefined,
      frameRate: isSet(object.frameRate) ? globalThis.String(object.frameRate) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      widevinePssh: isSet(object.widevinePssh) ? globalThis.String(object.widevinePssh) : undefined,
    };
  },

  toJSON(message: DashVideo): unknown {
    const obj: any = {};
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.backupUrl?.length) {
      obj.backupUrl = message.backupUrl;
    }
    if (message.bandwidth !== 0) {
      obj.bandwidth = Math.round(message.bandwidth);
    }
    if (message.codecid !== 0) {
      obj.codecid = Math.round(message.codecid);
    }
    if (message.md5 !== undefined) {
      obj.md5 = message.md5;
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.audioId !== 0) {
      obj.audioId = Math.round(message.audioId);
    }
    if (message.noRexcode !== undefined) {
      obj.noRexcode = message.noRexcode;
    }
    if (message.frameRate !== "") {
      obj.frameRate = message.frameRate;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.widevinePssh !== undefined) {
      obj.widevinePssh = message.widevinePssh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DashVideo>, I>>(base?: I): DashVideo {
    return DashVideo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DashVideo>, I>>(object: I): DashVideo {
    const message = createBaseDashVideo();
    message.baseUrl = object.baseUrl ?? "";
    message.backupUrl = object.backupUrl?.map((e) => e) || [];
    message.bandwidth = object.bandwidth ?? 0;
    message.codecid = object.codecid ?? 0;
    message.md5 = object.md5 ?? undefined;
    message.size = object.size ?? 0n;
    message.audioId = object.audioId ?? 0;
    message.noRexcode = object.noRexcode ?? undefined;
    message.frameRate = object.frameRate ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.widevinePssh = object.widevinePssh ?? undefined;
    return message;
  },
};

function createBaseSegmentVideo(): SegmentVideo {
  return { segment: [] };
}

export const SegmentVideo: MessageFns<SegmentVideo> = {
  encode(message: SegmentVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.segment) {
      ResponseUrl.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segment.push(ResponseUrl.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentVideo {
    return {
      segment: globalThis.Array.isArray(object?.segment) ? object.segment.map((e: any) => ResponseUrl.fromJSON(e)) : [],
    };
  },

  toJSON(message: SegmentVideo): unknown {
    const obj: any = {};
    if (message.segment?.length) {
      obj.segment = message.segment.map((e) => ResponseUrl.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegmentVideo>, I>>(base?: I): SegmentVideo {
    return SegmentVideo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegmentVideo>, I>>(object: I): SegmentVideo {
    const message = createBaseSegmentVideo();
    message.segment = object.segment?.map((e) => ResponseUrl.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResponseUrl(): ResponseUrl {
  return { order: 0, length: 0n, size: 0n, url: "", backupUrl: [] };
}

export const ResponseUrl: MessageFns<ResponseUrl> = {
  encode(message: ResponseUrl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== 0) {
      writer.uint32(8).uint32(message.order);
    }
    if (message.length !== 0n) {
      if (BigInt.asUintN(64, message.length) !== message.length) {
        throw new globalThis.Error("value provided for field message.length of type uint64 too large");
      }
      writer.uint32(16).uint64(message.length);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(24).uint64(message.size);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    for (const v of message.backupUrl) {
      writer.uint32(42).string(v!);
    }
    if (message.md5 !== undefined) {
      writer.uint32(50).string(message.md5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseUrl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseUrl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.order = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.length = reader.uint64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.backupUrl.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.md5 = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseUrl {
    return {
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      length: isSet(object.length) ? BigInt(object.length) : 0n,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      backupUrl: globalThis.Array.isArray(object?.backupUrl)
        ? object.backupUrl.map((e: any) => globalThis.String(e))
        : [],
      md5: isSet(object.md5) ? globalThis.String(object.md5) : undefined,
    };
  },

  toJSON(message: ResponseUrl): unknown {
    const obj: any = {};
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.length !== 0n) {
      obj.length = message.length.toString();
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.backupUrl?.length) {
      obj.backupUrl = message.backupUrl;
    }
    if (message.md5 !== undefined) {
      obj.md5 = message.md5;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseUrl>, I>>(base?: I): ResponseUrl {
    return ResponseUrl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseUrl>, I>>(object: I): ResponseUrl {
    const message = createBaseResponseUrl();
    message.order = object.order ?? 0;
    message.length = object.length ?? 0n;
    message.size = object.size ?? 0n;
    message.url = object.url ?? "";
    message.backupUrl = object.backupUrl?.map((e) => e) || [];
    message.md5 = object.md5 ?? undefined;
    return message;
  },
};

function createBaseDashItem(): DashItem {
  return { id: 0, baseUrl: "", backupUrl: [], bandwidth: 0, size: 0n };
}

export const DashItem: MessageFns<DashItem> = {
  encode(message: DashItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    for (const v of message.backupUrl) {
      writer.uint32(26).string(v!);
    }
    if (message.bandwidth !== 0) {
      writer.uint32(32).uint32(message.bandwidth);
    }
    if (message.codecid !== undefined) {
      writer.uint32(40).uint32(message.codecid);
    }
    if (message.md5 !== undefined) {
      writer.uint32(50).string(message.md5);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(56).uint64(message.size);
    }
    if (message.frameRate !== undefined) {
      writer.uint32(66).string(message.frameRate);
    }
    if (message.widevinePssh !== undefined) {
      writer.uint32(74).string(message.widevinePssh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DashItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDashItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupUrl.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bandwidth = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.codecid = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.md5 = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.frameRate = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.widevinePssh = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DashItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      backupUrl: globalThis.Array.isArray(object?.backupUrl)
        ? object.backupUrl.map((e: any) => globalThis.String(e))
        : [],
      bandwidth: isSet(object.bandwidth) ? globalThis.Number(object.bandwidth) : 0,
      codecid: isSet(object.codecid) ? globalThis.Number(object.codecid) : undefined,
      md5: isSet(object.md5) ? globalThis.String(object.md5) : undefined,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      frameRate: isSet(object.frameRate) ? globalThis.String(object.frameRate) : undefined,
      widevinePssh: isSet(object.widevinePssh) ? globalThis.String(object.widevinePssh) : undefined,
    };
  },

  toJSON(message: DashItem): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.backupUrl?.length) {
      obj.backupUrl = message.backupUrl;
    }
    if (message.bandwidth !== 0) {
      obj.bandwidth = Math.round(message.bandwidth);
    }
    if (message.codecid !== undefined) {
      obj.codecid = Math.round(message.codecid);
    }
    if (message.md5 !== undefined) {
      obj.md5 = message.md5;
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.frameRate !== undefined) {
      obj.frameRate = message.frameRate;
    }
    if (message.widevinePssh !== undefined) {
      obj.widevinePssh = message.widevinePssh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DashItem>, I>>(base?: I): DashItem {
    return DashItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DashItem>, I>>(object: I): DashItem {
    const message = createBaseDashItem();
    message.id = object.id ?? 0;
    message.baseUrl = object.baseUrl ?? "";
    message.backupUrl = object.backupUrl?.map((e) => e) || [];
    message.bandwidth = object.bandwidth ?? 0;
    message.codecid = object.codecid ?? undefined;
    message.md5 = object.md5 ?? undefined;
    message.size = object.size ?? 0n;
    message.frameRate = object.frameRate ?? undefined;
    message.widevinePssh = object.widevinePssh ?? undefined;
    return message;
  },
};

function createBaseDolbyItem(): DolbyItem {
  return { type: 0, audio: [] };
}

export const DolbyItem: MessageFns<DolbyItem> = {
  encode(message: DolbyItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.audio) {
      DashItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DolbyItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDolbyItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio.push(DashItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DolbyItem {
    return {
      type: isSet(object.type) ? dolbyItem_TypeFromJSON(object.type) : 0,
      audio: globalThis.Array.isArray(object?.audio) ? object.audio.map((e: any) => DashItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: DolbyItem): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = dolbyItem_TypeToJSON(message.type);
    }
    if (message.audio?.length) {
      obj.audio = message.audio.map((e) => DashItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DolbyItem>, I>>(base?: I): DolbyItem {
    return DolbyItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DolbyItem>, I>>(object: I): DolbyItem {
    const message = createBaseDolbyItem();
    message.type = object.type ?? 0;
    message.audio = object.audio?.map((e) => DashItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVolumeInfo(): VolumeInfo {
  return {
    measuredI: 0,
    measuredLra: 0,
    measuredTp: 0,
    measuredThreshold: 0,
    targetOffset: 0,
    targetI: 0,
    targetTp: 0,
  };
}

export const VolumeInfo: MessageFns<VolumeInfo> = {
  encode(message: VolumeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measuredI !== 0) {
      writer.uint32(9).double(message.measuredI);
    }
    if (message.measuredLra !== 0) {
      writer.uint32(17).double(message.measuredLra);
    }
    if (message.measuredTp !== 0) {
      writer.uint32(25).double(message.measuredTp);
    }
    if (message.measuredThreshold !== 0) {
      writer.uint32(33).double(message.measuredThreshold);
    }
    if (message.targetOffset !== 0) {
      writer.uint32(41).double(message.targetOffset);
    }
    if (message.targetI !== 0) {
      writer.uint32(49).double(message.targetI);
    }
    if (message.targetTp !== 0) {
      writer.uint32(57).double(message.targetTp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.measuredI = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.measuredLra = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.measuredTp = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.measuredThreshold = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.targetOffset = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.targetI = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.targetTp = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeInfo {
    return {
      measuredI: isSet(object.measuredI) ? globalThis.Number(object.measuredI) : 0,
      measuredLra: isSet(object.measuredLra) ? globalThis.Number(object.measuredLra) : 0,
      measuredTp: isSet(object.measuredTp) ? globalThis.Number(object.measuredTp) : 0,
      measuredThreshold: isSet(object.measuredThreshold) ? globalThis.Number(object.measuredThreshold) : 0,
      targetOffset: isSet(object.targetOffset) ? globalThis.Number(object.targetOffset) : 0,
      targetI: isSet(object.targetI) ? globalThis.Number(object.targetI) : 0,
      targetTp: isSet(object.targetTp) ? globalThis.Number(object.targetTp) : 0,
    };
  },

  toJSON(message: VolumeInfo): unknown {
    const obj: any = {};
    if (message.measuredI !== 0) {
      obj.measuredI = message.measuredI;
    }
    if (message.measuredLra !== 0) {
      obj.measuredLra = message.measuredLra;
    }
    if (message.measuredTp !== 0) {
      obj.measuredTp = message.measuredTp;
    }
    if (message.measuredThreshold !== 0) {
      obj.measuredThreshold = message.measuredThreshold;
    }
    if (message.targetOffset !== 0) {
      obj.targetOffset = message.targetOffset;
    }
    if (message.targetI !== 0) {
      obj.targetI = message.targetI;
    }
    if (message.targetTp !== 0) {
      obj.targetTp = message.targetTp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VolumeInfo>, I>>(base?: I): VolumeInfo {
    return VolumeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VolumeInfo>, I>>(object: I): VolumeInfo {
    const message = createBaseVolumeInfo();
    message.measuredI = object.measuredI ?? 0;
    message.measuredLra = object.measuredLra ?? 0;
    message.measuredTp = object.measuredTp ?? 0;
    message.measuredThreshold = object.measuredThreshold ?? 0;
    message.targetOffset = object.targetOffset ?? 0;
    message.targetI = object.targetI ?? 0;
    message.targetTp = object.targetTp ?? 0;
    return message;
  },
};

function createBaseLossLessItem(): LossLessItem {
  return { isLosslessAudio: false, audio: undefined, needVip: false };
}

export const LossLessItem: MessageFns<LossLessItem> = {
  encode(message: LossLessItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isLosslessAudio !== false) {
      writer.uint32(8).bool(message.isLosslessAudio);
    }
    if (message.audio !== undefined) {
      DashItem.encode(message.audio, writer.uint32(18).fork()).join();
    }
    if (message.needVip !== false) {
      writer.uint32(24).bool(message.needVip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LossLessItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLossLessItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isLosslessAudio = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = DashItem.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.needVip = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LossLessItem {
    return {
      isLosslessAudio: isSet(object.isLosslessAudio) ? globalThis.Boolean(object.isLosslessAudio) : false,
      audio: isSet(object.audio) ? DashItem.fromJSON(object.audio) : undefined,
      needVip: isSet(object.needVip) ? globalThis.Boolean(object.needVip) : false,
    };
  },

  toJSON(message: LossLessItem): unknown {
    const obj: any = {};
    if (message.isLosslessAudio !== false) {
      obj.isLosslessAudio = message.isLosslessAudio;
    }
    if (message.audio !== undefined) {
      obj.audio = DashItem.toJSON(message.audio);
    }
    if (message.needVip !== false) {
      obj.needVip = message.needVip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LossLessItem>, I>>(base?: I): LossLessItem {
    return LossLessItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LossLessItem>, I>>(object: I): LossLessItem {
    const message = createBaseLossLessItem();
    message.isLosslessAudio = object.isLosslessAudio ?? false;
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? DashItem.fromPartial(object.audio)
      : undefined;
    message.needVip = object.needVip ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
