// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/playershared/PlayArc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bilibili.playershared";

export enum BizType {
  BIZ_TYPE_UNKNOWN = 0,
  BIZ_TYPE_UGC = 1,
  BIZ_TYPE_PGC = 2,
  BIZ_TYPE_PUGV = 3,
  UNRECOGNIZED = -1,
}

export function bizTypeFromJSON(object: any): BizType {
  switch (object) {
    case 0:
    case "BIZ_TYPE_UNKNOWN":
      return BizType.BIZ_TYPE_UNKNOWN;
    case 1:
    case "BIZ_TYPE_UGC":
      return BizType.BIZ_TYPE_UGC;
    case 2:
    case "BIZ_TYPE_PGC":
      return BizType.BIZ_TYPE_PGC;
    case 3:
    case "BIZ_TYPE_PUGV":
      return BizType.BIZ_TYPE_PUGV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BizType.UNRECOGNIZED;
  }
}

export function bizTypeToJSON(object: BizType): string {
  switch (object) {
    case BizType.BIZ_TYPE_UNKNOWN:
      return "BIZ_TYPE_UNKNOWN";
    case BizType.BIZ_TYPE_UGC:
      return "BIZ_TYPE_UGC";
    case BizType.BIZ_TYPE_PGC:
      return "BIZ_TYPE_PGC";
    case BizType.BIZ_TYPE_PUGV:
      return "BIZ_TYPE_PUGV";
    case BizType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DrmTechType {
  UNKNOWN_DRM = 0,
  FAIR_PLAY = 1,
  WIDE_VINE = 2,
  /** BILI_DRM - 哔哩哔哩自研DRM */
  BILI_DRM = 3,
  UNRECOGNIZED = -1,
}

export function drmTechTypeFromJSON(object: any): DrmTechType {
  switch (object) {
    case 0:
    case "UNKNOWN_DRM":
      return DrmTechType.UNKNOWN_DRM;
    case 1:
    case "FAIR_PLAY":
      return DrmTechType.FAIR_PLAY;
    case 2:
    case "WIDE_VINE":
      return DrmTechType.WIDE_VINE;
    case 3:
    case "BILI_DRM":
      return DrmTechType.BILI_DRM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DrmTechType.UNRECOGNIZED;
  }
}

export function drmTechTypeToJSON(object: DrmTechType): string {
  switch (object) {
    case DrmTechType.UNKNOWN_DRM:
      return "UNKNOWN_DRM";
    case DrmTechType.FAIR_PLAY:
      return "FAIR_PLAY";
    case DrmTechType.WIDE_VINE:
      return "WIDE_VINE";
    case DrmTechType.BILI_DRM:
      return "BILI_DRM";
    case DrmTechType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ArcType {
  ARC_TYPE_NORMAL = 0,
  ARC_TYPE_INTERACT = 1,
  UNRECOGNIZED = -1,
}

export function arcTypeFromJSON(object: any): ArcType {
  switch (object) {
    case 0:
    case "ARC_TYPE_NORMAL":
      return ArcType.ARC_TYPE_NORMAL;
    case 1:
    case "ARC_TYPE_INTERACT":
      return ArcType.ARC_TYPE_INTERACT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ArcType.UNRECOGNIZED;
  }
}

export function arcTypeToJSON(object: ArcType): string {
  switch (object) {
    case ArcType.ARC_TYPE_NORMAL:
      return "ARC_TYPE_NORMAL";
    case ArcType.ARC_TYPE_INTERACT:
      return "ARC_TYPE_INTERACT";
    case ArcType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlayArc {
  videoType: BizType;
  aid: bigint;
  cid: bigint;
  drmTechType?: DrmTechType | undefined;
  arcType?: ArcType | undefined;
  interaction?: Interaction | undefined;
  dimension: Dimension | undefined;
  duration: bigint;
  isPreview?: boolean | undefined;
  watchTimeLength: bigint;
  durationMs: bigint;
}

export interface Interaction {
  historyNode: Node | undefined;
  graphVersion: bigint;
  msg: string;
  mark: bigint;
}

export interface Node {
  nodeId: bigint;
  title: string;
  cid: bigint;
}

/** 当前分辨率信息 */
export interface Dimension {
  /** 宽 */
  width: number;
  /** 长 */
  height: number;
  /** 旋转角度 */
  rotate: number;
}

function createBasePlayArc(): PlayArc {
  return { videoType: 0, aid: 0n, cid: 0n, dimension: undefined, duration: 0n, watchTimeLength: 0n, durationMs: 0n };
}

export const PlayArc: MessageFns<PlayArc> = {
  encode(message: PlayArc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoType !== 0) {
      writer.uint32(8).int32(message.videoType);
    }
    if (message.aid !== 0n) {
      if (BigInt.asUintN(64, message.aid) !== message.aid) {
        throw new globalThis.Error("value provided for field message.aid of type uint64 too large");
      }
      writer.uint32(16).uint64(message.aid);
    }
    if (message.cid !== 0n) {
      if (BigInt.asUintN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type uint64 too large");
      }
      writer.uint32(24).uint64(message.cid);
    }
    if (message.drmTechType !== undefined) {
      writer.uint32(32).int32(message.drmTechType);
    }
    if (message.arcType !== undefined) {
      writer.uint32(40).int32(message.arcType);
    }
    if (message.interaction !== undefined) {
      Interaction.encode(message.interaction, writer.uint32(50).fork()).join();
    }
    if (message.dimension !== undefined) {
      Dimension.encode(message.dimension, writer.uint32(58).fork()).join();
    }
    if (message.duration !== 0n) {
      if (BigInt.asIntN(64, message.duration) !== message.duration) {
        throw new globalThis.Error("value provided for field message.duration of type int64 too large");
      }
      writer.uint32(64).int64(message.duration);
    }
    if (message.isPreview !== undefined) {
      writer.uint32(72).bool(message.isPreview);
    }
    if (message.watchTimeLength !== 0n) {
      if (BigInt.asIntN(64, message.watchTimeLength) !== message.watchTimeLength) {
        throw new globalThis.Error("value provided for field message.watchTimeLength of type int64 too large");
      }
      writer.uint32(80).int64(message.watchTimeLength);
    }
    if (message.durationMs !== 0n) {
      if (BigInt.asIntN(64, message.durationMs) !== message.durationMs) {
        throw new globalThis.Error("value provided for field message.durationMs of type int64 too large");
      }
      writer.uint32(88).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayArc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayArc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.videoType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.aid = reader.uint64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cid = reader.uint64() as bigint;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.drmTechType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.arcType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.interaction = Interaction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dimension = Dimension.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.duration = reader.int64() as bigint;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isPreview = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.watchTimeLength = reader.int64() as bigint;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.durationMs = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayArc {
    return {
      videoType: isSet(object.videoType) ? bizTypeFromJSON(object.videoType) : 0,
      aid: isSet(object.aid) ? BigInt(object.aid) : 0n,
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
      drmTechType: isSet(object.drmTechType) ? drmTechTypeFromJSON(object.drmTechType) : undefined,
      arcType: isSet(object.arcType) ? arcTypeFromJSON(object.arcType) : undefined,
      interaction: isSet(object.interaction) ? Interaction.fromJSON(object.interaction) : undefined,
      dimension: isSet(object.dimension) ? Dimension.fromJSON(object.dimension) : undefined,
      duration: isSet(object.duration) ? BigInt(object.duration) : 0n,
      isPreview: isSet(object.isPreview) ? globalThis.Boolean(object.isPreview) : undefined,
      watchTimeLength: isSet(object.watchTimeLength) ? BigInt(object.watchTimeLength) : 0n,
      durationMs: isSet(object.durationMs) ? BigInt(object.durationMs) : 0n,
    };
  },

  toJSON(message: PlayArc): unknown {
    const obj: any = {};
    if (message.videoType !== 0) {
      obj.videoType = bizTypeToJSON(message.videoType);
    }
    if (message.aid !== 0n) {
      obj.aid = message.aid.toString();
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    if (message.drmTechType !== undefined) {
      obj.drmTechType = drmTechTypeToJSON(message.drmTechType);
    }
    if (message.arcType !== undefined) {
      obj.arcType = arcTypeToJSON(message.arcType);
    }
    if (message.interaction !== undefined) {
      obj.interaction = Interaction.toJSON(message.interaction);
    }
    if (message.dimension !== undefined) {
      obj.dimension = Dimension.toJSON(message.dimension);
    }
    if (message.duration !== 0n) {
      obj.duration = message.duration.toString();
    }
    if (message.isPreview !== undefined) {
      obj.isPreview = message.isPreview;
    }
    if (message.watchTimeLength !== 0n) {
      obj.watchTimeLength = message.watchTimeLength.toString();
    }
    if (message.durationMs !== 0n) {
      obj.durationMs = message.durationMs.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayArc>, I>>(base?: I): PlayArc {
    return PlayArc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayArc>, I>>(object: I): PlayArc {
    const message = createBasePlayArc();
    message.videoType = object.videoType ?? 0;
    message.aid = object.aid ?? 0n;
    message.cid = object.cid ?? 0n;
    message.drmTechType = object.drmTechType ?? undefined;
    message.arcType = object.arcType ?? undefined;
    message.interaction = (object.interaction !== undefined && object.interaction !== null)
      ? Interaction.fromPartial(object.interaction)
      : undefined;
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? Dimension.fromPartial(object.dimension)
      : undefined;
    message.duration = object.duration ?? 0n;
    message.isPreview = object.isPreview ?? undefined;
    message.watchTimeLength = object.watchTimeLength ?? 0n;
    message.durationMs = object.durationMs ?? 0n;
    return message;
  },
};

function createBaseInteraction(): Interaction {
  return { historyNode: undefined, graphVersion: 0n, msg: "", mark: 0n };
}

export const Interaction: MessageFns<Interaction> = {
  encode(message: Interaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.historyNode !== undefined) {
      Node.encode(message.historyNode, writer.uint32(10).fork()).join();
    }
    if (message.graphVersion !== 0n) {
      if (BigInt.asIntN(64, message.graphVersion) !== message.graphVersion) {
        throw new globalThis.Error("value provided for field message.graphVersion of type int64 too large");
      }
      writer.uint32(16).int64(message.graphVersion);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    if (message.mark !== 0n) {
      if (BigInt.asIntN(64, message.mark) !== message.mark) {
        throw new globalThis.Error("value provided for field message.mark of type int64 too large");
      }
      writer.uint32(32).int64(message.mark);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.historyNode = Node.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.graphVersion = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mark = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interaction {
    return {
      historyNode: isSet(object.historyNode) ? Node.fromJSON(object.historyNode) : undefined,
      graphVersion: isSet(object.graphVersion) ? BigInt(object.graphVersion) : 0n,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      mark: isSet(object.mark) ? BigInt(object.mark) : 0n,
    };
  },

  toJSON(message: Interaction): unknown {
    const obj: any = {};
    if (message.historyNode !== undefined) {
      obj.historyNode = Node.toJSON(message.historyNode);
    }
    if (message.graphVersion !== 0n) {
      obj.graphVersion = message.graphVersion.toString();
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.mark !== 0n) {
      obj.mark = message.mark.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Interaction>, I>>(base?: I): Interaction {
    return Interaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Interaction>, I>>(object: I): Interaction {
    const message = createBaseInteraction();
    message.historyNode = (object.historyNode !== undefined && object.historyNode !== null)
      ? Node.fromPartial(object.historyNode)
      : undefined;
    message.graphVersion = object.graphVersion ?? 0n;
    message.msg = object.msg ?? "";
    message.mark = object.mark ?? 0n;
    return message;
  },
};

function createBaseNode(): Node {
  return { nodeId: 0n, title: "", cid: 0n };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== 0n) {
      if (BigInt.asIntN(64, message.nodeId) !== message.nodeId) {
        throw new globalThis.Error("value provided for field message.nodeId of type int64 too large");
      }
      writer.uint32(8).int64(message.nodeId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.cid !== 0n) {
      if (BigInt.asIntN(64, message.cid) !== message.cid) {
        throw new globalThis.Error("value provided for field message.cid of type int64 too large");
      }
      writer.uint32(24).int64(message.cid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cid = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      nodeId: isSet(object.nodeId) ? BigInt(object.nodeId) : 0n,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      cid: isSet(object.cid) ? BigInt(object.cid) : 0n,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.nodeId !== 0n) {
      obj.nodeId = message.nodeId.toString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.cid !== 0n) {
      obj.cid = message.cid.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.nodeId = object.nodeId ?? 0n;
    message.title = object.title ?? "";
    message.cid = object.cid ?? 0n;
    return message;
  },
};

function createBaseDimension(): Dimension {
  return { width: 0, height: 0, rotate: 0 };
}

export const Dimension: MessageFns<Dimension> = {
  encode(message: Dimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.rotate !== 0) {
      writer.uint32(24).int32(message.rotate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rotate = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimension {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      rotate: isSet(object.rotate) ? globalThis.Number(object.rotate) : 0,
    };
  },

  toJSON(message: Dimension): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.rotate !== 0) {
      obj.rotate = Math.round(message.rotate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dimension>, I>>(base?: I): Dimension {
    return Dimension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dimension>, I>>(object: I): Dimension {
    const message = createBaseDimension();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.rotate = object.rotate ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
