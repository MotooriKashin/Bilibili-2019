// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.2
// source: src/io/com/bapis/bilibili/playershared/ViewInfo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bilibili.playershared";

export enum GuideStyle {
  STYLE_UNKNOWN = 0,
  HORIZONTAL_IMAGE = 1,
  VERTICAL_TEXT = 2,
  SIMPLE_TEXT = 3,
  CHARGING_TEXT = 4,
  UNRECOGNIZED = -1,
}

export function guideStyleFromJSON(object: any): GuideStyle {
  switch (object) {
    case 0:
    case "STYLE_UNKNOWN":
      return GuideStyle.STYLE_UNKNOWN;
    case 1:
    case "HORIZONTAL_IMAGE":
      return GuideStyle.HORIZONTAL_IMAGE;
    case 2:
    case "VERTICAL_TEXT":
      return GuideStyle.VERTICAL_TEXT;
    case 3:
    case "SIMPLE_TEXT":
      return GuideStyle.SIMPLE_TEXT;
    case 4:
    case "CHARGING_TEXT":
      return GuideStyle.CHARGING_TEXT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GuideStyle.UNRECOGNIZED;
  }
}

export function guideStyleToJSON(object: GuideStyle): string {
  switch (object) {
    case GuideStyle.STYLE_UNKNOWN:
      return "STYLE_UNKNOWN";
    case GuideStyle.HORIZONTAL_IMAGE:
      return "HORIZONTAL_IMAGE";
    case GuideStyle.VERTICAL_TEXT:
      return "VERTICAL_TEXT";
    case GuideStyle.SIMPLE_TEXT:
      return "SIMPLE_TEXT";
    case GuideStyle.CHARGING_TEXT:
      return "CHARGING_TEXT";
    case GuideStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ButtonAction {
  BUTTON_UNKNOWN = 0,
  PAY = 1,
  VIP = 2,
  PACK = 3,
  LINK = 4,
  COUPON = 5,
  DEMAND = 6,
  DEMAND_PACK = 7,
  FOLLOW = 8,
  APPOINTMENT = 9,
  VIP_FREE = 10,
  TASK = 11,
  CHARGINGPLUS = 12,
  BP = 13,
  PRE_SELL = 14,
  LOGIN = 15,
  UNRECOGNIZED = -1,
}

export function buttonActionFromJSON(object: any): ButtonAction {
  switch (object) {
    case 0:
    case "BUTTON_UNKNOWN":
      return ButtonAction.BUTTON_UNKNOWN;
    case 1:
    case "PAY":
      return ButtonAction.PAY;
    case 2:
    case "VIP":
      return ButtonAction.VIP;
    case 3:
    case "PACK":
      return ButtonAction.PACK;
    case 4:
    case "LINK":
      return ButtonAction.LINK;
    case 5:
    case "COUPON":
      return ButtonAction.COUPON;
    case 6:
    case "DEMAND":
      return ButtonAction.DEMAND;
    case 7:
    case "DEMAND_PACK":
      return ButtonAction.DEMAND_PACK;
    case 8:
    case "FOLLOW":
      return ButtonAction.FOLLOW;
    case 9:
    case "APPOINTMENT":
      return ButtonAction.APPOINTMENT;
    case 10:
    case "VIP_FREE":
      return ButtonAction.VIP_FREE;
    case 11:
    case "TASK":
      return ButtonAction.TASK;
    case 12:
    case "CHARGINGPLUS":
      return ButtonAction.CHARGINGPLUS;
    case 13:
    case "BP":
      return ButtonAction.BP;
    case 14:
    case "PRE_SELL":
      return ButtonAction.PRE_SELL;
    case 15:
    case "LOGIN":
      return ButtonAction.LOGIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ButtonAction.UNRECOGNIZED;
  }
}

export function buttonActionToJSON(object: ButtonAction): string {
  switch (object) {
    case ButtonAction.BUTTON_UNKNOWN:
      return "BUTTON_UNKNOWN";
    case ButtonAction.PAY:
      return "PAY";
    case ButtonAction.VIP:
      return "VIP";
    case ButtonAction.PACK:
      return "PACK";
    case ButtonAction.LINK:
      return "LINK";
    case ButtonAction.COUPON:
      return "COUPON";
    case ButtonAction.DEMAND:
      return "DEMAND";
    case ButtonAction.DEMAND_PACK:
      return "DEMAND_PACK";
    case ButtonAction.FOLLOW:
      return "FOLLOW";
    case ButtonAction.APPOINTMENT:
      return "APPOINTMENT";
    case ButtonAction.VIP_FREE:
      return "VIP_FREE";
    case ButtonAction.TASK:
      return "TASK";
    case ButtonAction.CHARGINGPLUS:
      return "CHARGINGPLUS";
    case ButtonAction.BP:
      return "BP";
    case ButtonAction.PRE_SELL:
      return "PRE_SELL";
    case ButtonAction.LOGIN:
      return "LOGIN";
    case ButtonAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExtDataType {
  EXT_DATA_TYPE_UNKNOWN = 0,
  PLAY_LIST = 1,
  UNRECOGNIZED = -1,
}

export function extDataTypeFromJSON(object: any): ExtDataType {
  switch (object) {
    case 0:
    case "EXT_DATA_TYPE_UNKNOWN":
      return ExtDataType.EXT_DATA_TYPE_UNKNOWN;
    case 1:
    case "PLAY_LIST":
      return ExtDataType.PLAY_LIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExtDataType.UNRECOGNIZED;
  }
}

export function extDataTypeToJSON(object: ExtDataType): string {
  switch (object) {
    case ExtDataType.EXT_DATA_TYPE_UNKNOWN:
      return "EXT_DATA_TYPE_UNKNOWN";
    case ExtDataType.PLAY_LIST:
      return "PLAY_LIST";
    case ExtDataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LimitActionType {
  LAT_UNKNOWN = 0,
  SHOW_LIMIT_DIALOG = 1,
  SKIP_CURRENT_EP = 2,
  UNRECOGNIZED = -1,
}

export function limitActionTypeFromJSON(object: any): LimitActionType {
  switch (object) {
    case 0:
    case "LAT_UNKNOWN":
      return LimitActionType.LAT_UNKNOWN;
    case 1:
    case "SHOW_LIMIT_DIALOG":
      return LimitActionType.SHOW_LIMIT_DIALOG;
    case 2:
    case "SKIP_CURRENT_EP":
      return LimitActionType.SKIP_CURRENT_EP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LimitActionType.UNRECOGNIZED;
  }
}

export function limitActionTypeToJSON(object: LimitActionType): string {
  switch (object) {
    case LimitActionType.LAT_UNKNOWN:
      return "LAT_UNKNOWN";
    case LimitActionType.SHOW_LIMIT_DIALOG:
      return "SHOW_LIMIT_DIALOG";
    case LimitActionType.SKIP_CURRENT_EP:
      return "SKIP_CURRENT_EP";
    case LimitActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PromptBarType {
  PROMPT_BAR_TYPE_UNKNOWN = 0,
  OPEN_PROMPT_BAR = 1,
  UNRECOGNIZED = -1,
}

export function promptBarTypeFromJSON(object: any): PromptBarType {
  switch (object) {
    case 0:
    case "PROMPT_BAR_TYPE_UNKNOWN":
      return PromptBarType.PROMPT_BAR_TYPE_UNKNOWN;
    case 1:
    case "OPEN_PROMPT_BAR":
      return PromptBarType.OPEN_PROMPT_BAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PromptBarType.UNRECOGNIZED;
  }
}

export function promptBarTypeToJSON(object: PromptBarType): string {
  switch (object) {
    case PromptBarType.PROMPT_BAR_TYPE_UNKNOWN:
      return "PROMPT_BAR_TYPE_UNKNOWN";
    case PromptBarType.OPEN_PROMPT_BAR:
      return "OPEN_PROMPT_BAR";
    case PromptBarType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PromptBarStyle {
  PROMPT_BAR_STYLE_UNKNOWN = 0,
  TEXT = 1,
  CURING_BENEFITS = 2,
  CARD_OPENING_GIFT = 3,
  COUNTDOWN = 4,
  UNRECOGNIZED = -1,
}

export function promptBarStyleFromJSON(object: any): PromptBarStyle {
  switch (object) {
    case 0:
    case "PROMPT_BAR_STYLE_UNKNOWN":
      return PromptBarStyle.PROMPT_BAR_STYLE_UNKNOWN;
    case 1:
    case "TEXT":
      return PromptBarStyle.TEXT;
    case 2:
    case "CURING_BENEFITS":
      return PromptBarStyle.CURING_BENEFITS;
    case 3:
    case "CARD_OPENING_GIFT":
      return PromptBarStyle.CARD_OPENING_GIFT;
    case 4:
    case "COUNTDOWN":
      return PromptBarStyle.COUNTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PromptBarStyle.UNRECOGNIZED;
  }
}

export function promptBarStyleToJSON(object: PromptBarStyle): string {
  switch (object) {
    case PromptBarStyle.PROMPT_BAR_STYLE_UNKNOWN:
      return "PROMPT_BAR_STYLE_UNKNOWN";
    case PromptBarStyle.TEXT:
      return "TEXT";
    case PromptBarStyle.CURING_BENEFITS:
      return "CURING_BENEFITS";
    case PromptBarStyle.CARD_OPENING_GIFT:
      return "CARD_OPENING_GIFT";
    case PromptBarStyle.COUNTDOWN:
      return "COUNTDOWN";
    case PromptBarStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ViewInfo {
  dialogMap: { [key: string]: Dialog };
  promptBar: PromptBar | undefined;
  toasts: ComprehensiveToast[];
}

export interface ViewInfo_DialogMapEntry {
  key: string;
  value: Dialog | undefined;
}

export interface Dialog {
  styleType: GuideStyle;
  backgroundInfo: BackgroundInfo | undefined;
  title: TextInfo | undefined;
  subtitle: TextInfo | undefined;
  image: ImageInfo | undefined;
  button: ButtonInfo[];
  bottomDesc: ButtonInfo | undefined;
  report: Report | undefined;
  countDownSec: number;
  rightBottomDesc: TextInfo | undefined;
  bottomDisplay: BottomDisplay[];
  extData: ExtData | undefined;
  limitActionType: LimitActionType;
  isHideMoreBtn: number;
}

export interface BackgroundInfo {
  drawableColor: string;
  drawableBitmapUrl: string;
  effects: number;
}

export interface TextInfo {
  text: string;
  textColor: string;
  textColorNight: string;
}

export interface ImageInfo {
  url: string;
}

export interface ButtonInfo {
  text: string;
  textColor: string;
  textColorNight: string;
  bgColor: string;
  bgColorNight: string;
  link: string;
  actionType: ButtonAction;
  badgeInfo: BadgeInfo | undefined;
  report: Report | undefined;
  leftStrikethroughText: string;
  simpleTextInfo: TextInfo | undefined;
  simpleBgColor: string;
  simpleBgColorNight: string;
  bgGradientColor: GradientColor | undefined;
  orderReportParams: { [key: string]: string };
  taskParam: TaskParam | undefined;
  frameColor: string;
  icon: string;
}

export interface ButtonInfo_OrderReportParamsEntry {
  key: string;
  value: string;
}

export interface BadgeInfo {
  text: string;
  bgColor: string;
  bgColorNight: string;
  textColor: string;
  bgGradientColor: GradientColor | undefined;
  img: string;
}

export interface GradientColor {
  startColor: string;
  endColor: string;
}

export interface Report {
  showEventId: string;
  clickEventId: string;
  extends: string;
}

export interface TaskParam {
  taskType: string;
  activityId: bigint;
  tipsId: bigint;
}

export interface BottomDisplay {
  title: TextInfo | undefined;
  icon: string;
}

export interface ExtData {
  type: ExtDataType;
  playListInfo?: PlayListInfo | undefined;
}

export interface PlayListInfo {
  playList: PlayList[];
}

export interface PlayList {
  seasonId: bigint;
  title: string;
  cover: string;
  link: string;
  badgeInfo: BadgeInfo | undefined;
}

/** 视频下方广告 Banner */
export interface PromptBar {
  title: TextInfo | undefined;
  subtitle: TextInfo | undefined;
  subTitleIcon: string;
  bgImage: string;
  bgGradientColor: GradientColor | undefined;
  button: ButtonInfo[];
  report: Report | undefined;
  fullScreenIpIcon: string;
  fullScreenBgGradientColor: GradientColor | undefined;
  promptBarType: PromptBarType;
  promptBarStyle: PromptBarStyle;
  benefitInfos: BenefitInfo[];
  endTime: bigint;
}

export interface BenefitInfo {
  title: string;
  icon: string;
}

export interface ComprehensiveToast {
  type: number;
  button: ButtonInfo | undefined;
  showStyleType: number;
  icon: string;
  toastText: TextInfo | undefined;
  report: Report | undefined;
  orderReportParams: { [key: string]: string };
}

export interface ComprehensiveToast_OrderReportParamsEntry {
  key: string;
  value: string;
}

function createBaseViewInfo(): ViewInfo {
  return { dialogMap: {}, promptBar: undefined, toasts: [] };
}

export const ViewInfo: MessageFns<ViewInfo> = {
  encode(message: ViewInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.dialogMap).forEach(([key, value]) => {
      ViewInfo_DialogMapEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.promptBar !== undefined) {
      PromptBar.encode(message.promptBar, writer.uint32(18).fork()).join();
    }
    for (const v of message.toasts) {
      ComprehensiveToast.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ViewInfo_DialogMapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.dialogMap[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.promptBar = PromptBar.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toasts.push(ComprehensiveToast.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo {
    return {
      dialogMap: isObject(object.dialogMap)
        ? Object.entries(object.dialogMap).reduce<{ [key: string]: Dialog }>((acc, [key, value]) => {
          acc[key] = Dialog.fromJSON(value);
          return acc;
        }, {})
        : {},
      promptBar: isSet(object.promptBar) ? PromptBar.fromJSON(object.promptBar) : undefined,
      toasts: globalThis.Array.isArray(object?.toasts)
        ? object.toasts.map((e: any) => ComprehensiveToast.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ViewInfo): unknown {
    const obj: any = {};
    if (message.dialogMap) {
      const entries = Object.entries(message.dialogMap);
      if (entries.length > 0) {
        obj.dialogMap = {};
        entries.forEach(([k, v]) => {
          obj.dialogMap[k] = Dialog.toJSON(v);
        });
      }
    }
    if (message.promptBar !== undefined) {
      obj.promptBar = PromptBar.toJSON(message.promptBar);
    }
    if (message.toasts?.length) {
      obj.toasts = message.toasts.map((e) => ComprehensiveToast.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo>, I>>(base?: I): ViewInfo {
    return ViewInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo>, I>>(object: I): ViewInfo {
    const message = createBaseViewInfo();
    message.dialogMap = Object.entries(object.dialogMap ?? {}).reduce<{ [key: string]: Dialog }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Dialog.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.promptBar = (object.promptBar !== undefined && object.promptBar !== null)
      ? PromptBar.fromPartial(object.promptBar)
      : undefined;
    message.toasts = object.toasts?.map((e) => ComprehensiveToast.fromPartial(e)) || [];
    return message;
  },
};

function createBaseViewInfo_DialogMapEntry(): ViewInfo_DialogMapEntry {
  return { key: "", value: undefined };
}

export const ViewInfo_DialogMapEntry: MessageFns<ViewInfo_DialogMapEntry> = {
  encode(message: ViewInfo_DialogMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Dialog.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewInfo_DialogMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewInfo_DialogMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Dialog.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewInfo_DialogMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Dialog.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ViewInfo_DialogMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Dialog.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewInfo_DialogMapEntry>, I>>(base?: I): ViewInfo_DialogMapEntry {
    return ViewInfo_DialogMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewInfo_DialogMapEntry>, I>>(object: I): ViewInfo_DialogMapEntry {
    const message = createBaseViewInfo_DialogMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Dialog.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDialog(): Dialog {
  return {
    styleType: 0,
    backgroundInfo: undefined,
    title: undefined,
    subtitle: undefined,
    image: undefined,
    button: [],
    bottomDesc: undefined,
    report: undefined,
    countDownSec: 0,
    rightBottomDesc: undefined,
    bottomDisplay: [],
    extData: undefined,
    limitActionType: 0,
    isHideMoreBtn: 0,
  };
}

export const Dialog: MessageFns<Dialog> = {
  encode(message: Dialog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.styleType !== 0) {
      writer.uint32(8).int32(message.styleType);
    }
    if (message.backgroundInfo !== undefined) {
      BackgroundInfo.encode(message.backgroundInfo, writer.uint32(18).fork()).join();
    }
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(26).fork()).join();
    }
    if (message.subtitle !== undefined) {
      TextInfo.encode(message.subtitle, writer.uint32(34).fork()).join();
    }
    if (message.image !== undefined) {
      ImageInfo.encode(message.image, writer.uint32(42).fork()).join();
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.bottomDesc !== undefined) {
      ButtonInfo.encode(message.bottomDesc, writer.uint32(58).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(66).fork()).join();
    }
    if (message.countDownSec !== 0) {
      writer.uint32(72).int32(message.countDownSec);
    }
    if (message.rightBottomDesc !== undefined) {
      TextInfo.encode(message.rightBottomDesc, writer.uint32(82).fork()).join();
    }
    for (const v of message.bottomDisplay) {
      BottomDisplay.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.extData !== undefined) {
      ExtData.encode(message.extData, writer.uint32(98).fork()).join();
    }
    if (message.limitActionType !== 0) {
      writer.uint32(104).int32(message.limitActionType);
    }
    if (message.isHideMoreBtn !== 0) {
      writer.uint32(112).int32(message.isHideMoreBtn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dialog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.styleType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backgroundInfo = BackgroundInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subtitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.image = ImageInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bottomDesc = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.countDownSec = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rightBottomDesc = TextInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.bottomDisplay.push(BottomDisplay.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.extData = ExtData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.limitActionType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isHideMoreBtn = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dialog {
    return {
      styleType: isSet(object.styleType) ? guideStyleFromJSON(object.styleType) : 0,
      backgroundInfo: isSet(object.backgroundInfo) ? BackgroundInfo.fromJSON(object.backgroundInfo) : undefined,
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      subtitle: isSet(object.subtitle) ? TextInfo.fromJSON(object.subtitle) : undefined,
      image: isSet(object.image) ? ImageInfo.fromJSON(object.image) : undefined,
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      bottomDesc: isSet(object.bottomDesc) ? ButtonInfo.fromJSON(object.bottomDesc) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      countDownSec: isSet(object.countDownSec) ? globalThis.Number(object.countDownSec) : 0,
      rightBottomDesc: isSet(object.rightBottomDesc) ? TextInfo.fromJSON(object.rightBottomDesc) : undefined,
      bottomDisplay: globalThis.Array.isArray(object?.bottomDisplay)
        ? object.bottomDisplay.map((e: any) => BottomDisplay.fromJSON(e))
        : [],
      extData: isSet(object.extData) ? ExtData.fromJSON(object.extData) : undefined,
      limitActionType: isSet(object.limitActionType) ? limitActionTypeFromJSON(object.limitActionType) : 0,
      isHideMoreBtn: isSet(object.isHideMoreBtn) ? globalThis.Number(object.isHideMoreBtn) : 0,
    };
  },

  toJSON(message: Dialog): unknown {
    const obj: any = {};
    if (message.styleType !== 0) {
      obj.styleType = guideStyleToJSON(message.styleType);
    }
    if (message.backgroundInfo !== undefined) {
      obj.backgroundInfo = BackgroundInfo.toJSON(message.backgroundInfo);
    }
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.subtitle !== undefined) {
      obj.subtitle = TextInfo.toJSON(message.subtitle);
    }
    if (message.image !== undefined) {
      obj.image = ImageInfo.toJSON(message.image);
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.bottomDesc !== undefined) {
      obj.bottomDesc = ButtonInfo.toJSON(message.bottomDesc);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.countDownSec !== 0) {
      obj.countDownSec = Math.round(message.countDownSec);
    }
    if (message.rightBottomDesc !== undefined) {
      obj.rightBottomDesc = TextInfo.toJSON(message.rightBottomDesc);
    }
    if (message.bottomDisplay?.length) {
      obj.bottomDisplay = message.bottomDisplay.map((e) => BottomDisplay.toJSON(e));
    }
    if (message.extData !== undefined) {
      obj.extData = ExtData.toJSON(message.extData);
    }
    if (message.limitActionType !== 0) {
      obj.limitActionType = limitActionTypeToJSON(message.limitActionType);
    }
    if (message.isHideMoreBtn !== 0) {
      obj.isHideMoreBtn = Math.round(message.isHideMoreBtn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dialog>, I>>(base?: I): Dialog {
    return Dialog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dialog>, I>>(object: I): Dialog {
    const message = createBaseDialog();
    message.styleType = object.styleType ?? 0;
    message.backgroundInfo = (object.backgroundInfo !== undefined && object.backgroundInfo !== null)
      ? BackgroundInfo.fromPartial(object.backgroundInfo)
      : undefined;
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.subtitle = (object.subtitle !== undefined && object.subtitle !== null)
      ? TextInfo.fromPartial(object.subtitle)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? ImageInfo.fromPartial(object.image)
      : undefined;
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.bottomDesc = (object.bottomDesc !== undefined && object.bottomDesc !== null)
      ? ButtonInfo.fromPartial(object.bottomDesc)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.countDownSec = object.countDownSec ?? 0;
    message.rightBottomDesc = (object.rightBottomDesc !== undefined && object.rightBottomDesc !== null)
      ? TextInfo.fromPartial(object.rightBottomDesc)
      : undefined;
    message.bottomDisplay = object.bottomDisplay?.map((e) => BottomDisplay.fromPartial(e)) || [];
    message.extData = (object.extData !== undefined && object.extData !== null)
      ? ExtData.fromPartial(object.extData)
      : undefined;
    message.limitActionType = object.limitActionType ?? 0;
    message.isHideMoreBtn = object.isHideMoreBtn ?? 0;
    return message;
  },
};

function createBaseBackgroundInfo(): BackgroundInfo {
  return { drawableColor: "", drawableBitmapUrl: "", effects: 0 };
}

export const BackgroundInfo: MessageFns<BackgroundInfo> = {
  encode(message: BackgroundInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.drawableColor !== "") {
      writer.uint32(10).string(message.drawableColor);
    }
    if (message.drawableBitmapUrl !== "") {
      writer.uint32(18).string(message.drawableBitmapUrl);
    }
    if (message.effects !== 0) {
      writer.uint32(24).int32(message.effects);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.drawableColor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.drawableBitmapUrl = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.effects = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundInfo {
    return {
      drawableColor: isSet(object.drawableColor) ? globalThis.String(object.drawableColor) : "",
      drawableBitmapUrl: isSet(object.drawableBitmapUrl) ? globalThis.String(object.drawableBitmapUrl) : "",
      effects: isSet(object.effects) ? globalThis.Number(object.effects) : 0,
    };
  },

  toJSON(message: BackgroundInfo): unknown {
    const obj: any = {};
    if (message.drawableColor !== "") {
      obj.drawableColor = message.drawableColor;
    }
    if (message.drawableBitmapUrl !== "") {
      obj.drawableBitmapUrl = message.drawableBitmapUrl;
    }
    if (message.effects !== 0) {
      obj.effects = Math.round(message.effects);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundInfo>, I>>(base?: I): BackgroundInfo {
    return BackgroundInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundInfo>, I>>(object: I): BackgroundInfo {
    const message = createBaseBackgroundInfo();
    message.drawableColor = object.drawableColor ?? "";
    message.drawableBitmapUrl = object.drawableBitmapUrl ?? "";
    message.effects = object.effects ?? 0;
    return message;
  },
};

function createBaseTextInfo(): TextInfo {
  return { text: "", textColor: "", textColorNight: "" };
}

export const TextInfo: MessageFns<TextInfo> = {
  encode(message: TextInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(18).string(message.textColor);
    }
    if (message.textColorNight !== "") {
      writer.uint32(26).string(message.textColorNight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textColorNight = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      textColorNight: isSet(object.textColorNight) ? globalThis.String(object.textColorNight) : "",
    };
  },

  toJSON(message: TextInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textColorNight !== "") {
      obj.textColorNight = message.textColorNight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInfo>, I>>(base?: I): TextInfo {
    return TextInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInfo>, I>>(object: I): TextInfo {
    const message = createBaseTextInfo();
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textColorNight = object.textColorNight ?? "";
    return message;
  },
};

function createBaseImageInfo(): ImageInfo {
  return { url: "" };
}

export const ImageInfo: MessageFns<ImageInfo> = {
  encode(message: ImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageInfo {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: ImageInfo): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageInfo>, I>>(base?: I): ImageInfo {
    return ImageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageInfo>, I>>(object: I): ImageInfo {
    const message = createBaseImageInfo();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseButtonInfo(): ButtonInfo {
  return {
    text: "",
    textColor: "",
    textColorNight: "",
    bgColor: "",
    bgColorNight: "",
    link: "",
    actionType: 0,
    badgeInfo: undefined,
    report: undefined,
    leftStrikethroughText: "",
    simpleTextInfo: undefined,
    simpleBgColor: "",
    simpleBgColorNight: "",
    bgGradientColor: undefined,
    orderReportParams: {},
    taskParam: undefined,
    frameColor: "",
    icon: "",
  };
}

export const ButtonInfo: MessageFns<ButtonInfo> = {
  encode(message: ButtonInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.textColor !== "") {
      writer.uint32(18).string(message.textColor);
    }
    if (message.textColorNight !== "") {
      writer.uint32(26).string(message.textColorNight);
    }
    if (message.bgColor !== "") {
      writer.uint32(34).string(message.bgColor);
    }
    if (message.bgColorNight !== "") {
      writer.uint32(42).string(message.bgColorNight);
    }
    if (message.link !== "") {
      writer.uint32(50).string(message.link);
    }
    if (message.actionType !== 0) {
      writer.uint32(56).int32(message.actionType);
    }
    if (message.badgeInfo !== undefined) {
      BadgeInfo.encode(message.badgeInfo, writer.uint32(66).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(74).fork()).join();
    }
    if (message.leftStrikethroughText !== "") {
      writer.uint32(82).string(message.leftStrikethroughText);
    }
    if (message.simpleTextInfo !== undefined) {
      TextInfo.encode(message.simpleTextInfo, writer.uint32(90).fork()).join();
    }
    if (message.simpleBgColor !== "") {
      writer.uint32(98).string(message.simpleBgColor);
    }
    if (message.simpleBgColorNight !== "") {
      writer.uint32(106).string(message.simpleBgColorNight);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(114).fork()).join();
    }
    Object.entries(message.orderReportParams).forEach(([key, value]) => {
      ButtonInfo_OrderReportParamsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.taskParam !== undefined) {
      TaskParam.encode(message.taskParam, writer.uint32(130).fork()).join();
    }
    if (message.frameColor !== "") {
      writer.uint32(138).string(message.frameColor);
    }
    if (message.icon !== "") {
      writer.uint32(146).string(message.icon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ButtonInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textColorNight = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bgColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgColorNight = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.link = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.badgeInfo = BadgeInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.leftStrikethroughText = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.simpleTextInfo = TextInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.simpleBgColor = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.simpleBgColorNight = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = ButtonInfo_OrderReportParamsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.orderReportParams[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.taskParam = TaskParam.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.frameColor = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      textColorNight: isSet(object.textColorNight) ? globalThis.String(object.textColorNight) : "",
      bgColor: isSet(object.bgColor) ? globalThis.String(object.bgColor) : "",
      bgColorNight: isSet(object.bgColorNight) ? globalThis.String(object.bgColorNight) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      actionType: isSet(object.actionType) ? buttonActionFromJSON(object.actionType) : 0,
      badgeInfo: isSet(object.badgeInfo) ? BadgeInfo.fromJSON(object.badgeInfo) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      leftStrikethroughText: isSet(object.leftStrikethroughText) ? globalThis.String(object.leftStrikethroughText) : "",
      simpleTextInfo: isSet(object.simpleTextInfo) ? TextInfo.fromJSON(object.simpleTextInfo) : undefined,
      simpleBgColor: isSet(object.simpleBgColor) ? globalThis.String(object.simpleBgColor) : "",
      simpleBgColorNight: isSet(object.simpleBgColorNight) ? globalThis.String(object.simpleBgColorNight) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      orderReportParams: isObject(object.orderReportParams)
        ? Object.entries(object.orderReportParams).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      taskParam: isSet(object.taskParam) ? TaskParam.fromJSON(object.taskParam) : undefined,
      frameColor: isSet(object.frameColor) ? globalThis.String(object.frameColor) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
    };
  },

  toJSON(message: ButtonInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.textColorNight !== "") {
      obj.textColorNight = message.textColorNight;
    }
    if (message.bgColor !== "") {
      obj.bgColor = message.bgColor;
    }
    if (message.bgColorNight !== "") {
      obj.bgColorNight = message.bgColorNight;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.actionType !== 0) {
      obj.actionType = buttonActionToJSON(message.actionType);
    }
    if (message.badgeInfo !== undefined) {
      obj.badgeInfo = BadgeInfo.toJSON(message.badgeInfo);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.leftStrikethroughText !== "") {
      obj.leftStrikethroughText = message.leftStrikethroughText;
    }
    if (message.simpleTextInfo !== undefined) {
      obj.simpleTextInfo = TextInfo.toJSON(message.simpleTextInfo);
    }
    if (message.simpleBgColor !== "") {
      obj.simpleBgColor = message.simpleBgColor;
    }
    if (message.simpleBgColorNight !== "") {
      obj.simpleBgColorNight = message.simpleBgColorNight;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.orderReportParams) {
      const entries = Object.entries(message.orderReportParams);
      if (entries.length > 0) {
        obj.orderReportParams = {};
        entries.forEach(([k, v]) => {
          obj.orderReportParams[k] = v;
        });
      }
    }
    if (message.taskParam !== undefined) {
      obj.taskParam = TaskParam.toJSON(message.taskParam);
    }
    if (message.frameColor !== "") {
      obj.frameColor = message.frameColor;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonInfo>, I>>(base?: I): ButtonInfo {
    return ButtonInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonInfo>, I>>(object: I): ButtonInfo {
    const message = createBaseButtonInfo();
    message.text = object.text ?? "";
    message.textColor = object.textColor ?? "";
    message.textColorNight = object.textColorNight ?? "";
    message.bgColor = object.bgColor ?? "";
    message.bgColorNight = object.bgColorNight ?? "";
    message.link = object.link ?? "";
    message.actionType = object.actionType ?? 0;
    message.badgeInfo = (object.badgeInfo !== undefined && object.badgeInfo !== null)
      ? BadgeInfo.fromPartial(object.badgeInfo)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.leftStrikethroughText = object.leftStrikethroughText ?? "";
    message.simpleTextInfo = (object.simpleTextInfo !== undefined && object.simpleTextInfo !== null)
      ? TextInfo.fromPartial(object.simpleTextInfo)
      : undefined;
    message.simpleBgColor = object.simpleBgColor ?? "";
    message.simpleBgColorNight = object.simpleBgColorNight ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.orderReportParams = Object.entries(object.orderReportParams ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.taskParam = (object.taskParam !== undefined && object.taskParam !== null)
      ? TaskParam.fromPartial(object.taskParam)
      : undefined;
    message.frameColor = object.frameColor ?? "";
    message.icon = object.icon ?? "";
    return message;
  },
};

function createBaseButtonInfo_OrderReportParamsEntry(): ButtonInfo_OrderReportParamsEntry {
  return { key: "", value: "" };
}

export const ButtonInfo_OrderReportParamsEntry: MessageFns<ButtonInfo_OrderReportParamsEntry> = {
  encode(message: ButtonInfo_OrderReportParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ButtonInfo_OrderReportParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonInfo_OrderReportParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonInfo_OrderReportParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ButtonInfo_OrderReportParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonInfo_OrderReportParamsEntry>, I>>(
    base?: I,
  ): ButtonInfo_OrderReportParamsEntry {
    return ButtonInfo_OrderReportParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonInfo_OrderReportParamsEntry>, I>>(
    object: I,
  ): ButtonInfo_OrderReportParamsEntry {
    const message = createBaseButtonInfo_OrderReportParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBadgeInfo(): BadgeInfo {
  return { text: "", bgColor: "", bgColorNight: "", textColor: "", bgGradientColor: undefined, img: "" };
}

export const BadgeInfo: MessageFns<BadgeInfo> = {
  encode(message: BadgeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.bgColor !== "") {
      writer.uint32(18).string(message.bgColor);
    }
    if (message.bgColorNight !== "") {
      writer.uint32(26).string(message.bgColorNight);
    }
    if (message.textColor !== "") {
      writer.uint32(34).string(message.textColor);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(42).fork()).join();
    }
    if (message.img !== "") {
      writer.uint32(50).string(message.img);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bgColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bgColorNight = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.img = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BadgeInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      bgColor: isSet(object.bgColor) ? globalThis.String(object.bgColor) : "",
      bgColorNight: isSet(object.bgColorNight) ? globalThis.String(object.bgColorNight) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      img: isSet(object.img) ? globalThis.String(object.img) : "",
    };
  },

  toJSON(message: BadgeInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.bgColor !== "") {
      obj.bgColor = message.bgColor;
    }
    if (message.bgColorNight !== "") {
      obj.bgColorNight = message.bgColorNight;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.img !== "") {
      obj.img = message.img;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadgeInfo>, I>>(base?: I): BadgeInfo {
    return BadgeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeInfo>, I>>(object: I): BadgeInfo {
    const message = createBaseBadgeInfo();
    message.text = object.text ?? "";
    message.bgColor = object.bgColor ?? "";
    message.bgColorNight = object.bgColorNight ?? "";
    message.textColor = object.textColor ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.img = object.img ?? "";
    return message;
  },
};

function createBaseGradientColor(): GradientColor {
  return { startColor: "", endColor: "" };
}

export const GradientColor: MessageFns<GradientColor> = {
  encode(message: GradientColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startColor !== "") {
      writer.uint32(10).string(message.startColor);
    }
    if (message.endColor !== "") {
      writer.uint32(18).string(message.endColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GradientColor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGradientColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startColor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GradientColor {
    return {
      startColor: isSet(object.startColor) ? globalThis.String(object.startColor) : "",
      endColor: isSet(object.endColor) ? globalThis.String(object.endColor) : "",
    };
  },

  toJSON(message: GradientColor): unknown {
    const obj: any = {};
    if (message.startColor !== "") {
      obj.startColor = message.startColor;
    }
    if (message.endColor !== "") {
      obj.endColor = message.endColor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GradientColor>, I>>(base?: I): GradientColor {
    return GradientColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GradientColor>, I>>(object: I): GradientColor {
    const message = createBaseGradientColor();
    message.startColor = object.startColor ?? "";
    message.endColor = object.endColor ?? "";
    return message;
  },
};

function createBaseReport(): Report {
  return { showEventId: "", clickEventId: "", extends: "" };
}

export const Report: MessageFns<Report> = {
  encode(message: Report, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.showEventId !== "") {
      writer.uint32(10).string(message.showEventId);
    }
    if (message.clickEventId !== "") {
      writer.uint32(18).string(message.clickEventId);
    }
    if (message.extends !== "") {
      writer.uint32(26).string(message.extends);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.showEventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clickEventId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extends = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report {
    return {
      showEventId: isSet(object.showEventId) ? globalThis.String(object.showEventId) : "",
      clickEventId: isSet(object.clickEventId) ? globalThis.String(object.clickEventId) : "",
      extends: isSet(object.extends) ? globalThis.String(object.extends) : "",
    };
  },

  toJSON(message: Report): unknown {
    const obj: any = {};
    if (message.showEventId !== "") {
      obj.showEventId = message.showEventId;
    }
    if (message.clickEventId !== "") {
      obj.clickEventId = message.clickEventId;
    }
    if (message.extends !== "") {
      obj.extends = message.extends;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Report>, I>>(base?: I): Report {
    return Report.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Report>, I>>(object: I): Report {
    const message = createBaseReport();
    message.showEventId = object.showEventId ?? "";
    message.clickEventId = object.clickEventId ?? "";
    message.extends = object.extends ?? "";
    return message;
  },
};

function createBaseTaskParam(): TaskParam {
  return { taskType: "", activityId: 0n, tipsId: 0n };
}

export const TaskParam: MessageFns<TaskParam> = {
  encode(message: TaskParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskType !== "") {
      writer.uint32(10).string(message.taskType);
    }
    if (message.activityId !== 0n) {
      if (BigInt.asIntN(64, message.activityId) !== message.activityId) {
        throw new globalThis.Error("value provided for field message.activityId of type int64 too large");
      }
      writer.uint32(16).int64(message.activityId);
    }
    if (message.tipsId !== 0n) {
      if (BigInt.asIntN(64, message.tipsId) !== message.tipsId) {
        throw new globalThis.Error("value provided for field message.tipsId of type int64 too large");
      }
      writer.uint32(24).int64(message.tipsId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.activityId = reader.int64() as bigint;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tipsId = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskParam {
    return {
      taskType: isSet(object.taskType) ? globalThis.String(object.taskType) : "",
      activityId: isSet(object.activityId) ? BigInt(object.activityId) : 0n,
      tipsId: isSet(object.tipsId) ? BigInt(object.tipsId) : 0n,
    };
  },

  toJSON(message: TaskParam): unknown {
    const obj: any = {};
    if (message.taskType !== "") {
      obj.taskType = message.taskType;
    }
    if (message.activityId !== 0n) {
      obj.activityId = message.activityId.toString();
    }
    if (message.tipsId !== 0n) {
      obj.tipsId = message.tipsId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskParam>, I>>(base?: I): TaskParam {
    return TaskParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskParam>, I>>(object: I): TaskParam {
    const message = createBaseTaskParam();
    message.taskType = object.taskType ?? "";
    message.activityId = object.activityId ?? 0n;
    message.tipsId = object.tipsId ?? 0n;
    return message;
  },
};

function createBaseBottomDisplay(): BottomDisplay {
  return { title: undefined, icon: "" };
}

export const BottomDisplay: MessageFns<BottomDisplay> = {
  encode(message: BottomDisplay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(10).fork()).join();
    }
    if (message.icon !== "") {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BottomDisplay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBottomDisplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BottomDisplay {
    return {
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
    };
  },

  toJSON(message: BottomDisplay): unknown {
    const obj: any = {};
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BottomDisplay>, I>>(base?: I): BottomDisplay {
    return BottomDisplay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BottomDisplay>, I>>(object: I): BottomDisplay {
    const message = createBaseBottomDisplay();
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.icon = object.icon ?? "";
    return message;
  },
};

function createBaseExtData(): ExtData {
  return { type: 0 };
}

export const ExtData: MessageFns<ExtData> = {
  encode(message: ExtData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.playListInfo !== undefined) {
      PlayListInfo.encode(message.playListInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playListInfo = PlayListInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtData {
    return {
      type: isSet(object.type) ? extDataTypeFromJSON(object.type) : 0,
      playListInfo: isSet(object.playListInfo) ? PlayListInfo.fromJSON(object.playListInfo) : undefined,
    };
  },

  toJSON(message: ExtData): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = extDataTypeToJSON(message.type);
    }
    if (message.playListInfo !== undefined) {
      obj.playListInfo = PlayListInfo.toJSON(message.playListInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtData>, I>>(base?: I): ExtData {
    return ExtData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtData>, I>>(object: I): ExtData {
    const message = createBaseExtData();
    message.type = object.type ?? 0;
    message.playListInfo = (object.playListInfo !== undefined && object.playListInfo !== null)
      ? PlayListInfo.fromPartial(object.playListInfo)
      : undefined;
    return message;
  },
};

function createBasePlayListInfo(): PlayListInfo {
  return { playList: [] };
}

export const PlayListInfo: MessageFns<PlayListInfo> = {
  encode(message: PlayListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playList) {
      PlayList.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playList.push(PlayList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayListInfo {
    return {
      playList: globalThis.Array.isArray(object?.playList) ? object.playList.map((e: any) => PlayList.fromJSON(e)) : [],
    };
  },

  toJSON(message: PlayListInfo): unknown {
    const obj: any = {};
    if (message.playList?.length) {
      obj.playList = message.playList.map((e) => PlayList.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayListInfo>, I>>(base?: I): PlayListInfo {
    return PlayListInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayListInfo>, I>>(object: I): PlayListInfo {
    const message = createBasePlayListInfo();
    message.playList = object.playList?.map((e) => PlayList.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayList(): PlayList {
  return { seasonId: 0n, title: "", cover: "", link: "", badgeInfo: undefined };
}

export const PlayList: MessageFns<PlayList> = {
  encode(message: PlayList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seasonId !== 0n) {
      if (BigInt.asIntN(64, message.seasonId) !== message.seasonId) {
        throw new globalThis.Error("value provided for field message.seasonId of type int64 too large");
      }
      writer.uint32(8).int64(message.seasonId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.cover !== "") {
      writer.uint32(26).string(message.cover);
    }
    if (message.link !== "") {
      writer.uint32(34).string(message.link);
    }
    if (message.badgeInfo !== undefined) {
      BadgeInfo.encode(message.badgeInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seasonId = reader.int64() as bigint;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cover = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.link = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.badgeInfo = BadgeInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayList {
    return {
      seasonId: isSet(object.seasonId) ? BigInt(object.seasonId) : 0n,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      cover: isSet(object.cover) ? globalThis.String(object.cover) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      badgeInfo: isSet(object.badgeInfo) ? BadgeInfo.fromJSON(object.badgeInfo) : undefined,
    };
  },

  toJSON(message: PlayList): unknown {
    const obj: any = {};
    if (message.seasonId !== 0n) {
      obj.seasonId = message.seasonId.toString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.cover !== "") {
      obj.cover = message.cover;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.badgeInfo !== undefined) {
      obj.badgeInfo = BadgeInfo.toJSON(message.badgeInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayList>, I>>(base?: I): PlayList {
    return PlayList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayList>, I>>(object: I): PlayList {
    const message = createBasePlayList();
    message.seasonId = object.seasonId ?? 0n;
    message.title = object.title ?? "";
    message.cover = object.cover ?? "";
    message.link = object.link ?? "";
    message.badgeInfo = (object.badgeInfo !== undefined && object.badgeInfo !== null)
      ? BadgeInfo.fromPartial(object.badgeInfo)
      : undefined;
    return message;
  },
};

function createBasePromptBar(): PromptBar {
  return {
    title: undefined,
    subtitle: undefined,
    subTitleIcon: "",
    bgImage: "",
    bgGradientColor: undefined,
    button: [],
    report: undefined,
    fullScreenIpIcon: "",
    fullScreenBgGradientColor: undefined,
    promptBarType: 0,
    promptBarStyle: 0,
    benefitInfos: [],
    endTime: 0n,
  };
}

export const PromptBar: MessageFns<PromptBar> = {
  encode(message: PromptBar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      TextInfo.encode(message.title, writer.uint32(10).fork()).join();
    }
    if (message.subtitle !== undefined) {
      TextInfo.encode(message.subtitle, writer.uint32(18).fork()).join();
    }
    if (message.subTitleIcon !== "") {
      writer.uint32(26).string(message.subTitleIcon);
    }
    if (message.bgImage !== "") {
      writer.uint32(34).string(message.bgImage);
    }
    if (message.bgGradientColor !== undefined) {
      GradientColor.encode(message.bgGradientColor, writer.uint32(42).fork()).join();
    }
    for (const v of message.button) {
      ButtonInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(58).fork()).join();
    }
    if (message.fullScreenIpIcon !== "") {
      writer.uint32(66).string(message.fullScreenIpIcon);
    }
    if (message.fullScreenBgGradientColor !== undefined) {
      GradientColor.encode(message.fullScreenBgGradientColor, writer.uint32(74).fork()).join();
    }
    if (message.promptBarType !== 0) {
      writer.uint32(80).int32(message.promptBarType);
    }
    if (message.promptBarStyle !== 0) {
      writer.uint32(88).int32(message.promptBarStyle);
    }
    for (const v of message.benefitInfos) {
      BenefitInfo.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.endTime !== 0n) {
      if (BigInt.asIntN(64, message.endTime) !== message.endTime) {
        throw new globalThis.Error("value provided for field message.endTime of type int64 too large");
      }
      writer.uint32(104).int64(message.endTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromptBar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromptBar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = TextInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subtitle = TextInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subTitleIcon = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bgImage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.button.push(ButtonInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fullScreenIpIcon = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fullScreenBgGradientColor = GradientColor.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.promptBarType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.promptBarStyle = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.benefitInfos.push(BenefitInfo.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.endTime = reader.int64() as bigint;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromptBar {
    return {
      title: isSet(object.title) ? TextInfo.fromJSON(object.title) : undefined,
      subtitle: isSet(object.subtitle) ? TextInfo.fromJSON(object.subtitle) : undefined,
      subTitleIcon: isSet(object.subTitleIcon) ? globalThis.String(object.subTitleIcon) : "",
      bgImage: isSet(object.bgImage) ? globalThis.String(object.bgImage) : "",
      bgGradientColor: isSet(object.bgGradientColor) ? GradientColor.fromJSON(object.bgGradientColor) : undefined,
      button: globalThis.Array.isArray(object?.button) ? object.button.map((e: any) => ButtonInfo.fromJSON(e)) : [],
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      fullScreenIpIcon: isSet(object.fullScreenIpIcon) ? globalThis.String(object.fullScreenIpIcon) : "",
      fullScreenBgGradientColor: isSet(object.fullScreenBgGradientColor)
        ? GradientColor.fromJSON(object.fullScreenBgGradientColor)
        : undefined,
      promptBarType: isSet(object.promptBarType) ? promptBarTypeFromJSON(object.promptBarType) : 0,
      promptBarStyle: isSet(object.promptBarStyle) ? promptBarStyleFromJSON(object.promptBarStyle) : 0,
      benefitInfos: globalThis.Array.isArray(object?.benefitInfos)
        ? object.benefitInfos.map((e: any) => BenefitInfo.fromJSON(e))
        : [],
      endTime: isSet(object.endTime) ? BigInt(object.endTime) : 0n,
    };
  },

  toJSON(message: PromptBar): unknown {
    const obj: any = {};
    if (message.title !== undefined) {
      obj.title = TextInfo.toJSON(message.title);
    }
    if (message.subtitle !== undefined) {
      obj.subtitle = TextInfo.toJSON(message.subtitle);
    }
    if (message.subTitleIcon !== "") {
      obj.subTitleIcon = message.subTitleIcon;
    }
    if (message.bgImage !== "") {
      obj.bgImage = message.bgImage;
    }
    if (message.bgGradientColor !== undefined) {
      obj.bgGradientColor = GradientColor.toJSON(message.bgGradientColor);
    }
    if (message.button?.length) {
      obj.button = message.button.map((e) => ButtonInfo.toJSON(e));
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.fullScreenIpIcon !== "") {
      obj.fullScreenIpIcon = message.fullScreenIpIcon;
    }
    if (message.fullScreenBgGradientColor !== undefined) {
      obj.fullScreenBgGradientColor = GradientColor.toJSON(message.fullScreenBgGradientColor);
    }
    if (message.promptBarType !== 0) {
      obj.promptBarType = promptBarTypeToJSON(message.promptBarType);
    }
    if (message.promptBarStyle !== 0) {
      obj.promptBarStyle = promptBarStyleToJSON(message.promptBarStyle);
    }
    if (message.benefitInfos?.length) {
      obj.benefitInfos = message.benefitInfos.map((e) => BenefitInfo.toJSON(e));
    }
    if (message.endTime !== 0n) {
      obj.endTime = message.endTime.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PromptBar>, I>>(base?: I): PromptBar {
    return PromptBar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PromptBar>, I>>(object: I): PromptBar {
    const message = createBasePromptBar();
    message.title = (object.title !== undefined && object.title !== null)
      ? TextInfo.fromPartial(object.title)
      : undefined;
    message.subtitle = (object.subtitle !== undefined && object.subtitle !== null)
      ? TextInfo.fromPartial(object.subtitle)
      : undefined;
    message.subTitleIcon = object.subTitleIcon ?? "";
    message.bgImage = object.bgImage ?? "";
    message.bgGradientColor = (object.bgGradientColor !== undefined && object.bgGradientColor !== null)
      ? GradientColor.fromPartial(object.bgGradientColor)
      : undefined;
    message.button = object.button?.map((e) => ButtonInfo.fromPartial(e)) || [];
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.fullScreenIpIcon = object.fullScreenIpIcon ?? "";
    message.fullScreenBgGradientColor =
      (object.fullScreenBgGradientColor !== undefined && object.fullScreenBgGradientColor !== null)
        ? GradientColor.fromPartial(object.fullScreenBgGradientColor)
        : undefined;
    message.promptBarType = object.promptBarType ?? 0;
    message.promptBarStyle = object.promptBarStyle ?? 0;
    message.benefitInfos = object.benefitInfos?.map((e) => BenefitInfo.fromPartial(e)) || [];
    message.endTime = object.endTime ?? 0n;
    return message;
  },
};

function createBaseBenefitInfo(): BenefitInfo {
  return { title: "", icon: "" };
}

export const BenefitInfo: MessageFns<BenefitInfo> = {
  encode(message: BenefitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.icon !== "") {
      writer.uint32(18).string(message.icon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BenefitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBenefitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BenefitInfo {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
    };
  },

  toJSON(message: BenefitInfo): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BenefitInfo>, I>>(base?: I): BenefitInfo {
    return BenefitInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BenefitInfo>, I>>(object: I): BenefitInfo {
    const message = createBaseBenefitInfo();
    message.title = object.title ?? "";
    message.icon = object.icon ?? "";
    return message;
  },
};

function createBaseComprehensiveToast(): ComprehensiveToast {
  return {
    type: 0,
    button: undefined,
    showStyleType: 0,
    icon: "",
    toastText: undefined,
    report: undefined,
    orderReportParams: {},
  };
}

export const ComprehensiveToast: MessageFns<ComprehensiveToast> = {
  encode(message: ComprehensiveToast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.button !== undefined) {
      ButtonInfo.encode(message.button, writer.uint32(18).fork()).join();
    }
    if (message.showStyleType !== 0) {
      writer.uint32(24).int32(message.showStyleType);
    }
    if (message.icon !== "") {
      writer.uint32(34).string(message.icon);
    }
    if (message.toastText !== undefined) {
      TextInfo.encode(message.toastText, writer.uint32(42).fork()).join();
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(50).fork()).join();
    }
    Object.entries(message.orderReportParams).forEach(([key, value]) => {
      ComprehensiveToast_OrderReportParamsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComprehensiveToast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComprehensiveToast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.button = ButtonInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.showStyleType = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toastText = TextInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ComprehensiveToast_OrderReportParamsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.orderReportParams[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComprehensiveToast {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      button: isSet(object.button) ? ButtonInfo.fromJSON(object.button) : undefined,
      showStyleType: isSet(object.showStyleType) ? globalThis.Number(object.showStyleType) : 0,
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      toastText: isSet(object.toastText) ? TextInfo.fromJSON(object.toastText) : undefined,
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      orderReportParams: isObject(object.orderReportParams)
        ? Object.entries(object.orderReportParams).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ComprehensiveToast): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.button !== undefined) {
      obj.button = ButtonInfo.toJSON(message.button);
    }
    if (message.showStyleType !== 0) {
      obj.showStyleType = Math.round(message.showStyleType);
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.toastText !== undefined) {
      obj.toastText = TextInfo.toJSON(message.toastText);
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.orderReportParams) {
      const entries = Object.entries(message.orderReportParams);
      if (entries.length > 0) {
        obj.orderReportParams = {};
        entries.forEach(([k, v]) => {
          obj.orderReportParams[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComprehensiveToast>, I>>(base?: I): ComprehensiveToast {
    return ComprehensiveToast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComprehensiveToast>, I>>(object: I): ComprehensiveToast {
    const message = createBaseComprehensiveToast();
    message.type = object.type ?? 0;
    message.button = (object.button !== undefined && object.button !== null)
      ? ButtonInfo.fromPartial(object.button)
      : undefined;
    message.showStyleType = object.showStyleType ?? 0;
    message.icon = object.icon ?? "";
    message.toastText = (object.toastText !== undefined && object.toastText !== null)
      ? TextInfo.fromPartial(object.toastText)
      : undefined;
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.orderReportParams = Object.entries(object.orderReportParams ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseComprehensiveToast_OrderReportParamsEntry(): ComprehensiveToast_OrderReportParamsEntry {
  return { key: "", value: "" };
}

export const ComprehensiveToast_OrderReportParamsEntry: MessageFns<ComprehensiveToast_OrderReportParamsEntry> = {
  encode(message: ComprehensiveToast_OrderReportParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComprehensiveToast_OrderReportParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComprehensiveToast_OrderReportParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComprehensiveToast_OrderReportParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComprehensiveToast_OrderReportParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComprehensiveToast_OrderReportParamsEntry>, I>>(
    base?: I,
  ): ComprehensiveToast_OrderReportParamsEntry {
    return ComprehensiveToast_OrderReportParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComprehensiveToast_OrderReportParamsEntry>, I>>(
    object: I,
  ): ComprehensiveToast_OrderReportParamsEntry {
    const message = createBaseComprehensiveToast_OrderReportParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
